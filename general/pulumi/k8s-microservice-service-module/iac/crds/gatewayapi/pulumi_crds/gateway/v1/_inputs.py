# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ... import meta as _meta

__all__ = [
    'GRPCRouteSpecParentRefsPatchArgs',
    'GRPCRouteSpecParentRefsPatchArgsDict',
    'GRPCRouteSpecParentRefsArgs',
    'GRPCRouteSpecParentRefsArgsDict',
    'GRPCRouteSpecPatchArgs',
    'GRPCRouteSpecPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict',
    'GRPCRouteSpecRulesBackendRefsFiltersArgs',
    'GRPCRouteSpecRulesBackendRefsFiltersArgsDict',
    'GRPCRouteSpecRulesBackendRefsPatchArgs',
    'GRPCRouteSpecRulesBackendRefsPatchArgsDict',
    'GRPCRouteSpecRulesBackendRefsArgs',
    'GRPCRouteSpecRulesBackendRefsArgsDict',
    'GRPCRouteSpecRulesFiltersExtensionRefPatchArgs',
    'GRPCRouteSpecRulesFiltersExtensionRefPatchArgsDict',
    'GRPCRouteSpecRulesFiltersExtensionRefArgs',
    'GRPCRouteSpecRulesFiltersExtensionRefArgsDict',
    'GRPCRouteSpecRulesFiltersPatchArgs',
    'GRPCRouteSpecRulesFiltersPatchArgsDict',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierArgsDict',
    'GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs',
    'GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict',
    'GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs',
    'GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict',
    'GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs',
    'GRPCRouteSpecRulesFiltersRequestMirrorPatchArgsDict',
    'GRPCRouteSpecRulesFiltersRequestMirrorArgs',
    'GRPCRouteSpecRulesFiltersRequestMirrorArgsDict',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierArgsDict',
    'GRPCRouteSpecRulesFiltersArgs',
    'GRPCRouteSpecRulesFiltersArgsDict',
    'GRPCRouteSpecRulesMatchesHeadersPatchArgs',
    'GRPCRouteSpecRulesMatchesHeadersPatchArgsDict',
    'GRPCRouteSpecRulesMatchesHeadersArgs',
    'GRPCRouteSpecRulesMatchesHeadersArgsDict',
    'GRPCRouteSpecRulesMatchesMethodPatchArgs',
    'GRPCRouteSpecRulesMatchesMethodPatchArgsDict',
    'GRPCRouteSpecRulesMatchesMethodArgs',
    'GRPCRouteSpecRulesMatchesMethodArgsDict',
    'GRPCRouteSpecRulesMatchesPatchArgs',
    'GRPCRouteSpecRulesMatchesPatchArgsDict',
    'GRPCRouteSpecRulesMatchesArgs',
    'GRPCRouteSpecRulesMatchesArgsDict',
    'GRPCRouteSpecRulesPatchArgs',
    'GRPCRouteSpecRulesPatchArgsDict',
    'GRPCRouteSpecRulesArgs',
    'GRPCRouteSpecRulesArgsDict',
    'GRPCRouteSpecArgs',
    'GRPCRouteSpecArgsDict',
    'GRPCRouteStatusParentsConditionsArgs',
    'GRPCRouteStatusParentsConditionsArgsDict',
    'GRPCRouteStatusParentsParentRefArgs',
    'GRPCRouteStatusParentsParentRefArgsDict',
    'GRPCRouteStatusParentsArgs',
    'GRPCRouteStatusParentsArgsDict',
    'GRPCRouteStatusArgs',
    'GRPCRouteStatusArgsDict',
    'GRPCRouteArgs',
    'GRPCRouteArgsDict',
    'GatewayClassSpecParametersRefPatchArgs',
    'GatewayClassSpecParametersRefPatchArgsDict',
    'GatewayClassSpecParametersRefArgs',
    'GatewayClassSpecParametersRefArgsDict',
    'GatewayClassSpecPatchArgs',
    'GatewayClassSpecPatchArgsDict',
    'GatewayClassSpecArgs',
    'GatewayClassSpecArgsDict',
    'GatewayClassStatusConditionsArgs',
    'GatewayClassStatusConditionsArgsDict',
    'GatewayClassStatusArgs',
    'GatewayClassStatusArgsDict',
    'GatewayClassArgs',
    'GatewayClassArgsDict',
    'GatewaySpecAddressesPatchArgs',
    'GatewaySpecAddressesPatchArgsDict',
    'GatewaySpecAddressesArgs',
    'GatewaySpecAddressesArgsDict',
    'GatewaySpecInfrastructureParametersRefPatchArgs',
    'GatewaySpecInfrastructureParametersRefPatchArgsDict',
    'GatewaySpecInfrastructureParametersRefArgs',
    'GatewaySpecInfrastructureParametersRefArgsDict',
    'GatewaySpecInfrastructurePatchArgs',
    'GatewaySpecInfrastructurePatchArgsDict',
    'GatewaySpecInfrastructureArgs',
    'GatewaySpecInfrastructureArgsDict',
    'GatewaySpecListenersAllowedRoutesKindsPatchArgs',
    'GatewaySpecListenersAllowedRoutesKindsPatchArgsDict',
    'GatewaySpecListenersAllowedRoutesKindsArgs',
    'GatewaySpecListenersAllowedRoutesKindsArgsDict',
    'GatewaySpecListenersAllowedRoutesNamespacesPatchArgs',
    'GatewaySpecListenersAllowedRoutesNamespacesPatchArgsDict',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgsDict',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgsDict',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgsDict',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorArgsDict',
    'GatewaySpecListenersAllowedRoutesNamespacesArgs',
    'GatewaySpecListenersAllowedRoutesNamespacesArgsDict',
    'GatewaySpecListenersAllowedRoutesPatchArgs',
    'GatewaySpecListenersAllowedRoutesPatchArgsDict',
    'GatewaySpecListenersAllowedRoutesArgs',
    'GatewaySpecListenersAllowedRoutesArgsDict',
    'GatewaySpecListenersPatchArgs',
    'GatewaySpecListenersPatchArgsDict',
    'GatewaySpecListenersTlsCertificateRefsPatchArgs',
    'GatewaySpecListenersTlsCertificateRefsPatchArgsDict',
    'GatewaySpecListenersTlsCertificateRefsArgs',
    'GatewaySpecListenersTlsCertificateRefsArgsDict',
    'GatewaySpecListenersTlsPatchArgs',
    'GatewaySpecListenersTlsPatchArgsDict',
    'GatewaySpecListenersTlsArgs',
    'GatewaySpecListenersTlsArgsDict',
    'GatewaySpecListenersArgs',
    'GatewaySpecListenersArgsDict',
    'GatewaySpecPatchArgs',
    'GatewaySpecPatchArgsDict',
    'GatewaySpecArgs',
    'GatewaySpecArgsDict',
    'GatewayStatusAddressesArgs',
    'GatewayStatusAddressesArgsDict',
    'GatewayStatusConditionsArgs',
    'GatewayStatusConditionsArgsDict',
    'GatewayStatusListenersConditionsArgs',
    'GatewayStatusListenersConditionsArgsDict',
    'GatewayStatusListenersSupportedKindsArgs',
    'GatewayStatusListenersSupportedKindsArgsDict',
    'GatewayStatusListenersArgs',
    'GatewayStatusListenersArgsDict',
    'GatewayStatusArgs',
    'GatewayStatusArgsDict',
    'GatewayArgs',
    'GatewayArgsDict',
    'HTTPRouteSpecParentRefsPatchArgs',
    'HTTPRouteSpecParentRefsPatchArgsDict',
    'HTTPRouteSpecParentRefsArgs',
    'HTTPRouteSpecParentRefsArgsDict',
    'HTTPRouteSpecPatchArgs',
    'HTTPRouteSpecPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgsDict',
    'HTTPRouteSpecRulesBackendRefsFiltersArgs',
    'HTTPRouteSpecRulesBackendRefsFiltersArgsDict',
    'HTTPRouteSpecRulesBackendRefsPatchArgs',
    'HTTPRouteSpecRulesBackendRefsPatchArgsDict',
    'HTTPRouteSpecRulesBackendRefsArgs',
    'HTTPRouteSpecRulesBackendRefsArgsDict',
    'HTTPRouteSpecRulesFiltersExtensionRefPatchArgs',
    'HTTPRouteSpecRulesFiltersExtensionRefPatchArgsDict',
    'HTTPRouteSpecRulesFiltersExtensionRefArgs',
    'HTTPRouteSpecRulesFiltersExtensionRefArgsDict',
    'HTTPRouteSpecRulesFiltersPatchArgs',
    'HTTPRouteSpecRulesFiltersPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierArgsDict',
    'HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs',
    'HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict',
    'HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestMirrorPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestMirrorArgs',
    'HTTPRouteSpecRulesFiltersRequestMirrorArgsDict',
    'HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestRedirectPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs',
    'HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgsDict',
    'HTTPRouteSpecRulesFiltersRequestRedirectPathArgs',
    'HTTPRouteSpecRulesFiltersRequestRedirectPathArgsDict',
    'HTTPRouteSpecRulesFiltersRequestRedirectArgs',
    'HTTPRouteSpecRulesFiltersRequestRedirectArgsDict',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierArgsDict',
    'HTTPRouteSpecRulesFiltersUrlRewritePatchArgs',
    'HTTPRouteSpecRulesFiltersUrlRewritePatchArgsDict',
    'HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs',
    'HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgsDict',
    'HTTPRouteSpecRulesFiltersUrlRewritePathArgs',
    'HTTPRouteSpecRulesFiltersUrlRewritePathArgsDict',
    'HTTPRouteSpecRulesFiltersUrlRewriteArgs',
    'HTTPRouteSpecRulesFiltersUrlRewriteArgsDict',
    'HTTPRouteSpecRulesFiltersArgs',
    'HTTPRouteSpecRulesFiltersArgsDict',
    'HTTPRouteSpecRulesMatchesHeadersPatchArgs',
    'HTTPRouteSpecRulesMatchesHeadersPatchArgsDict',
    'HTTPRouteSpecRulesMatchesHeadersArgs',
    'HTTPRouteSpecRulesMatchesHeadersArgsDict',
    'HTTPRouteSpecRulesMatchesPatchArgs',
    'HTTPRouteSpecRulesMatchesPatchArgsDict',
    'HTTPRouteSpecRulesMatchesPathPatchArgs',
    'HTTPRouteSpecRulesMatchesPathPatchArgsDict',
    'HTTPRouteSpecRulesMatchesPathArgs',
    'HTTPRouteSpecRulesMatchesPathArgsDict',
    'HTTPRouteSpecRulesMatchesQueryParamsPatchArgs',
    'HTTPRouteSpecRulesMatchesQueryParamsPatchArgsDict',
    'HTTPRouteSpecRulesMatchesQueryParamsArgs',
    'HTTPRouteSpecRulesMatchesQueryParamsArgsDict',
    'HTTPRouteSpecRulesMatchesArgs',
    'HTTPRouteSpecRulesMatchesArgsDict',
    'HTTPRouteSpecRulesPatchArgs',
    'HTTPRouteSpecRulesPatchArgsDict',
    'HTTPRouteSpecRulesTimeoutsPatchArgs',
    'HTTPRouteSpecRulesTimeoutsPatchArgsDict',
    'HTTPRouteSpecRulesTimeoutsArgs',
    'HTTPRouteSpecRulesTimeoutsArgsDict',
    'HTTPRouteSpecRulesArgs',
    'HTTPRouteSpecRulesArgsDict',
    'HTTPRouteSpecArgs',
    'HTTPRouteSpecArgsDict',
    'HTTPRouteStatusParentsConditionsArgs',
    'HTTPRouteStatusParentsConditionsArgsDict',
    'HTTPRouteStatusParentsParentRefArgs',
    'HTTPRouteStatusParentsParentRefArgsDict',
    'HTTPRouteStatusParentsArgs',
    'HTTPRouteStatusParentsArgsDict',
    'HTTPRouteStatusArgs',
    'HTTPRouteStatusArgsDict',
    'HTTPRouteArgs',
    'HTTPRouteArgsDict',
]

MYPY = False

if not MYPY:
    class GRPCRouteSpecParentRefsPatchArgsDict(TypedDict):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.

        Support: Core
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        section_name: NotRequired[pulumi.Input[str]]
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
elif False:
    GRPCRouteSpecParentRefsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecParentRefsPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 section_name: Optional[pulumi.Input[str]] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param pulumi.Input[str] group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param pulumi.Input[str] kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param pulumi.Input[str] name: Name is the name of the referent.
               
               Support: Core
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param pulumi.Input[str] section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[pulumi.Input[str]]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")

    @section_name.setter
    def section_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_name", value)


if not MYPY:
    class GRPCRouteSpecParentRefsArgsDict(TypedDict):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.

        Support: Core
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        section_name: NotRequired[pulumi.Input[str]]
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
elif False:
    GRPCRouteSpecParentRefsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecParentRefsArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 section_name: Optional[pulumi.Input[str]] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param pulumi.Input[str] group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param pulumi.Input[str] kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param pulumi.Input[str] name: Name is the name of the referent.
               
               Support: Core
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param pulumi.Input[str] section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[pulumi.Input[str]]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")

    @section_name.setter
    def section_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_name", value)


if not MYPY:
    class GRPCRouteSpecPatchArgsDict(TypedDict):
        """
        Spec defines the desired state of GRPCRoute.
        """
        hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Hostnames defines a set of hostnames to match against the GRPC
        Host header to select a GRPCRoute to process the request. This matches
        the RFC 1123 definition of a hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label MUST appear by itself as the first label.

        If a hostname is specified by both the Listener and GRPCRoute, there
        MUST be at least one intersecting hostname for the GRPCRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `test.example.com` and `*.example.com` would both match. On the other
          hand, `example.com` and `test.example.net` would not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and GRPCRoute have specified hostnames, any
        GRPCRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        GRPCRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` MUST NOT be considered for a match.

        If both the Listener and GRPCRoute have specified hostnames, and none
        match with the criteria above, then the GRPCRoute MUST NOT be accepted by
        the implementation. The implementation MUST raise an 'Accepted' Condition
        with a status of `False` in the corresponding RouteParentStatus.

        If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
        Listener and that listener already has another Route (B) of the other
        type attached and the intersection of the hostnames of A and B is
        non-empty, then the implementation MUST accept exactly one of these two
        routes, determined by the following criteria, in order:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        The rejected Route MUST raise an 'Accepted' condition with a status of
        'False' in the corresponding RouteParentStatus.

        Support: Core
        """
        parent_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsPatchArgsDict']]]]
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesPatchArgsDict']]]]
        """
        Rules are a list of GRPC matchers, filters and actions.
        """
elif False:
    GRPCRouteSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecPatchArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parent_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsPatchArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesPatchArgs']]]] = None):
        """
        Spec defines the desired state of GRPCRoute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: Hostnames defines a set of hostnames to match against the GRPC
               Host header to select a GRPCRoute to process the request. This matches
               the RFC 1123 definition of a hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label MUST appear by itself as the first label.
               
               If a hostname is specified by both the Listener and GRPCRoute, there
               MUST be at least one intersecting hostname for the GRPCRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `test.example.com` and `*.example.com` would both match. On the other
                 hand, `example.com` and `test.example.net` would not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and GRPCRoute have specified hostnames, any
               GRPCRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               GRPCRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` MUST NOT be considered for a match.
               
               If both the Listener and GRPCRoute have specified hostnames, and none
               match with the criteria above, then the GRPCRoute MUST NOT be accepted by
               the implementation. The implementation MUST raise an 'Accepted' Condition
               with a status of `False` in the corresponding RouteParentStatus.
               
               If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
               Listener and that listener already has another Route (B) of the other
               type attached and the intersection of the hostnames of A and B is
               non-empty, then the implementation MUST accept exactly one of these two
               routes, determined by the following criteria, in order:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               The rejected Route MUST raise an 'Accepted' condition with a status of
               'False' in the corresponding RouteParentStatus.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsPatchArgs']]] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesPatchArgs']]] rules: Rules are a list of GRPC matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Hostnames defines a set of hostnames to match against the GRPC
        Host header to select a GRPCRoute to process the request. This matches
        the RFC 1123 definition of a hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label MUST appear by itself as the first label.

        If a hostname is specified by both the Listener and GRPCRoute, there
        MUST be at least one intersecting hostname for the GRPCRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `test.example.com` and `*.example.com` would both match. On the other
          hand, `example.com` and `test.example.net` would not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and GRPCRoute have specified hostnames, any
        GRPCRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        GRPCRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` MUST NOT be considered for a match.

        If both the Listener and GRPCRoute have specified hostnames, and none
        match with the criteria above, then the GRPCRoute MUST NOT be accepted by
        the implementation. The implementation MUST raise an 'Accepted' Condition
        with a status of `False` in the corresponding RouteParentStatus.

        If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
        Listener and that listener already has another Route (B) of the other
        type attached and the intersection of the hostnames of A and B is
        non-empty, then the implementation MUST accept exactly one of these two
        routes, determined by the following criteria, in order:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        The rejected Route MUST raise an 'Accepted' condition with a status of
        'False' in the corresponding RouteParentStatus.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsPatchArgs']]]]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @parent_refs.setter
    def parent_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsPatchArgs']]]]):
        pulumi.set(self, "parent_refs", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesPatchArgs']]]]:
        """
        Rules are a list of GRPC matchers, filters and actions.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesPatchArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersPatchArgsDict(TypedDict):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict']]
        request_mirror: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersPatchArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs']] = None,
                 request_mirror: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict']]
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict']]
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsFiltersArgsDict(TypedDict):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict']]
        request_mirror: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsFiltersArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs']] = None,
                 request_mirror: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsPatchArgsDict(TypedDict):
        """
        GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersPatchArgsDict']]]]
        """
        Filters defined at this level MUST be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in GRPCRouteRule.)
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsPatchArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersPatchArgs']]]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersPatchArgs']]] filters: Filters defined at this level MUST be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in GRPCRouteRule.)
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param pulumi.Input[int] weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersPatchArgs']]]]:
        """
        Filters defined at this level MUST be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in GRPCRouteRule.)
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersPatchArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GRPCRouteSpecRulesBackendRefsArgsDict(TypedDict):
        """
        GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersArgsDict']]]]
        """
        Filters defined at this level MUST be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in GRPCRouteRule.)
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
elif False:
    GRPCRouteSpecRulesBackendRefsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesBackendRefsArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersArgs']]]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersArgs']]] filters: Filters defined at this level MUST be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in GRPCRouteRule.)
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param pulumi.Input[int] weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersArgs']]]]:
        """
        Filters defined at this level MUST be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in GRPCRouteRule.)
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsFiltersArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersExtensionRefPatchArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    GRPCRouteSpecRulesFiltersExtensionRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersExtensionRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersExtensionRefArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    GRPCRouteSpecRulesFiltersExtensionRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersExtensionRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersPatchArgsDict(TypedDict):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefPatchArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict']]
        request_mirror: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorPatchArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
elif False:
    GRPCRouteSpecRulesFiltersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersPatchArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefPatchArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs']] = None,
                 request_mirror: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefPatchArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefPatchArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestHeaderModifierArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestMirrorPatchArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict']]
elif False:
    GRPCRouteSpecRulesFiltersRequestMirrorPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestMirrorPatchArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersRequestMirrorArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict']]
elif False:
    GRPCRouteSpecRulesFiltersRequestMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersRequestMirrorArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersResponseHeaderModifierArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    GRPCRouteSpecRulesFiltersResponseHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class GRPCRouteSpecRulesFiltersArgsDict(TypedDict):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierArgsDict']]
        request_mirror: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
elif False:
    GRPCRouteSpecRulesFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesFiltersArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs']] = None,
                 request_mirror: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersExtensionRefArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersRequestMirrorArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteSpecRulesMatchesHeadersPatchArgsDict(TypedDict):
        """
        GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
        headers.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the gRPC Header to be matched.

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the value of the header.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of the gRPC Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesMatchesHeadersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesMatchesHeadersPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
        headers.
        :param pulumi.Input[str] name: Name is the name of the gRPC Header to be matched.
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] type: Type specifies how to match against the value of the header.
        :param pulumi.Input[str] value: Value is the value of the gRPC Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the gRPC Header to be matched.

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the value of the header.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of the gRPC Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesMatchesHeadersArgsDict(TypedDict):
        """
        GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
        headers.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the gRPC Header to be matched.

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the value of the header.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of the gRPC Header to be matched.
        """
elif False:
    GRPCRouteSpecRulesMatchesHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesMatchesHeadersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
        headers.
        :param pulumi.Input[str] name: Name is the name of the gRPC Header to be matched.
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] type: Type specifies how to match against the value of the header.
        :param pulumi.Input[str] value: Value is the value of the gRPC Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the gRPC Header to be matched.

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the value of the header.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of the gRPC Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GRPCRouteSpecRulesMatchesMethodPatchArgsDict(TypedDict):
        """
        Method specifies a gRPC request service/method matcher. If this field is
        not specified, all services and methods will match.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Value of the method to match against. If left empty or omitted, will
        match all services.

        At least one of Service and Method MUST be a non-empty string.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Value of the service to match against. If left empty or omitted, will
        match any service.

        At least one of Service and Method MUST be a non-empty string.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the service and/or method.
        Support: Core (Exact with service and method specified)

        Support: Implementation-specific (Exact with method specified but no service specified)

        Support: Implementation-specific (RegularExpression)
        """
elif False:
    GRPCRouteSpecRulesMatchesMethodPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesMatchesMethodPatchArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Method specifies a gRPC request service/method matcher. If this field is
        not specified, all services and methods will match.
        :param pulumi.Input[str] method: Value of the method to match against. If left empty or omitted, will
               match all services.
               
               At least one of Service and Method MUST be a non-empty string.
        :param pulumi.Input[str] service: Value of the service to match against. If left empty or omitted, will
               match any service.
               
               At least one of Service and Method MUST be a non-empty string.
        :param pulumi.Input[str] type: Type specifies how to match against the service and/or method.
               Support: Core (Exact with service and method specified)
               
               Support: Implementation-specific (Exact with method specified but no service specified)
               
               Support: Implementation-specific (RegularExpression)
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the method to match against. If left empty or omitted, will
        match all services.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the service to match against. If left empty or omitted, will
        match any service.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the service and/or method.
        Support: Core (Exact with service and method specified)

        Support: Implementation-specific (Exact with method specified but no service specified)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteSpecRulesMatchesMethodArgsDict(TypedDict):
        """
        Method specifies a gRPC request service/method matcher. If this field is
        not specified, all services and methods will match.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Value of the method to match against. If left empty or omitted, will
        match all services.

        At least one of Service and Method MUST be a non-empty string.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Value of the service to match against. If left empty or omitted, will
        match any service.

        At least one of Service and Method MUST be a non-empty string.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the service and/or method.
        Support: Core (Exact with service and method specified)

        Support: Implementation-specific (Exact with method specified but no service specified)

        Support: Implementation-specific (RegularExpression)
        """
elif False:
    GRPCRouteSpecRulesMatchesMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesMatchesMethodArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Method specifies a gRPC request service/method matcher. If this field is
        not specified, all services and methods will match.
        :param pulumi.Input[str] method: Value of the method to match against. If left empty or omitted, will
               match all services.
               
               At least one of Service and Method MUST be a non-empty string.
        :param pulumi.Input[str] service: Value of the service to match against. If left empty or omitted, will
               match any service.
               
               At least one of Service and Method MUST be a non-empty string.
        :param pulumi.Input[str] type: Type specifies how to match against the service and/or method.
               Support: Core (Exact with service and method specified)
               
               Support: Implementation-specific (Exact with method specified but no service specified)
               
               Support: Implementation-specific (RegularExpression)
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the method to match against. If left empty or omitted, will
        match all services.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the service to match against. If left empty or omitted, will
        match any service.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the service and/or method.
        Support: Core (Exact with service and method specified)

        Support: Implementation-specific (Exact with method specified but no service specified)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteSpecRulesMatchesPatchArgsDict(TypedDict):
        """
        GRPCRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a gRPC request only if its service
        is `foo` AND it contains the `version: v1` header:

        ```
        matches:
          - method:
            type: Exact
            service: "foo"
            headers:
          - name: "version"
            value "v1"

        ```
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersPatchArgsDict']]]]
        """
        Headers specifies gRPC request header matchers. Multiple match values are
        ANDed together, meaning, a request MUST match all the specified headers
        to select the route.
        """
        method: NotRequired[pulumi.Input['GRPCRouteSpecRulesMatchesMethodPatchArgsDict']]
elif False:
    GRPCRouteSpecRulesMatchesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesMatchesPatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersPatchArgs']]]] = None,
                 method: Optional[pulumi.Input['GRPCRouteSpecRulesMatchesMethodPatchArgs']] = None):
        """
        GRPCRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a gRPC request only if its service
        is `foo` AND it contains the `version: v1` header:

        ```
        matches:
          - method:
            type: Exact
            service: "foo"
            headers:
          - name: "version"
            value "v1"

        ```
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersPatchArgs']]] headers: Headers specifies gRPC request header matchers. Multiple match values are
               ANDed together, meaning, a request MUST match all the specified headers
               to select the route.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersPatchArgs']]]]:
        """
        Headers specifies gRPC request header matchers. Multiple match values are
        ANDed together, meaning, a request MUST match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersPatchArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesMatchesMethodPatchArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesMatchesMethodPatchArgs']]):
        pulumi.set(self, "method", value)


if not MYPY:
    class GRPCRouteSpecRulesMatchesArgsDict(TypedDict):
        """
        GRPCRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a gRPC request only if its service
        is `foo` AND it contains the `version: v1` header:

        ```
        matches:
          - method:
            type: Exact
            service: "foo"
            headers:
          - name: "version"
            value "v1"

        ```
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersArgsDict']]]]
        """
        Headers specifies gRPC request header matchers. Multiple match values are
        ANDed together, meaning, a request MUST match all the specified headers
        to select the route.
        """
        method: NotRequired[pulumi.Input['GRPCRouteSpecRulesMatchesMethodArgsDict']]
elif False:
    GRPCRouteSpecRulesMatchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesMatchesArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersArgs']]]] = None,
                 method: Optional[pulumi.Input['GRPCRouteSpecRulesMatchesMethodArgs']] = None):
        """
        GRPCRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a gRPC request only if its service
        is `foo` AND it contains the `version: v1` header:

        ```
        matches:
          - method:
            type: Exact
            service: "foo"
            headers:
          - name: "version"
            value "v1"

        ```
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersArgs']]] headers: Headers specifies gRPC request header matchers. Multiple match values are
               ANDed together, meaning, a request MUST match all the specified headers
               to select the route.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersArgs']]]]:
        """
        Headers specifies gRPC request header matchers. Multiple match values are
        ANDed together, meaning, a request MUST match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesHeadersArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['GRPCRouteSpecRulesMatchesMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['GRPCRouteSpecRulesMatchesMethodArgs']]):
        pulumi.set(self, "method", value)


if not MYPY:
    class GRPCRouteSpecRulesPatchArgsDict(TypedDict):
        """
        GRPCRouteRule defines the semantics for matching a gRPC request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        """
        backend_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsPatchArgsDict']]]]
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive an `UNAVAILABLE` status.

        See the GRPCBackendRef definition for the rules about what makes a single
        GRPCBackendRef invalid.

        When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive an `UNAVAILABLE` status.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
        Implementations may choose how that 50 percent is determined.

        Support: Core for Kubernetes Service

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersPatchArgsDict']]]]
        """
        Filters define the filters that are applied to requests that match
        this rule.

        The effects of ordering of multiple behaviors are currently unspecified.
        This can change in the future based on feedback during the alpha stage.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations that support
          GRPCRoute.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        If an implementation can not support a combination of filters, it must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesPatchArgsDict']]]]
        """
        Matches define conditions used for matching the rule against incoming
        gRPC requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - method:
            service: foo.bar
          headers:
            values:
              version: 2
        - method:
            service: foo.bar.v2
        ```

        For a request to match against this rule, it MUST satisfy
        EITHER of the two conditions:

        - service of foo.bar AND contains the header `version: 2`
        - service of foo.bar.v2

        See the documentation for GRPCRouteMatch on how to specify multiple
        match conditions to be ANDed together.

        If no matches are specified, the implementation MUST match every gRPC request.

        Proxy or Load Balancer routing configuration generated from GRPCRoutes
        MUST prioritize rules based on the following criteria, continuing on
        ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
        Precedence MUST be given to the rule with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.
        * Characters in a matching service.
        * Characters in a matching method.
        * Header matches.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within the Route that has been given precedence,
        matching precedence MUST be granted to the first matching rule meeting
        the above criteria.
        """
elif False:
    GRPCRouteSpecRulesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesPatchArgs:
    def __init__(__self__, *,
                 backend_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsPatchArgs']]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersPatchArgs']]]] = None,
                 matches: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesPatchArgs']]]] = None):
        """
        GRPCRouteRule defines the semantics for matching a gRPC request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsPatchArgs']]] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive an `UNAVAILABLE` status.
               
               See the GRPCBackendRef definition for the rules about what makes a single
               GRPCBackendRef invalid.
               
               When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive an `UNAVAILABLE` status.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
               Implementations may choose how that 50 percent is determined.
               
               Support: Core for Kubernetes Service
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersPatchArgs']]] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               The effects of ordering of multiple behaviors are currently unspecified.
               This can change in the future based on feedback during the alpha stage.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations that support
                 GRPCRoute.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               If an implementation can not support a combination of filters, it must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesPatchArgs']]] matches: Matches define conditions used for matching the rule against incoming
               gRPC requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - method:
                   service: foo.bar
                 headers:
                   values:
                     version: 2
               - method:
                   service: foo.bar.v2
               ```
               
               For a request to match against this rule, it MUST satisfy
               EITHER of the two conditions:
               
               - service of foo.bar AND contains the header `version: 2`
               - service of foo.bar.v2
               
               See the documentation for GRPCRouteMatch on how to specify multiple
               match conditions to be ANDed together.
               
               If no matches are specified, the implementation MUST match every gRPC request.
               
               Proxy or Load Balancer routing configuration generated from GRPCRoutes
               MUST prioritize rules based on the following criteria, continuing on
               ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
               Precedence MUST be given to the rule with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               * Characters in a matching service.
               * Characters in a matching method.
               * Header matches.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within the Route that has been given precedence,
               matching precedence MUST be granted to the first matching rule meeting
               the above criteria.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsPatchArgs']]]]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive an `UNAVAILABLE` status.

        See the GRPCBackendRef definition for the rules about what makes a single
        GRPCBackendRef invalid.

        When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive an `UNAVAILABLE` status.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
        Implementations may choose how that 50 percent is determined.

        Support: Core for Kubernetes Service

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @backend_refs.setter
    def backend_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsPatchArgs']]]]):
        pulumi.set(self, "backend_refs", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersPatchArgs']]]]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        The effects of ordering of multiple behaviors are currently unspecified.
        This can change in the future based on feedback during the alpha stage.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations that support
          GRPCRoute.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        If an implementation can not support a combination of filters, it must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersPatchArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesPatchArgs']]]]:
        """
        Matches define conditions used for matching the rule against incoming
        gRPC requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - method:
            service: foo.bar
          headers:
            values:
              version: 2
        - method:
            service: foo.bar.v2
        ```

        For a request to match against this rule, it MUST satisfy
        EITHER of the two conditions:

        - service of foo.bar AND contains the header `version: 2`
        - service of foo.bar.v2

        See the documentation for GRPCRouteMatch on how to specify multiple
        match conditions to be ANDed together.

        If no matches are specified, the implementation MUST match every gRPC request.

        Proxy or Load Balancer routing configuration generated from GRPCRoutes
        MUST prioritize rules based on the following criteria, continuing on
        ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
        Precedence MUST be given to the rule with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.
        * Characters in a matching service.
        * Characters in a matching method.
        * Header matches.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within the Route that has been given precedence,
        matching precedence MUST be granted to the first matching rule meeting
        the above criteria.
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesPatchArgs']]]]):
        pulumi.set(self, "matches", value)


if not MYPY:
    class GRPCRouteSpecRulesArgsDict(TypedDict):
        """
        GRPCRouteRule defines the semantics for matching a gRPC request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        """
        backend_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsArgsDict']]]]
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive an `UNAVAILABLE` status.

        See the GRPCBackendRef definition for the rules about what makes a single
        GRPCBackendRef invalid.

        When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive an `UNAVAILABLE` status.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
        Implementations may choose how that 50 percent is determined.

        Support: Core for Kubernetes Service

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersArgsDict']]]]
        """
        Filters define the filters that are applied to requests that match
        this rule.

        The effects of ordering of multiple behaviors are currently unspecified.
        This can change in the future based on feedback during the alpha stage.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations that support
          GRPCRoute.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        If an implementation can not support a combination of filters, it must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesArgsDict']]]]
        """
        Matches define conditions used for matching the rule against incoming
        gRPC requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - method:
            service: foo.bar
          headers:
            values:
              version: 2
        - method:
            service: foo.bar.v2
        ```

        For a request to match against this rule, it MUST satisfy
        EITHER of the two conditions:

        - service of foo.bar AND contains the header `version: 2`
        - service of foo.bar.v2

        See the documentation for GRPCRouteMatch on how to specify multiple
        match conditions to be ANDed together.

        If no matches are specified, the implementation MUST match every gRPC request.

        Proxy or Load Balancer routing configuration generated from GRPCRoutes
        MUST prioritize rules based on the following criteria, continuing on
        ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
        Precedence MUST be given to the rule with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.
        * Characters in a matching service.
        * Characters in a matching method.
        * Header matches.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within the Route that has been given precedence,
        matching precedence MUST be granted to the first matching rule meeting
        the above criteria.
        """
elif False:
    GRPCRouteSpecRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecRulesArgs:
    def __init__(__self__, *,
                 backend_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsArgs']]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersArgs']]]] = None,
                 matches: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesArgs']]]] = None):
        """
        GRPCRouteRule defines the semantics for matching a gRPC request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsArgs']]] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive an `UNAVAILABLE` status.
               
               See the GRPCBackendRef definition for the rules about what makes a single
               GRPCBackendRef invalid.
               
               When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive an `UNAVAILABLE` status.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
               Implementations may choose how that 50 percent is determined.
               
               Support: Core for Kubernetes Service
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersArgs']]] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               The effects of ordering of multiple behaviors are currently unspecified.
               This can change in the future based on feedback during the alpha stage.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations that support
                 GRPCRoute.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               If an implementation can not support a combination of filters, it must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesArgs']]] matches: Matches define conditions used for matching the rule against incoming
               gRPC requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - method:
                   service: foo.bar
                 headers:
                   values:
                     version: 2
               - method:
                   service: foo.bar.v2
               ```
               
               For a request to match against this rule, it MUST satisfy
               EITHER of the two conditions:
               
               - service of foo.bar AND contains the header `version: 2`
               - service of foo.bar.v2
               
               See the documentation for GRPCRouteMatch on how to specify multiple
               match conditions to be ANDed together.
               
               If no matches are specified, the implementation MUST match every gRPC request.
               
               Proxy or Load Balancer routing configuration generated from GRPCRoutes
               MUST prioritize rules based on the following criteria, continuing on
               ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
               Precedence MUST be given to the rule with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               * Characters in a matching service.
               * Characters in a matching method.
               * Header matches.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within the Route that has been given precedence,
               matching precedence MUST be granted to the first matching rule meeting
               the above criteria.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsArgs']]]]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive an `UNAVAILABLE` status.

        See the GRPCBackendRef definition for the rules about what makes a single
        GRPCBackendRef invalid.

        When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive an `UNAVAILABLE` status.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
        Implementations may choose how that 50 percent is determined.

        Support: Core for Kubernetes Service

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @backend_refs.setter
    def backend_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesBackendRefsArgs']]]]):
        pulumi.set(self, "backend_refs", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersArgs']]]]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        The effects of ordering of multiple behaviors are currently unspecified.
        This can change in the future based on feedback during the alpha stage.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations that support
          GRPCRoute.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        If an implementation can not support a combination of filters, it must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesFiltersArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesArgs']]]]:
        """
        Matches define conditions used for matching the rule against incoming
        gRPC requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - method:
            service: foo.bar
          headers:
            values:
              version: 2
        - method:
            service: foo.bar.v2
        ```

        For a request to match against this rule, it MUST satisfy
        EITHER of the two conditions:

        - service of foo.bar AND contains the header `version: 2`
        - service of foo.bar.v2

        See the documentation for GRPCRouteMatch on how to specify multiple
        match conditions to be ANDed together.

        If no matches are specified, the implementation MUST match every gRPC request.

        Proxy or Load Balancer routing configuration generated from GRPCRoutes
        MUST prioritize rules based on the following criteria, continuing on
        ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
        Precedence MUST be given to the rule with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.
        * Characters in a matching service.
        * Characters in a matching method.
        * Header matches.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within the Route that has been given precedence,
        matching precedence MUST be granted to the first matching rule meeting
        the above criteria.
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesMatchesArgs']]]]):
        pulumi.set(self, "matches", value)


if not MYPY:
    class GRPCRouteSpecArgsDict(TypedDict):
        """
        Spec defines the desired state of GRPCRoute.
        """
        hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Hostnames defines a set of hostnames to match against the GRPC
        Host header to select a GRPCRoute to process the request. This matches
        the RFC 1123 definition of a hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label MUST appear by itself as the first label.

        If a hostname is specified by both the Listener and GRPCRoute, there
        MUST be at least one intersecting hostname for the GRPCRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `test.example.com` and `*.example.com` would both match. On the other
          hand, `example.com` and `test.example.net` would not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and GRPCRoute have specified hostnames, any
        GRPCRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        GRPCRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` MUST NOT be considered for a match.

        If both the Listener and GRPCRoute have specified hostnames, and none
        match with the criteria above, then the GRPCRoute MUST NOT be accepted by
        the implementation. The implementation MUST raise an 'Accepted' Condition
        with a status of `False` in the corresponding RouteParentStatus.

        If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
        Listener and that listener already has another Route (B) of the other
        type attached and the intersection of the hostnames of A and B is
        non-empty, then the implementation MUST accept exactly one of these two
        routes, determined by the following criteria, in order:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        The rejected Route MUST raise an 'Accepted' condition with a status of
        'False' in the corresponding RouteParentStatus.

        Support: Core
        """
        parent_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsArgsDict']]]]
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesArgsDict']]]]
        """
        Rules are a list of GRPC matchers, filters and actions.
        """
elif False:
    GRPCRouteSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteSpecArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parent_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesArgs']]]] = None):
        """
        Spec defines the desired state of GRPCRoute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: Hostnames defines a set of hostnames to match against the GRPC
               Host header to select a GRPCRoute to process the request. This matches
               the RFC 1123 definition of a hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label MUST appear by itself as the first label.
               
               If a hostname is specified by both the Listener and GRPCRoute, there
               MUST be at least one intersecting hostname for the GRPCRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `test.example.com` and `*.example.com` would both match. On the other
                 hand, `example.com` and `test.example.net` would not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and GRPCRoute have specified hostnames, any
               GRPCRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               GRPCRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` MUST NOT be considered for a match.
               
               If both the Listener and GRPCRoute have specified hostnames, and none
               match with the criteria above, then the GRPCRoute MUST NOT be accepted by
               the implementation. The implementation MUST raise an 'Accepted' Condition
               with a status of `False` in the corresponding RouteParentStatus.
               
               If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
               Listener and that listener already has another Route (B) of the other
               type attached and the intersection of the hostnames of A and B is
               non-empty, then the implementation MUST accept exactly one of these two
               routes, determined by the following criteria, in order:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               The rejected Route MUST raise an 'Accepted' condition with a status of
               'False' in the corresponding RouteParentStatus.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsArgs']]] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesArgs']]] rules: Rules are a list of GRPC matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Hostnames defines a set of hostnames to match against the GRPC
        Host header to select a GRPCRoute to process the request. This matches
        the RFC 1123 definition of a hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label MUST appear by itself as the first label.

        If a hostname is specified by both the Listener and GRPCRoute, there
        MUST be at least one intersecting hostname for the GRPCRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `test.example.com` and `*.example.com` would both match. On the other
          hand, `example.com` and `test.example.net` would not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and GRPCRoute have specified hostnames, any
        GRPCRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        GRPCRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` MUST NOT be considered for a match.

        If both the Listener and GRPCRoute have specified hostnames, and none
        match with the criteria above, then the GRPCRoute MUST NOT be accepted by
        the implementation. The implementation MUST raise an 'Accepted' Condition
        with a status of `False` in the corresponding RouteParentStatus.

        If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
        Listener and that listener already has another Route (B) of the other
        type attached and the intersection of the hostnames of A and B is
        non-empty, then the implementation MUST accept exactly one of these two
        routes, determined by the following criteria, in order:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        The rejected Route MUST raise an 'Accepted' condition with a status of
        'False' in the corresponding RouteParentStatus.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsArgs']]]]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @parent_refs.setter
    def parent_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecParentRefsArgs']]]]):
        pulumi.set(self, "parent_refs", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesArgs']]]]:
        """
        Rules are a list of GRPC matchers, filters and actions.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteSpecRulesArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GRPCRouteStatusParentsConditionsArgsDict(TypedDict):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        """
        last_transition_time: NotRequired[pulumi.Input[str]]
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        observed_generation: NotRequired[pulumi.Input[int]]
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of the condition, one of True, False, Unknown.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
elif False:
    GRPCRouteStatusParentsConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteStatusParentsConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param pulumi.Input[str] last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param pulumi.Input[int] observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param pulumi.Input[str] reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param pulumi.Input[str] status: status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GRPCRouteStatusParentsParentRefArgsDict(TypedDict):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.

        Support: Core
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        section_name: NotRequired[pulumi.Input[str]]
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
elif False:
    GRPCRouteStatusParentsParentRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteStatusParentsParentRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 section_name: Optional[pulumi.Input[str]] = None):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        :param pulumi.Input[str] group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param pulumi.Input[str] kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param pulumi.Input[str] name: Name is the name of the referent.
               
               Support: Core
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param pulumi.Input[str] section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[pulumi.Input[str]]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")

    @section_name.setter
    def section_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_name", value)


if not MYPY:
    class GRPCRouteStatusParentsArgsDict(TypedDict):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsConditionsArgsDict']]]]
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        controller_name: NotRequired[pulumi.Input[str]]
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        parent_ref: NotRequired[pulumi.Input['GRPCRouteStatusParentsParentRefArgsDict']]
elif False:
    GRPCRouteStatusParentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteStatusParentsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsConditionsArgs']]]] = None,
                 controller_name: Optional[pulumi.Input[str]] = None,
                 parent_ref: Optional[pulumi.Input['GRPCRouteStatusParentsParentRefArgs']] = None):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsConditionsArgs']]] conditions: Conditions describes the status of the route with respect to the Gateway.
               Note that the route's availability is also subject to the Gateway's own
               status conditions and listener status.
               
               If the Route's ParentRef specifies an existing Gateway that supports
               Routes of this kind AND that Gateway's controller has sufficient access,
               then that Gateway's controller MUST set the "Accepted" condition on the
               Route, to indicate whether the route has been accepted or rejected by the
               Gateway, and why.
               
               A Route MUST be considered "Accepted" if at least one of the Route's
               rules is implemented by the Gateway.
               
               There are a number of cases where the "Accepted" condition may not be set
               due to lack of controller visibility, that includes when:
               
               * The Route refers to a non-existent parent.
               * The Route is of a type that the controller does not support.
               * The Route is in a namespace the controller does not have access to.
        :param pulumi.Input[str] controller_name: ControllerName is a domain/path string that indicates the name of the
               controller that wrote this status. This corresponds with the
               controllerName field on GatewayClass.
               
               Example: "example.net/gateway-controller".
               
               The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
               valid Kubernetes names
               (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
               
               Controllers MUST populate this field when writing status. Controllers should ensure that
               entries to status populated with their ControllerName are cleaned up when they are no
               longer necessary.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if parent_ref is not None:
            pulumi.set(__self__, "parent_ref", parent_ref)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsConditionsArgs']]]]:
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[pulumi.Input[str]]:
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        return pulumi.get(self, "controller_name")

    @controller_name.setter
    def controller_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_name", value)

    @property
    @pulumi.getter(name="parentRef")
    def parent_ref(self) -> Optional[pulumi.Input['GRPCRouteStatusParentsParentRefArgs']]:
        return pulumi.get(self, "parent_ref")

    @parent_ref.setter
    def parent_ref(self, value: Optional[pulumi.Input['GRPCRouteStatusParentsParentRefArgs']]):
        pulumi.set(self, "parent_ref", value)


if not MYPY:
    class GRPCRouteStatusArgsDict(TypedDict):
        """
        Status defines the current state of GRPCRoute.
        """
        parents: NotRequired[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsArgsDict']]]]
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
elif False:
    GRPCRouteStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteStatusArgs:
    def __init__(__self__, *,
                 parents: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsArgs']]]] = None):
        """
        Status defines the current state of GRPCRoute.
        :param pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsArgs']]] parents: Parents is a list of parent resources (usually Gateways) that are
               associated with the route, and the status of the route with respect to
               each parent. When this route attaches to a parent, the controller that
               manages the parent must add an entry to this list when the controller
               first sees the route and should update the entry as appropriate when the
               route or gateway is modified.
               
               Note that parent references that cannot be resolved by an implementation
               of this API will not be added to this list. Implementations of this API
               can only populate Route status for the Gateways/parent resources they are
               responsible for.
               
               A maximum of 32 Gateways will be represented in this list. An empty list
               means the route has not been attached to any Gateway.
        """
        if parents is not None:
            pulumi.set(__self__, "parents", parents)

    @property
    @pulumi.getter
    def parents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsArgs']]]]:
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
        return pulumi.get(self, "parents")

    @parents.setter
    def parents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GRPCRouteStatusParentsArgs']]]]):
        pulumi.set(self, "parents", value)


if not MYPY:
    class GRPCRouteArgsDict(TypedDict):
        """
        GRPCRoute provides a way to route gRPC requests. This includes the capability
        to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
        Filters can be used to specify additional processing steps. Backends specify
        where matching requests will be routed.

        GRPCRoute falls under extended support within the Gateway API. Within the
        following specification, the word "MUST" indicates that an implementation
        supporting GRPCRoute must conform to the indicated requirement, but an
        implementation not supporting this route type need not follow the requirement
        unless explicitly indicated.

        Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
        accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
        ALPN. If the implementation does not support this, then it MUST set the
        "Accepted" condition to "False" for the affected listener with a reason of
        "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
        with an upgrade from HTTP/1.

        Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
        support HTTP/2 over cleartext TCP (h2c,
        https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
        upgrade from HTTP/1.1, i.e. with prior knowledge
        (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
        does not support this, then it MUST set the "Accepted" condition to "False"
        for the affected listener with a reason of "UnsupportedProtocol".
        Implementations MAY also accept HTTP/2 connections with an upgrade from
        HTTP/1, i.e. without prior knowledge.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['GRPCRouteSpecArgsDict']]
        status: NotRequired[pulumi.Input['GRPCRouteStatusArgsDict']]
elif False:
    GRPCRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GRPCRouteArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['GRPCRouteSpecArgs']] = None,
                 status: Optional[pulumi.Input['GRPCRouteStatusArgs']] = None):
        """
        GRPCRoute provides a way to route gRPC requests. This includes the capability
        to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
        Filters can be used to specify additional processing steps. Backends specify
        where matching requests will be routed.

        GRPCRoute falls under extended support within the Gateway API. Within the
        following specification, the word "MUST" indicates that an implementation
        supporting GRPCRoute must conform to the indicated requirement, but an
        implementation not supporting this route type need not follow the requirement
        unless explicitly indicated.

        Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
        accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
        ALPN. If the implementation does not support this, then it MUST set the
        "Accepted" condition to "False" for the affected listener with a reason of
        "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
        with an upgrade from HTTP/1.

        Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
        support HTTP/2 over cleartext TCP (h2c,
        https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
        upgrade from HTTP/1.1, i.e. with prior knowledge
        (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
        does not support this, then it MUST set the "Accepted" condition to "False"
        for the affected listener with a reason of "UnsupportedProtocol".
        Implementations MAY also accept HTTP/2 connections with an upgrade from
        HTTP/1, i.e. without prior knowledge.
        :param pulumi.Input[str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'GRPCRoute')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['GRPCRouteSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['GRPCRouteSpecArgs']]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['GRPCRouteStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['GRPCRouteStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GatewayClassSpecParametersRefPatchArgsDict(TypedDict):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the GatewayClass. This is optional if the
        controller does not require any additional configuration.

        ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
        or an implementation-specific custom resource. The resource can be
        cluster-scoped or namespace-scoped.

        If the referent cannot be found, refers to an unsupported kind, or when
        the data within that resource is malformed, the GatewayClass SHOULD be
        rejected with the "Accepted" status condition set to "False" and an
        "InvalidParameters" reason.

        A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent.
        This field is required when referring to a Namespace-scoped resource and
        MUST be unset when referring to a Cluster-scoped resource.
        """
elif False:
    GatewayClassSpecParametersRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassSpecParametersRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the GatewayClass. This is optional if the
        controller does not require any additional configuration.

        ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
        or an implementation-specific custom resource. The resource can be
        cluster-scoped or namespace-scoped.

        If the referent cannot be found, refers to an unsupported kind, or when
        the data within that resource is malformed, the GatewayClass SHOULD be
        rejected with the "Accepted" status condition set to "False" and an
        "InvalidParameters" reason.

        A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent.
        :param pulumi.Input[str] kind: Kind is kind of the referent.
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent.
               This field is required when referring to a Namespace-scoped resource and
               MUST be unset when referring to a Cluster-scoped resource.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent.
        This field is required when referring to a Namespace-scoped resource and
        MUST be unset when referring to a Cluster-scoped resource.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GatewayClassSpecParametersRefArgsDict(TypedDict):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the GatewayClass. This is optional if the
        controller does not require any additional configuration.

        ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
        or an implementation-specific custom resource. The resource can be
        cluster-scoped or namespace-scoped.

        If the referent cannot be found, refers to an unsupported kind, or when
        the data within that resource is malformed, the GatewayClass SHOULD be
        rejected with the "Accepted" status condition set to "False" and an
        "InvalidParameters" reason.

        A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent.
        This field is required when referring to a Namespace-scoped resource and
        MUST be unset when referring to a Cluster-scoped resource.
        """
elif False:
    GatewayClassSpecParametersRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassSpecParametersRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the GatewayClass. This is optional if the
        controller does not require any additional configuration.

        ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
        or an implementation-specific custom resource. The resource can be
        cluster-scoped or namespace-scoped.

        If the referent cannot be found, refers to an unsupported kind, or when
        the data within that resource is malformed, the GatewayClass SHOULD be
        rejected with the "Accepted" status condition set to "False" and an
        "InvalidParameters" reason.

        A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent.
        :param pulumi.Input[str] kind: Kind is kind of the referent.
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent.
               This field is required when referring to a Namespace-scoped resource and
               MUST be unset when referring to a Cluster-scoped resource.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent.
        This field is required when referring to a Namespace-scoped resource and
        MUST be unset when referring to a Cluster-scoped resource.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GatewayClassSpecPatchArgsDict(TypedDict):
        """
        Spec defines the desired state of GatewayClass.
        """
        controller_name: NotRequired[pulumi.Input[str]]
        """
        ControllerName is the name of the controller that is managing Gateways of
        this class. The value of this field MUST be a domain prefixed path.

        Example: "example.net/gateway-controller".

        This field is not mutable and cannot be empty.

        Support: Core
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description helps describe a GatewayClass with more details.
        """
        parameters_ref: NotRequired[pulumi.Input['GatewayClassSpecParametersRefPatchArgsDict']]
elif False:
    GatewayClassSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassSpecPatchArgs:
    def __init__(__self__, *,
                 controller_name: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters_ref: Optional[pulumi.Input['GatewayClassSpecParametersRefPatchArgs']] = None):
        """
        Spec defines the desired state of GatewayClass.
        :param pulumi.Input[str] controller_name: ControllerName is the name of the controller that is managing Gateways of
               this class. The value of this field MUST be a domain prefixed path.
               
               Example: "example.net/gateway-controller".
               
               This field is not mutable and cannot be empty.
               
               Support: Core
        :param pulumi.Input[str] description: Description helps describe a GatewayClass with more details.
        """
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[pulumi.Input[str]]:
        """
        ControllerName is the name of the controller that is managing Gateways of
        this class. The value of this field MUST be a domain prefixed path.

        Example: "example.net/gateway-controller".

        This field is not mutable and cannot be empty.

        Support: Core
        """
        return pulumi.get(self, "controller_name")

    @controller_name.setter
    def controller_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description helps describe a GatewayClass with more details.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional[pulumi.Input['GatewayClassSpecParametersRefPatchArgs']]:
        return pulumi.get(self, "parameters_ref")

    @parameters_ref.setter
    def parameters_ref(self, value: Optional[pulumi.Input['GatewayClassSpecParametersRefPatchArgs']]):
        pulumi.set(self, "parameters_ref", value)


if not MYPY:
    class GatewayClassSpecArgsDict(TypedDict):
        """
        Spec defines the desired state of GatewayClass.
        """
        controller_name: NotRequired[pulumi.Input[str]]
        """
        ControllerName is the name of the controller that is managing Gateways of
        this class. The value of this field MUST be a domain prefixed path.

        Example: "example.net/gateway-controller".

        This field is not mutable and cannot be empty.

        Support: Core
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description helps describe a GatewayClass with more details.
        """
        parameters_ref: NotRequired[pulumi.Input['GatewayClassSpecParametersRefArgsDict']]
elif False:
    GatewayClassSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassSpecArgs:
    def __init__(__self__, *,
                 controller_name: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 parameters_ref: Optional[pulumi.Input['GatewayClassSpecParametersRefArgs']] = None):
        """
        Spec defines the desired state of GatewayClass.
        :param pulumi.Input[str] controller_name: ControllerName is the name of the controller that is managing Gateways of
               this class. The value of this field MUST be a domain prefixed path.
               
               Example: "example.net/gateway-controller".
               
               This field is not mutable and cannot be empty.
               
               Support: Core
        :param pulumi.Input[str] description: Description helps describe a GatewayClass with more details.
        """
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[pulumi.Input[str]]:
        """
        ControllerName is the name of the controller that is managing Gateways of
        this class. The value of this field MUST be a domain prefixed path.

        Example: "example.net/gateway-controller".

        This field is not mutable and cannot be empty.

        Support: Core
        """
        return pulumi.get(self, "controller_name")

    @controller_name.setter
    def controller_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description helps describe a GatewayClass with more details.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional[pulumi.Input['GatewayClassSpecParametersRefArgs']]:
        return pulumi.get(self, "parameters_ref")

    @parameters_ref.setter
    def parameters_ref(self, value: Optional[pulumi.Input['GatewayClassSpecParametersRefArgs']]):
        pulumi.set(self, "parameters_ref", value)


if not MYPY:
    class GatewayClassStatusConditionsArgsDict(TypedDict):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        """
        last_transition_time: NotRequired[pulumi.Input[str]]
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        observed_generation: NotRequired[pulumi.Input[int]]
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of the condition, one of True, False, Unknown.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
elif False:
    GatewayClassStatusConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param pulumi.Input[str] last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param pulumi.Input[int] observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param pulumi.Input[str] reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param pulumi.Input[str] status: status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayClassStatusArgsDict(TypedDict):
        """
        Status defines the current state of GatewayClass.

        Implementations MUST populate status on all GatewayClass resources which
        specify their controller name.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayClassStatusConditionsArgsDict']]]]
        """
        Conditions is the current status from the controller for
        this GatewayClass.

        Controllers should prefer to publish conditions using values
        of GatewayClassConditionType for the type of each Condition.
        """
elif False:
    GatewayClassStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayClassStatusConditionsArgs']]]] = None):
        """
        Status defines the current state of GatewayClass.

        Implementations MUST populate status on all GatewayClass resources which
        specify their controller name.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayClassStatusConditionsArgs']]] conditions: Conditions is the current status from the controller for
               this GatewayClass.
               
               Controllers should prefer to publish conditions using values
               of GatewayClassConditionType for the type of each Condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayClassStatusConditionsArgs']]]]:
        """
        Conditions is the current status from the controller for
        this GatewayClass.

        Controllers should prefer to publish conditions using values
        of GatewayClassConditionType for the type of each Condition.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayClassStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class GatewayClassArgsDict(TypedDict):
        """
        GatewayClass describes a class of Gateways available to the user for creating
        Gateway resources.

        It is recommended that this resource be used as a template for Gateways. This
        means that a Gateway is based on the state of the GatewayClass at the time it
        was created and changes to the GatewayClass or associated parameters are not
        propagated down to existing Gateways. This recommendation is intended to
        limit the blast radius of changes to GatewayClass or associated parameters.
        If implementations choose to propagate GatewayClass changes to existing
        Gateways, that MUST be clearly documented by the implementation.

        Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
        add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
        associated GatewayClass. This ensures that a GatewayClass associated with a
        Gateway is not deleted while in use.

        GatewayClass is a Cluster level resource.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['GatewayClassSpecArgsDict']]
        status: NotRequired[pulumi.Input['GatewayClassStatusArgsDict']]
elif False:
    GatewayClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClassArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['GatewayClassSpecArgs']] = None,
                 status: Optional[pulumi.Input['GatewayClassStatusArgs']] = None):
        """
        GatewayClass describes a class of Gateways available to the user for creating
        Gateway resources.

        It is recommended that this resource be used as a template for Gateways. This
        means that a Gateway is based on the state of the GatewayClass at the time it
        was created and changes to the GatewayClass or associated parameters are not
        propagated down to existing Gateways. This recommendation is intended to
        limit the blast radius of changes to GatewayClass or associated parameters.
        If implementations choose to propagate GatewayClass changes to existing
        Gateways, that MUST be clearly documented by the implementation.

        Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
        add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
        associated GatewayClass. This ensures that a GatewayClass associated with a
        Gateway is not deleted while in use.

        GatewayClass is a Cluster level resource.
        :param pulumi.Input[str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'GatewayClass')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['GatewayClassSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['GatewayClassSpecArgs']]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['GatewayClassStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['GatewayClassStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GatewaySpecAddressesPatchArgsDict(TypedDict):
        """
        GatewayAddress describes an address that can be bound to a Gateway.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the address.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
elif False:
    GatewaySpecAddressesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecAddressesPatchArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        GatewayAddress describes an address that can be bound to a Gateway.
        :param pulumi.Input[str] type: Type of the address.
        :param pulumi.Input[str] value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewaySpecAddressesArgsDict(TypedDict):
        """
        GatewayAddress describes an address that can be bound to a Gateway.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the address.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
elif False:
    GatewaySpecAddressesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecAddressesArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        GatewayAddress describes an address that can be bound to a Gateway.
        :param pulumi.Input[str] type: Type of the address.
        :param pulumi.Input[str] value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewaySpecInfrastructureParametersRefPatchArgsDict(TypedDict):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the Gateway. This is optional if the
        controller does not require any additional configuration.

        This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

        The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    GatewaySpecInfrastructureParametersRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecInfrastructureParametersRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the Gateway. This is optional if the
        controller does not require any additional configuration.

        This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

        The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent.
        :param pulumi.Input[str] kind: Kind is kind of the referent.
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewaySpecInfrastructureParametersRefArgsDict(TypedDict):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the Gateway. This is optional if the
        controller does not require any additional configuration.

        This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

        The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    GatewaySpecInfrastructureParametersRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecInfrastructureParametersRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the Gateway. This is optional if the
        controller does not require any additional configuration.

        This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

        The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent.
        :param pulumi.Input[str] kind: Kind is kind of the referent.
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewaySpecInfrastructurePatchArgsDict(TypedDict):
        """
        Infrastructure defines infrastructure level attributes about this Gateway instance.

        Support: Extended
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.

        An implementation may chose to add additional implementation-specific annotations as they see fit.

        Support: Extended
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "labels" concepts.

        An implementation may chose to add additional implementation-specific labels as they see fit.

        If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
        change, it SHOULD clearly warn about this behavior in documentation.

        Support: Extended
        """
        parameters_ref: NotRequired[pulumi.Input['GatewaySpecInfrastructureParametersRefPatchArgsDict']]
elif False:
    GatewaySpecInfrastructurePatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecInfrastructurePatchArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 parameters_ref: Optional[pulumi.Input['GatewaySpecInfrastructureParametersRefPatchArgs']] = None):
        """
        Infrastructure defines infrastructure level attributes about this Gateway instance.

        Support: Extended
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
               
               An implementation may chose to add additional implementation-specific annotations as they see fit.
               
               Support: Extended
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
               
               An implementation may chose to add additional implementation-specific labels as they see fit.
               
               If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
               change, it SHOULD clearly warn about this behavior in documentation.
               
               Support: Extended
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.

        An implementation may chose to add additional implementation-specific annotations as they see fit.

        Support: Extended
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "labels" concepts.

        An implementation may chose to add additional implementation-specific labels as they see fit.

        If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
        change, it SHOULD clearly warn about this behavior in documentation.

        Support: Extended
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional[pulumi.Input['GatewaySpecInfrastructureParametersRefPatchArgs']]:
        return pulumi.get(self, "parameters_ref")

    @parameters_ref.setter
    def parameters_ref(self, value: Optional[pulumi.Input['GatewaySpecInfrastructureParametersRefPatchArgs']]):
        pulumi.set(self, "parameters_ref", value)


if not MYPY:
    class GatewaySpecInfrastructureArgsDict(TypedDict):
        """
        Infrastructure defines infrastructure level attributes about this Gateway instance.

        Support: Extended
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.

        An implementation may chose to add additional implementation-specific annotations as they see fit.

        Support: Extended
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "labels" concepts.

        An implementation may chose to add additional implementation-specific labels as they see fit.

        If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
        change, it SHOULD clearly warn about this behavior in documentation.

        Support: Extended
        """
        parameters_ref: NotRequired[pulumi.Input['GatewaySpecInfrastructureParametersRefArgsDict']]
elif False:
    GatewaySpecInfrastructureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecInfrastructureArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 parameters_ref: Optional[pulumi.Input['GatewaySpecInfrastructureParametersRefArgs']] = None):
        """
        Infrastructure defines infrastructure level attributes about this Gateway instance.

        Support: Extended
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
               
               An implementation may chose to add additional implementation-specific annotations as they see fit.
               
               Support: Extended
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
               
               An implementation may chose to add additional implementation-specific labels as they see fit.
               
               If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
               change, it SHOULD clearly warn about this behavior in documentation.
               
               Support: Extended
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.

        An implementation may chose to add additional implementation-specific annotations as they see fit.

        Support: Extended
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "labels" concepts.

        An implementation may chose to add additional implementation-specific labels as they see fit.

        If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
        change, it SHOULD clearly warn about this behavior in documentation.

        Support: Extended
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional[pulumi.Input['GatewaySpecInfrastructureParametersRefArgs']]:
        return pulumi.get(self, "parameters_ref")

    @parameters_ref.setter
    def parameters_ref(self, value: Optional[pulumi.Input['GatewaySpecInfrastructureParametersRefArgs']]):
        pulumi.set(self, "parameters_ref", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesKindsPatchArgsDict(TypedDict):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the Route.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the kind of the Route.
        """
elif False:
    GatewaySpecListenersAllowedRoutesKindsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesKindsPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param pulumi.Input[str] group: Group is the group of the Route.
        :param pulumi.Input[str] kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesKindsArgsDict(TypedDict):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the Route.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the kind of the Route.
        """
elif False:
    GatewaySpecListenersAllowedRoutesKindsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesKindsArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param pulumi.Input[str] group: Group is the group of the Route.
        :param pulumi.Input[str] kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesNamespacesPatchArgsDict(TypedDict):
        """
        Namespaces indicates namespaces from which Routes may be attached to this
        Listener. This is restricted to the namespace of this Gateway by default.

        Support: Core
        """
        from_: NotRequired[pulumi.Input[str]]
        """
        From indicates where Routes will be selected for this Gateway. Possible
        values are:

        * All: Routes in all namespaces may be used by this Gateway.
        * Selector: Routes in namespaces selected by the selector may be used by
          this Gateway.
        * Same: Only Routes in the same namespace may be used by this Gateway.

        Support: Core
        """
        selector: NotRequired[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgsDict']]
elif False:
    GatewaySpecListenersAllowedRoutesNamespacesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesNamespacesPatchArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 selector: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs']] = None):
        """
        Namespaces indicates namespaces from which Routes may be attached to this
        Listener. This is restricted to the namespace of this Gateway by default.

        Support: Core
        :param pulumi.Input[str] from_: From indicates where Routes will be selected for this Gateway. Possible
               values are:
               
               * All: Routes in all namespaces may be used by this Gateway.
               * Selector: Routes in namespaces selected by the selector may be used by
                 this Gateway.
               * Same: Only Routes in the same namespace may be used by this Gateway.
               
               Support: Core
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        From indicates where Routes will be selected for this Gateway. Possible
        values are:

        * All: Routes in all namespaces may be used by this Gateway.
        * Selector: Routes in namespaces selected by the selector may be used by
          this Gateway.
        * Same: Only Routes in the same namespace may be used by this Gateway.

        Support: Core
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgsDict(TypedDict):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that
        relates the key and values.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        key is the label key that the selector applies to.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        operator represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        values is an array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.
        """
elif False:
    GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that
        relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values.
               Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn,
               the values array must be non-empty. If the operator is Exists or DoesNotExist,
               the values array must be empty. This array is replaced during a strategic
               merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        operator represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgsDict(TypedDict):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that
        relates the key and values.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        key is the label key that the selector applies to.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        operator represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        values is an array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.
        """
elif False:
    GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that
        relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values.
               Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn,
               the values array must be non-empty. If the operator is Exists or DoesNotExist,
               the values array must be empty. This array is replaced during a strategic
               merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        operator represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgsDict(TypedDict):
        """
        Selector must be specified when From is set to "Selector". In that case,
        only Routes in Namespaces matching this Selector will be selected by this
        Gateway. This field is ignored for other values of "From".

        Support: Core
        """
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgsDict']]]]
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
elif False:
    GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorPatchArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Selector must be specified when From is set to "Selector". In that case,
        only Routes in Namespaces matching this Selector will be selected by this
        Gateway. This field is ignored for other values of "From".

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
               map is equivalent to an element of matchExpressions, whose key field is "key", the
               operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesNamespacesSelectorArgsDict(TypedDict):
        """
        Selector must be specified when From is set to "Selector". In that case,
        only Routes in Namespaces matching this Selector will be selected by this
        Gateway. This field is ignored for other values of "From".

        Support: Core
        """
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgsDict']]]]
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
elif False:
    GatewaySpecListenersAllowedRoutesNamespacesSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Selector must be specified when From is set to "Selector". In that case,
        only Routes in Namespaces matching this Selector will be selected by this
        Gateway. This field is ignored for other values of "From".

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
               map is equivalent to an element of matchExpressions, whose key field is "key", the
               operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesNamespacesArgsDict(TypedDict):
        """
        Namespaces indicates namespaces from which Routes may be attached to this
        Listener. This is restricted to the namespace of this Gateway by default.

        Support: Core
        """
        from_: NotRequired[pulumi.Input[str]]
        """
        From indicates where Routes will be selected for this Gateway. Possible
        values are:

        * All: Routes in all namespaces may be used by this Gateway.
        * Selector: Routes in namespaces selected by the selector may be used by
          this Gateway.
        * Same: Only Routes in the same namespace may be used by this Gateway.

        Support: Core
        """
        selector: NotRequired[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorArgsDict']]
elif False:
    GatewaySpecListenersAllowedRoutesNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesNamespacesArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 selector: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs']] = None):
        """
        Namespaces indicates namespaces from which Routes may be attached to this
        Listener. This is restricted to the namespace of this Gateway by default.

        Support: Core
        :param pulumi.Input[str] from_: From indicates where Routes will be selected for this Gateway. Possible
               values are:
               
               * All: Routes in all namespaces may be used by this Gateway.
               * Selector: Routes in namespaces selected by the selector may be used by
                 this Gateway.
               * Same: Only Routes in the same namespace may be used by this Gateway.
               
               Support: Core
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        """
        From indicates where Routes will be selected for this Gateway. Possible
        values are:

        * All: Routes in all namespaces may be used by this Gateway.
        * Selector: Routes in namespaces selected by the selector may be used by
          this Gateway.
        * Same: Only Routes in the same namespace may be used by this Gateway.

        Support: Core
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesPatchArgsDict(TypedDict):
        """
        AllowedRoutes defines the types of routes that MAY be attached to a
        Listener and the trusted namespaces where those Route resources MAY be
        present.

        Although a client request may match multiple route rules, only one rule
        may ultimately receive the request. Matching precedence MUST be
        determined in order of the following criteria:

        * The most specific match as defined by the Route type.
        * The oldest Route based on creation timestamp. For example, a Route with
          a creation timestamp of "2020-09-08 01:02:03" is given precedence over
          a Route with a creation timestamp of "2020-09-08 01:02:04".
        * If everything else is equivalent, the Route appearing first in
          alphabetical order (namespace/name) should be given precedence. For
          example, foo/bar is given precedence over foo/baz.

        All valid rules within a Route attached to this Listener should be
        implemented. Invalid Route rules can be ignored (sometimes that will mean
        the full Route). If a Route rule transitions from valid to invalid,
        support for that Route rule should be dropped to ensure consistency. For
        example, even if a filter specified by a Route rule is invalid, the rest
        of the rules within that Route should still be supported.

        Support: Core
        """
        kinds: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsPatchArgsDict']]]]
        """
        Kinds specifies the groups and kinds of Routes that are allowed to bind
        to this Gateway Listener. When unspecified or empty, the kinds of Routes
        selected are determined using the Listener protocol.

        A RouteGroupKind MUST correspond to kinds of Routes that are compatible
        with the application protocol specified in the Listener's Protocol field.
        If an implementation does not support or recognize this resource type, it
        MUST set the "ResolvedRefs" condition to False for this Listener with the
        "InvalidRouteKinds" reason.

        Support: Core
        """
        namespaces: NotRequired[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesPatchArgsDict']]
elif False:
    GatewaySpecListenersAllowedRoutesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesPatchArgs:
    def __init__(__self__, *,
                 kinds: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsPatchArgs']]]] = None,
                 namespaces: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesPatchArgs']] = None):
        """
        AllowedRoutes defines the types of routes that MAY be attached to a
        Listener and the trusted namespaces where those Route resources MAY be
        present.

        Although a client request may match multiple route rules, only one rule
        may ultimately receive the request. Matching precedence MUST be
        determined in order of the following criteria:

        * The most specific match as defined by the Route type.
        * The oldest Route based on creation timestamp. For example, a Route with
          a creation timestamp of "2020-09-08 01:02:03" is given precedence over
          a Route with a creation timestamp of "2020-09-08 01:02:04".
        * If everything else is equivalent, the Route appearing first in
          alphabetical order (namespace/name) should be given precedence. For
          example, foo/bar is given precedence over foo/baz.

        All valid rules within a Route attached to this Listener should be
        implemented. Invalid Route rules can be ignored (sometimes that will mean
        the full Route). If a Route rule transitions from valid to invalid,
        support for that Route rule should be dropped to ensure consistency. For
        example, even if a filter specified by a Route rule is invalid, the rest
        of the rules within that Route should still be supported.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsPatchArgs']]] kinds: Kinds specifies the groups and kinds of Routes that are allowed to bind
               to this Gateway Listener. When unspecified or empty, the kinds of Routes
               selected are determined using the Listener protocol.
               
               A RouteGroupKind MUST correspond to kinds of Routes that are compatible
               with the application protocol specified in the Listener's Protocol field.
               If an implementation does not support or recognize this resource type, it
               MUST set the "ResolvedRefs" condition to False for this Listener with the
               "InvalidRouteKinds" reason.
               
               Support: Core
        """
        if kinds is not None:
            pulumi.set(__self__, "kinds", kinds)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def kinds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsPatchArgs']]]]:
        """
        Kinds specifies the groups and kinds of Routes that are allowed to bind
        to this Gateway Listener. When unspecified or empty, the kinds of Routes
        selected are determined using the Listener protocol.

        A RouteGroupKind MUST correspond to kinds of Routes that are compatible
        with the application protocol specified in the Listener's Protocol field.
        If an implementation does not support or recognize this resource type, it
        MUST set the "ResolvedRefs" condition to False for this Listener with the
        "InvalidRouteKinds" reason.

        Support: Core
        """
        return pulumi.get(self, "kinds")

    @kinds.setter
    def kinds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsPatchArgs']]]]):
        pulumi.set(self, "kinds", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesPatchArgs']]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesPatchArgs']]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class GatewaySpecListenersAllowedRoutesArgsDict(TypedDict):
        """
        AllowedRoutes defines the types of routes that MAY be attached to a
        Listener and the trusted namespaces where those Route resources MAY be
        present.

        Although a client request may match multiple route rules, only one rule
        may ultimately receive the request. Matching precedence MUST be
        determined in order of the following criteria:

        * The most specific match as defined by the Route type.
        * The oldest Route based on creation timestamp. For example, a Route with
          a creation timestamp of "2020-09-08 01:02:03" is given precedence over
          a Route with a creation timestamp of "2020-09-08 01:02:04".
        * If everything else is equivalent, the Route appearing first in
          alphabetical order (namespace/name) should be given precedence. For
          example, foo/bar is given precedence over foo/baz.

        All valid rules within a Route attached to this Listener should be
        implemented. Invalid Route rules can be ignored (sometimes that will mean
        the full Route). If a Route rule transitions from valid to invalid,
        support for that Route rule should be dropped to ensure consistency. For
        example, even if a filter specified by a Route rule is invalid, the rest
        of the rules within that Route should still be supported.

        Support: Core
        """
        kinds: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsArgsDict']]]]
        """
        Kinds specifies the groups and kinds of Routes that are allowed to bind
        to this Gateway Listener. When unspecified or empty, the kinds of Routes
        selected are determined using the Listener protocol.

        A RouteGroupKind MUST correspond to kinds of Routes that are compatible
        with the application protocol specified in the Listener's Protocol field.
        If an implementation does not support or recognize this resource type, it
        MUST set the "ResolvedRefs" condition to False for this Listener with the
        "InvalidRouteKinds" reason.

        Support: Core
        """
        namespaces: NotRequired[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesArgsDict']]
elif False:
    GatewaySpecListenersAllowedRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersAllowedRoutesArgs:
    def __init__(__self__, *,
                 kinds: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsArgs']]]] = None,
                 namespaces: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesArgs']] = None):
        """
        AllowedRoutes defines the types of routes that MAY be attached to a
        Listener and the trusted namespaces where those Route resources MAY be
        present.

        Although a client request may match multiple route rules, only one rule
        may ultimately receive the request. Matching precedence MUST be
        determined in order of the following criteria:

        * The most specific match as defined by the Route type.
        * The oldest Route based on creation timestamp. For example, a Route with
          a creation timestamp of "2020-09-08 01:02:03" is given precedence over
          a Route with a creation timestamp of "2020-09-08 01:02:04".
        * If everything else is equivalent, the Route appearing first in
          alphabetical order (namespace/name) should be given precedence. For
          example, foo/bar is given precedence over foo/baz.

        All valid rules within a Route attached to this Listener should be
        implemented. Invalid Route rules can be ignored (sometimes that will mean
        the full Route). If a Route rule transitions from valid to invalid,
        support for that Route rule should be dropped to ensure consistency. For
        example, even if a filter specified by a Route rule is invalid, the rest
        of the rules within that Route should still be supported.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsArgs']]] kinds: Kinds specifies the groups and kinds of Routes that are allowed to bind
               to this Gateway Listener. When unspecified or empty, the kinds of Routes
               selected are determined using the Listener protocol.
               
               A RouteGroupKind MUST correspond to kinds of Routes that are compatible
               with the application protocol specified in the Listener's Protocol field.
               If an implementation does not support or recognize this resource type, it
               MUST set the "ResolvedRefs" condition to False for this Listener with the
               "InvalidRouteKinds" reason.
               
               Support: Core
        """
        if kinds is not None:
            pulumi.set(__self__, "kinds", kinds)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def kinds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsArgs']]]]:
        """
        Kinds specifies the groups and kinds of Routes that are allowed to bind
        to this Gateway Listener. When unspecified or empty, the kinds of Routes
        selected are determined using the Listener protocol.

        A RouteGroupKind MUST correspond to kinds of Routes that are compatible
        with the application protocol specified in the Listener's Protocol field.
        If an implementation does not support or recognize this resource type, it
        MUST set the "ResolvedRefs" condition to False for this Listener with the
        "InvalidRouteKinds" reason.

        Support: Core
        """
        return pulumi.get(self, "kinds")

    @kinds.setter
    def kinds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersAllowedRoutesKindsArgs']]]]):
        pulumi.set(self, "kinds", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesArgs']]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesNamespacesArgs']]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class GatewaySpecListenersPatchArgsDict(TypedDict):
        """
        Listener embodies the concept of a logical endpoint where a Gateway accepts
        network connections.
        """
        allowed_routes: NotRequired[pulumi.Input['GatewaySpecListenersAllowedRoutesPatchArgsDict']]
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname specifies the virtual hostname to match for protocol types that
        define this concept. When unspecified, all hostnames are matched. This
        field is ignored for protocols that don't require hostname based
        matching.

        Implementations MUST apply Hostname matching appropriately for each of
        the following protocols:

        * TLS: The Listener Hostname MUST match the SNI.
        * HTTP: The Listener Hostname MUST match the Host header of the request.
        * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
          protocol layers as described above. If an implementation does not
          ensure that both the SNI and Host header match the Listener hostname,
          it MUST clearly document that.

        For HTTPRoute and TLSRoute resources, there is an interaction with the
        `spec.hostnames` array. When both listener and route specify hostnames,
        there MUST be an intersection between the values for a Route to be
        accepted. For more information, refer to the Route specific Hostnames
        documentation.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        Support: Core
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the Listener. This name MUST be unique within a
        Gateway.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port. Multiple listeners may use the
        same port, subject to the Listener compatibility rules.

        Support: Core
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol specifies the network protocol this listener expects to receive.

        Support: Core
        """
        tls: NotRequired[pulumi.Input['GatewaySpecListenersTlsPatchArgsDict']]
elif False:
    GatewaySpecListenersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersPatchArgs:
    def __init__(__self__, *,
                 allowed_routes: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesPatchArgs']] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input['GatewaySpecListenersTlsPatchArgs']] = None):
        """
        Listener embodies the concept of a logical endpoint where a Gateway accepts
        network connections.
        :param pulumi.Input[str] hostname: Hostname specifies the virtual hostname to match for protocol types that
               define this concept. When unspecified, all hostnames are matched. This
               field is ignored for protocols that don't require hostname based
               matching.
               
               Implementations MUST apply Hostname matching appropriately for each of
               the following protocols:
               
               * TLS: The Listener Hostname MUST match the SNI.
               * HTTP: The Listener Hostname MUST match the Host header of the request.
               * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
                 protocol layers as described above. If an implementation does not
                 ensure that both the SNI and Host header match the Listener hostname,
                 it MUST clearly document that.
               
               For HTTPRoute and TLSRoute resources, there is an interaction with the
               `spec.hostnames` array. When both listener and route specify hostnames,
               there MUST be an intersection between the values for a Route to be
               accepted. For more information, refer to the Route specific Hostnames
               documentation.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               Support: Core
        :param pulumi.Input[str] name: Name is the name of the Listener. This name MUST be unique within a
               Gateway.
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port. Multiple listeners may use the
               same port, subject to the Listener compatibility rules.
               
               Support: Core
        :param pulumi.Input[str] protocol: Protocol specifies the network protocol this listener expects to receive.
               
               Support: Core
        """
        if allowed_routes is not None:
            pulumi.set(__self__, "allowed_routes", allowed_routes)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="allowedRoutes")
    def allowed_routes(self) -> Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesPatchArgs']]:
        return pulumi.get(self, "allowed_routes")

    @allowed_routes.setter
    def allowed_routes(self, value: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesPatchArgs']]):
        pulumi.set(self, "allowed_routes", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname specifies the virtual hostname to match for protocol types that
        define this concept. When unspecified, all hostnames are matched. This
        field is ignored for protocols that don't require hostname based
        matching.

        Implementations MUST apply Hostname matching appropriately for each of
        the following protocols:

        * TLS: The Listener Hostname MUST match the SNI.
        * HTTP: The Listener Hostname MUST match the Host header of the request.
        * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
          protocol layers as described above. If an implementation does not
          ensure that both the SNI and Host header match the Listener hostname,
          it MUST clearly document that.

        For HTTPRoute and TLSRoute resources, there is an interaction with the
        `spec.hostnames` array. When both listener and route specify hostnames,
        there MUST be an intersection between the values for a Route to be
        accepted. For more information, refer to the Route specific Hostnames
        documentation.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the Listener. This name MUST be unique within a
        Gateway.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port. Multiple listeners may use the
        same port, subject to the Listener compatibility rules.

        Support: Core
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol specifies the network protocol this listener expects to receive.

        Support: Core
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['GatewaySpecListenersTlsPatchArgs']]:
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['GatewaySpecListenersTlsPatchArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class GatewaySpecListenersTlsCertificateRefsPatchArgsDict(TypedDict):
        """
        SecretObjectReference identifies an API object including its namespace,
        defaulting to Secret.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        References to objects with invalid Group and Kind are not valid, and must
        be rejected by the implementation, with appropriate Conditions set
        on the containing object.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "Secret".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referenced object. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
elif False:
    GatewaySpecListenersTlsCertificateRefsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersTlsCertificateRefsPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        SecretObjectReference identifies an API object including its namespace,
        defaulting to Secret.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        References to objects with invalid Group and Kind are not valid, and must
        be rejected by the implementation, with appropriate Conditions set
        on the containing object.
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "Secret".
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referenced object. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "Secret".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referenced object. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GatewaySpecListenersTlsCertificateRefsArgsDict(TypedDict):
        """
        SecretObjectReference identifies an API object including its namespace,
        defaulting to Secret.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        References to objects with invalid Group and Kind are not valid, and must
        be rejected by the implementation, with appropriate Conditions set
        on the containing object.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "Secret".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referenced object. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
elif False:
    GatewaySpecListenersTlsCertificateRefsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersTlsCertificateRefsArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        SecretObjectReference identifies an API object including its namespace,
        defaulting to Secret.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        References to objects with invalid Group and Kind are not valid, and must
        be rejected by the implementation, with appropriate Conditions set
        on the containing object.
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "Secret".
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referenced object. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "Secret".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referenced object. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GatewaySpecListenersTlsPatchArgsDict(TypedDict):
        """
        TLS is the TLS configuration for the Listener. This field is required if
        the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
        if the Protocol field is "HTTP", "TCP", or "UDP".

        The association of SNIs to Certificate defined in GatewayTLSConfig is
        defined based on the Hostname field for this listener.

        The GatewayClass MUST use the longest matching SNI out of all
        available certificates for any TLS handshake.

        Support: Core
        """
        certificate_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsPatchArgsDict']]]]
        """
        CertificateRefs contains a series of references to Kubernetes objects that
        contains TLS certificates and private keys. These certificates are used to
        establish a TLS handshake for requests that match the hostname of the
        associated listener.

        A single CertificateRef to a Kubernetes Secret has "Core" support.
        Implementations MAY choose to support attaching multiple certificates to
        a Listener, but this behavior is implementation-specific.

        References to a resource in different namespace are invalid UNLESS there
        is a ReferenceGrant in the target namespace that allows the certificate
        to be attached. If a ReferenceGrant does not allow this reference, the
        "ResolvedRefs" condition MUST be set to False for this listener with the
        "RefNotPermitted" reason.

        This field is required to have at least one element when the mode is set
        to "Terminate" (default) and is optional otherwise.

        CertificateRefs can reference to standard Kubernetes resources, i.e.
        Secret, or implementation-specific custom resources.

        Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls

        Support: Implementation-specific (More than one reference or other resource types)
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Mode defines the TLS behavior for the TLS session initiated by the client.
        There are two possible modes:

        - Terminate: The TLS session between the downstream client and the
          Gateway is terminated at the Gateway. This mode requires certificates
          to be specified in some way, such as populating the certificateRefs
          field.
        - Passthrough: The TLS session is NOT terminated by the Gateway. This
          implies that the Gateway can't decipher the TLS stream except for
          the ClientHello message of the TLS protocol. The certificateRefs field
          is ignored in this mode.

        Support: Core
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Options are a list of key/value pairs to enable extended TLS
        configuration for each implementation. For example, configuring the
        minimum TLS version or supported cipher suites.

        A set of common keys MAY be defined by the API in the future. To avoid
        any ambiguity, implementation-specific definitions MUST use
        domain-prefixed names, such as `example.com/my-custom-option`.
        Un-prefixed names are reserved for key names defined by Gateway API.

        Support: Implementation-specific
        """
elif False:
    GatewaySpecListenersTlsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersTlsPatchArgs:
    def __init__(__self__, *,
                 certificate_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsPatchArgs']]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        TLS is the TLS configuration for the Listener. This field is required if
        the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
        if the Protocol field is "HTTP", "TCP", or "UDP".

        The association of SNIs to Certificate defined in GatewayTLSConfig is
        defined based on the Hostname field for this listener.

        The GatewayClass MUST use the longest matching SNI out of all
        available certificates for any TLS handshake.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsPatchArgs']]] certificate_refs: CertificateRefs contains a series of references to Kubernetes objects that
               contains TLS certificates and private keys. These certificates are used to
               establish a TLS handshake for requests that match the hostname of the
               associated listener.
               
               A single CertificateRef to a Kubernetes Secret has "Core" support.
               Implementations MAY choose to support attaching multiple certificates to
               a Listener, but this behavior is implementation-specific.
               
               References to a resource in different namespace are invalid UNLESS there
               is a ReferenceGrant in the target namespace that allows the certificate
               to be attached. If a ReferenceGrant does not allow this reference, the
               "ResolvedRefs" condition MUST be set to False for this listener with the
               "RefNotPermitted" reason.
               
               This field is required to have at least one element when the mode is set
               to "Terminate" (default) and is optional otherwise.
               
               CertificateRefs can reference to standard Kubernetes resources, i.e.
               Secret, or implementation-specific custom resources.
               
               Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
               
               Support: Implementation-specific (More than one reference or other resource types)
        :param pulumi.Input[str] mode: Mode defines the TLS behavior for the TLS session initiated by the client.
               There are two possible modes:
               
               - Terminate: The TLS session between the downstream client and the
                 Gateway is terminated at the Gateway. This mode requires certificates
                 to be specified in some way, such as populating the certificateRefs
                 field.
               - Passthrough: The TLS session is NOT terminated by the Gateway. This
                 implies that the Gateway can't decipher the TLS stream except for
                 the ClientHello message of the TLS protocol. The certificateRefs field
                 is ignored in this mode.
               
               Support: Core
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: Options are a list of key/value pairs to enable extended TLS
               configuration for each implementation. For example, configuring the
               minimum TLS version or supported cipher suites.
               
               A set of common keys MAY be defined by the API in the future. To avoid
               any ambiguity, implementation-specific definitions MUST use
               domain-prefixed names, such as `example.com/my-custom-option`.
               Un-prefixed names are reserved for key names defined by Gateway API.
               
               Support: Implementation-specific
        """
        if certificate_refs is not None:
            pulumi.set(__self__, "certificate_refs", certificate_refs)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter(name="certificateRefs")
    def certificate_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsPatchArgs']]]]:
        """
        CertificateRefs contains a series of references to Kubernetes objects that
        contains TLS certificates and private keys. These certificates are used to
        establish a TLS handshake for requests that match the hostname of the
        associated listener.

        A single CertificateRef to a Kubernetes Secret has "Core" support.
        Implementations MAY choose to support attaching multiple certificates to
        a Listener, but this behavior is implementation-specific.

        References to a resource in different namespace are invalid UNLESS there
        is a ReferenceGrant in the target namespace that allows the certificate
        to be attached. If a ReferenceGrant does not allow this reference, the
        "ResolvedRefs" condition MUST be set to False for this listener with the
        "RefNotPermitted" reason.

        This field is required to have at least one element when the mode is set
        to "Terminate" (default) and is optional otherwise.

        CertificateRefs can reference to standard Kubernetes resources, i.e.
        Secret, or implementation-specific custom resources.

        Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls

        Support: Implementation-specific (More than one reference or other resource types)
        """
        return pulumi.get(self, "certificate_refs")

    @certificate_refs.setter
    def certificate_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsPatchArgs']]]]):
        pulumi.set(self, "certificate_refs", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode defines the TLS behavior for the TLS session initiated by the client.
        There are two possible modes:

        - Terminate: The TLS session between the downstream client and the
          Gateway is terminated at the Gateway. This mode requires certificates
          to be specified in some way, such as populating the certificateRefs
          field.
        - Passthrough: The TLS session is NOT terminated by the Gateway. This
          implies that the Gateway can't decipher the TLS stream except for
          the ClientHello message of the TLS protocol. The certificateRefs field
          is ignored in this mode.

        Support: Core
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Options are a list of key/value pairs to enable extended TLS
        configuration for each implementation. For example, configuring the
        minimum TLS version or supported cipher suites.

        A set of common keys MAY be defined by the API in the future. To avoid
        any ambiguity, implementation-specific definitions MUST use
        domain-prefixed names, such as `example.com/my-custom-option`.
        Un-prefixed names are reserved for key names defined by Gateway API.

        Support: Implementation-specific
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class GatewaySpecListenersTlsArgsDict(TypedDict):
        """
        TLS is the TLS configuration for the Listener. This field is required if
        the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
        if the Protocol field is "HTTP", "TCP", or "UDP".

        The association of SNIs to Certificate defined in GatewayTLSConfig is
        defined based on the Hostname field for this listener.

        The GatewayClass MUST use the longest matching SNI out of all
        available certificates for any TLS handshake.

        Support: Core
        """
        certificate_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsArgsDict']]]]
        """
        CertificateRefs contains a series of references to Kubernetes objects that
        contains TLS certificates and private keys. These certificates are used to
        establish a TLS handshake for requests that match the hostname of the
        associated listener.

        A single CertificateRef to a Kubernetes Secret has "Core" support.
        Implementations MAY choose to support attaching multiple certificates to
        a Listener, but this behavior is implementation-specific.

        References to a resource in different namespace are invalid UNLESS there
        is a ReferenceGrant in the target namespace that allows the certificate
        to be attached. If a ReferenceGrant does not allow this reference, the
        "ResolvedRefs" condition MUST be set to False for this listener with the
        "RefNotPermitted" reason.

        This field is required to have at least one element when the mode is set
        to "Terminate" (default) and is optional otherwise.

        CertificateRefs can reference to standard Kubernetes resources, i.e.
        Secret, or implementation-specific custom resources.

        Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls

        Support: Implementation-specific (More than one reference or other resource types)
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Mode defines the TLS behavior for the TLS session initiated by the client.
        There are two possible modes:

        - Terminate: The TLS session between the downstream client and the
          Gateway is terminated at the Gateway. This mode requires certificates
          to be specified in some way, such as populating the certificateRefs
          field.
        - Passthrough: The TLS session is NOT terminated by the Gateway. This
          implies that the Gateway can't decipher the TLS stream except for
          the ClientHello message of the TLS protocol. The certificateRefs field
          is ignored in this mode.

        Support: Core
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Options are a list of key/value pairs to enable extended TLS
        configuration for each implementation. For example, configuring the
        minimum TLS version or supported cipher suites.

        A set of common keys MAY be defined by the API in the future. To avoid
        any ambiguity, implementation-specific definitions MUST use
        domain-prefixed names, such as `example.com/my-custom-option`.
        Un-prefixed names are reserved for key names defined by Gateway API.

        Support: Implementation-specific
        """
elif False:
    GatewaySpecListenersTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersTlsArgs:
    def __init__(__self__, *,
                 certificate_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsArgs']]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        TLS is the TLS configuration for the Listener. This field is required if
        the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
        if the Protocol field is "HTTP", "TCP", or "UDP".

        The association of SNIs to Certificate defined in GatewayTLSConfig is
        defined based on the Hostname field for this listener.

        The GatewayClass MUST use the longest matching SNI out of all
        available certificates for any TLS handshake.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsArgs']]] certificate_refs: CertificateRefs contains a series of references to Kubernetes objects that
               contains TLS certificates and private keys. These certificates are used to
               establish a TLS handshake for requests that match the hostname of the
               associated listener.
               
               A single CertificateRef to a Kubernetes Secret has "Core" support.
               Implementations MAY choose to support attaching multiple certificates to
               a Listener, but this behavior is implementation-specific.
               
               References to a resource in different namespace are invalid UNLESS there
               is a ReferenceGrant in the target namespace that allows the certificate
               to be attached. If a ReferenceGrant does not allow this reference, the
               "ResolvedRefs" condition MUST be set to False for this listener with the
               "RefNotPermitted" reason.
               
               This field is required to have at least one element when the mode is set
               to "Terminate" (default) and is optional otherwise.
               
               CertificateRefs can reference to standard Kubernetes resources, i.e.
               Secret, or implementation-specific custom resources.
               
               Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
               
               Support: Implementation-specific (More than one reference or other resource types)
        :param pulumi.Input[str] mode: Mode defines the TLS behavior for the TLS session initiated by the client.
               There are two possible modes:
               
               - Terminate: The TLS session between the downstream client and the
                 Gateway is terminated at the Gateway. This mode requires certificates
                 to be specified in some way, such as populating the certificateRefs
                 field.
               - Passthrough: The TLS session is NOT terminated by the Gateway. This
                 implies that the Gateway can't decipher the TLS stream except for
                 the ClientHello message of the TLS protocol. The certificateRefs field
                 is ignored in this mode.
               
               Support: Core
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: Options are a list of key/value pairs to enable extended TLS
               configuration for each implementation. For example, configuring the
               minimum TLS version or supported cipher suites.
               
               A set of common keys MAY be defined by the API in the future. To avoid
               any ambiguity, implementation-specific definitions MUST use
               domain-prefixed names, such as `example.com/my-custom-option`.
               Un-prefixed names are reserved for key names defined by Gateway API.
               
               Support: Implementation-specific
        """
        if certificate_refs is not None:
            pulumi.set(__self__, "certificate_refs", certificate_refs)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter(name="certificateRefs")
    def certificate_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsArgs']]]]:
        """
        CertificateRefs contains a series of references to Kubernetes objects that
        contains TLS certificates and private keys. These certificates are used to
        establish a TLS handshake for requests that match the hostname of the
        associated listener.

        A single CertificateRef to a Kubernetes Secret has "Core" support.
        Implementations MAY choose to support attaching multiple certificates to
        a Listener, but this behavior is implementation-specific.

        References to a resource in different namespace are invalid UNLESS there
        is a ReferenceGrant in the target namespace that allows the certificate
        to be attached. If a ReferenceGrant does not allow this reference, the
        "ResolvedRefs" condition MUST be set to False for this listener with the
        "RefNotPermitted" reason.

        This field is required to have at least one element when the mode is set
        to "Terminate" (default) and is optional otherwise.

        CertificateRefs can reference to standard Kubernetes resources, i.e.
        Secret, or implementation-specific custom resources.

        Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls

        Support: Implementation-specific (More than one reference or other resource types)
        """
        return pulumi.get(self, "certificate_refs")

    @certificate_refs.setter
    def certificate_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersTlsCertificateRefsArgs']]]]):
        pulumi.set(self, "certificate_refs", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode defines the TLS behavior for the TLS session initiated by the client.
        There are two possible modes:

        - Terminate: The TLS session between the downstream client and the
          Gateway is terminated at the Gateway. This mode requires certificates
          to be specified in some way, such as populating the certificateRefs
          field.
        - Passthrough: The TLS session is NOT terminated by the Gateway. This
          implies that the Gateway can't decipher the TLS stream except for
          the ClientHello message of the TLS protocol. The certificateRefs field
          is ignored in this mode.

        Support: Core
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Options are a list of key/value pairs to enable extended TLS
        configuration for each implementation. For example, configuring the
        minimum TLS version or supported cipher suites.

        A set of common keys MAY be defined by the API in the future. To avoid
        any ambiguity, implementation-specific definitions MUST use
        domain-prefixed names, such as `example.com/my-custom-option`.
        Un-prefixed names are reserved for key names defined by Gateway API.

        Support: Implementation-specific
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class GatewaySpecListenersArgsDict(TypedDict):
        """
        Listener embodies the concept of a logical endpoint where a Gateway accepts
        network connections.
        """
        allowed_routes: NotRequired[pulumi.Input['GatewaySpecListenersAllowedRoutesArgsDict']]
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname specifies the virtual hostname to match for protocol types that
        define this concept. When unspecified, all hostnames are matched. This
        field is ignored for protocols that don't require hostname based
        matching.

        Implementations MUST apply Hostname matching appropriately for each of
        the following protocols:

        * TLS: The Listener Hostname MUST match the SNI.
        * HTTP: The Listener Hostname MUST match the Host header of the request.
        * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
          protocol layers as described above. If an implementation does not
          ensure that both the SNI and Host header match the Listener hostname,
          it MUST clearly document that.

        For HTTPRoute and TLSRoute resources, there is an interaction with the
        `spec.hostnames` array. When both listener and route specify hostnames,
        there MUST be an intersection between the values for a Route to be
        accepted. For more information, refer to the Route specific Hostnames
        documentation.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        Support: Core
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the Listener. This name MUST be unique within a
        Gateway.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port. Multiple listeners may use the
        same port, subject to the Listener compatibility rules.

        Support: Core
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol specifies the network protocol this listener expects to receive.

        Support: Core
        """
        tls: NotRequired[pulumi.Input['GatewaySpecListenersTlsArgsDict']]
elif False:
    GatewaySpecListenersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecListenersArgs:
    def __init__(__self__, *,
                 allowed_routes: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesArgs']] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input['GatewaySpecListenersTlsArgs']] = None):
        """
        Listener embodies the concept of a logical endpoint where a Gateway accepts
        network connections.
        :param pulumi.Input[str] hostname: Hostname specifies the virtual hostname to match for protocol types that
               define this concept. When unspecified, all hostnames are matched. This
               field is ignored for protocols that don't require hostname based
               matching.
               
               Implementations MUST apply Hostname matching appropriately for each of
               the following protocols:
               
               * TLS: The Listener Hostname MUST match the SNI.
               * HTTP: The Listener Hostname MUST match the Host header of the request.
               * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
                 protocol layers as described above. If an implementation does not
                 ensure that both the SNI and Host header match the Listener hostname,
                 it MUST clearly document that.
               
               For HTTPRoute and TLSRoute resources, there is an interaction with the
               `spec.hostnames` array. When both listener and route specify hostnames,
               there MUST be an intersection between the values for a Route to be
               accepted. For more information, refer to the Route specific Hostnames
               documentation.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               Support: Core
        :param pulumi.Input[str] name: Name is the name of the Listener. This name MUST be unique within a
               Gateway.
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port. Multiple listeners may use the
               same port, subject to the Listener compatibility rules.
               
               Support: Core
        :param pulumi.Input[str] protocol: Protocol specifies the network protocol this listener expects to receive.
               
               Support: Core
        """
        if allowed_routes is not None:
            pulumi.set(__self__, "allowed_routes", allowed_routes)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="allowedRoutes")
    def allowed_routes(self) -> Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesArgs']]:
        return pulumi.get(self, "allowed_routes")

    @allowed_routes.setter
    def allowed_routes(self, value: Optional[pulumi.Input['GatewaySpecListenersAllowedRoutesArgs']]):
        pulumi.set(self, "allowed_routes", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname specifies the virtual hostname to match for protocol types that
        define this concept. When unspecified, all hostnames are matched. This
        field is ignored for protocols that don't require hostname based
        matching.

        Implementations MUST apply Hostname matching appropriately for each of
        the following protocols:

        * TLS: The Listener Hostname MUST match the SNI.
        * HTTP: The Listener Hostname MUST match the Host header of the request.
        * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
          protocol layers as described above. If an implementation does not
          ensure that both the SNI and Host header match the Listener hostname,
          it MUST clearly document that.

        For HTTPRoute and TLSRoute resources, there is an interaction with the
        `spec.hostnames` array. When both listener and route specify hostnames,
        there MUST be an intersection between the values for a Route to be
        accepted. For more information, refer to the Route specific Hostnames
        documentation.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the Listener. This name MUST be unique within a
        Gateway.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port. Multiple listeners may use the
        same port, subject to the Listener compatibility rules.

        Support: Core
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol specifies the network protocol this listener expects to receive.

        Support: Core
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['GatewaySpecListenersTlsArgs']]:
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['GatewaySpecListenersTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class GatewaySpecPatchArgsDict(TypedDict):
        """
        Spec defines the desired state of Gateway.
        """
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesPatchArgsDict']]]]
        """
        Addresses requested for this Gateway. This is optional and behavior can
        depend on the implementation. If a value is set in the spec and the
        requested address is invalid or unavailable, the implementation MUST
        indicate this in the associated entry in GatewayStatus.Addresses.

        The Addresses field represents a request for the address(es) on the
        "outside of the Gateway", that traffic bound for this Gateway will use.
        This could be the IP address or hostname of an external load balancer or
        other networking infrastructure, or some other address that traffic will
        be sent to.

        If no Addresses are specified, the implementation MAY schedule the
        Gateway in an implementation-specific manner, assigning an appropriate
        set of Addresses.

        The implementation MUST bind all Listeners to every GatewayAddress that
        it assigns to the Gateway and add a corresponding entry in
        GatewayStatus.Addresses.

        Support: Extended
        """
        gateway_class_name: NotRequired[pulumi.Input[str]]
        """
        GatewayClassName used for this Gateway. This is the name of a
        GatewayClass resource.
        """
        infrastructure: NotRequired[pulumi.Input['GatewaySpecInfrastructurePatchArgsDict']]
        listeners: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersPatchArgsDict']]]]
        """
        Listeners associated with this Gateway. Listeners define
        logical endpoints that are bound on this Gateway's addresses.
        At least one Listener MUST be specified.

        Each Listener in a set of Listeners (for example, in a single Gateway)
        MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
        exactly one listener. (This section uses "set of Listeners" rather than
        "Listeners in a single Gateway" because implementations MAY merge configuration
        from multiple Gateways onto a single data plane, and these rules _also_
        apply in that case).

        Practically, this means that each listener in a set MUST have a unique
        combination of Port, Protocol, and, if supported by the protocol, Hostname.

        Some combinations of port, protocol, and TLS settings are considered
        Core support and MUST be supported by implementations based on their
        targeted conformance profile:

        HTTP Profile

        1. HTTPRoute, Port: 80, Protocol: HTTP
        2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided

        TLS Profile

        1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough

        "Distinct" Listeners have the following property:

        The implementation can match inbound requests to a single distinct
        Listener. When multiple Listeners share values for fields (for
        example, two Listeners with the same Port value), the implementation
        can match requests to only one of the Listeners using other
        Listener fields.

        For example, the following Listener scenarios are distinct:

        1. Multiple Listeners with the same Port that all use the "HTTP"
           Protocol that all have unique Hostname values.
        2. Multiple Listeners with the same Port that use either the "HTTPS" or
           "TLS" Protocol that all have unique Hostname values.
        3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
           with the same Protocol has the same Port value.

        Some fields in the Listener struct have possible values that affect
        whether the Listener is distinct. Hostname is particularly relevant
        for HTTP or HTTPS protocols.

        When using the Hostname value to select between same-Port, same-Protocol
        Listeners, the Hostname value must be different on each Listener for the
        Listener to be distinct.

        When the Listeners are distinct based on Hostname, inbound request
        hostnames MUST match from the most specific to least specific Hostname
        values to choose the correct Listener and its associated set of Routes.

        Exact matches must be processed before wildcard matches, and wildcard
        matches must be processed before fallback (empty Hostname value)
        matches. For example, `"foo.example.com"` takes precedence over
        `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.

        Additionally, if there are multiple wildcard entries, more specific
        wildcard entries must be processed before less specific wildcard entries.
        For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
        The precise definition here is that the higher the number of dots in the
        hostname to the right of the wildcard character, the higher the precedence.

        The wildcard character will match any number of characters _and dots_ to
        the left, however, so `"*.example.com"` will match both
        `"foo.bar.example.com"` _and_ `"bar.example.com"`.

        If a set of Listeners contains Listeners that are not distinct, then those
        Listeners are Conflicted, and the implementation MUST set the "Conflicted"
        condition in the Listener Status to "True".

        Implementations MAY choose to accept a Gateway with some Conflicted
        Listeners only if they only accept the partial Listener set that contains
        no Conflicted Listeners. To put this another way, implementations may
        accept a partial Listener set only if they throw out *all* the conflicting
        Listeners. No picking one of the conflicting listeners as the winner.
        This also means that the Gateway must have at least one non-conflicting
        Listener in this case, otherwise it violates the requirement that at
        least one Listener must be present.

        The implementation MUST set a "ListenersNotValid" condition on the
        Gateway Status when the Gateway contains Conflicted Listeners whether or
        not they accept the Gateway. That Condition SHOULD clearly
        indicate in the Message which Listeners are conflicted, and which are
        Accepted. Additionally, the Listener status for those listeners SHOULD
        indicate which Listeners are conflicted and not Accepted.

        A Gateway's Listeners are considered "compatible" if:

        1. They are distinct.
        2. The implementation can serve them in compliance with the Addresses
           requirement that all Listeners are available on all assigned
           addresses.

        Compatible combinations in Extended support are expected to vary across
        implementations. A combination that is compatible for one implementation
        may not be compatible for another.

        For example, an implementation that cannot serve both TCP and UDP listeners
        on the same address, or cannot mix HTTPS and generic TLS listens on the same port
        would not consider those cases compatible, even though they are distinct.

        Note that requests SHOULD match at most one Listener. For example, if
        Listeners are defined for "foo.example.com" and "*.example.com", a
        request to "foo.example.com" SHOULD only be routed using routes attached
        to the "foo.example.com" Listener (and not the "*.example.com" Listener).
        This concept is known as "Listener Isolation". Implementations that do
        not support Listener Isolation MUST clearly document this.

        Implementations MAY merge separate Gateways onto a single set of
        Addresses if all Listeners across all Gateways are compatible.

        Support: Core
        """
elif False:
    GatewaySpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecPatchArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesPatchArgs']]]] = None,
                 gateway_class_name: Optional[pulumi.Input[str]] = None,
                 infrastructure: Optional[pulumi.Input['GatewaySpecInfrastructurePatchArgs']] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersPatchArgs']]]] = None):
        """
        Spec defines the desired state of Gateway.
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesPatchArgs']]] addresses: Addresses requested for this Gateway. This is optional and behavior can
               depend on the implementation. If a value is set in the spec and the
               requested address is invalid or unavailable, the implementation MUST
               indicate this in the associated entry in GatewayStatus.Addresses.
               
               The Addresses field represents a request for the address(es) on the
               "outside of the Gateway", that traffic bound for this Gateway will use.
               This could be the IP address or hostname of an external load balancer or
               other networking infrastructure, or some other address that traffic will
               be sent to.
               
               If no Addresses are specified, the implementation MAY schedule the
               Gateway in an implementation-specific manner, assigning an appropriate
               set of Addresses.
               
               The implementation MUST bind all Listeners to every GatewayAddress that
               it assigns to the Gateway and add a corresponding entry in
               GatewayStatus.Addresses.
               
               Support: Extended
        :param pulumi.Input[str] gateway_class_name: GatewayClassName used for this Gateway. This is the name of a
               GatewayClass resource.
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersPatchArgs']]] listeners: Listeners associated with this Gateway. Listeners define
               logical endpoints that are bound on this Gateway's addresses.
               At least one Listener MUST be specified.
               
               Each Listener in a set of Listeners (for example, in a single Gateway)
               MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
               exactly one listener. (This section uses "set of Listeners" rather than
               "Listeners in a single Gateway" because implementations MAY merge configuration
               from multiple Gateways onto a single data plane, and these rules _also_
               apply in that case).
               
               Practically, this means that each listener in a set MUST have a unique
               combination of Port, Protocol, and, if supported by the protocol, Hostname.
               
               Some combinations of port, protocol, and TLS settings are considered
               Core support and MUST be supported by implementations based on their
               targeted conformance profile:
               
               HTTP Profile
               
               1. HTTPRoute, Port: 80, Protocol: HTTP
               2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
               
               TLS Profile
               
               1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
               
               "Distinct" Listeners have the following property:
               
               The implementation can match inbound requests to a single distinct
               Listener. When multiple Listeners share values for fields (for
               example, two Listeners with the same Port value), the implementation
               can match requests to only one of the Listeners using other
               Listener fields.
               
               For example, the following Listener scenarios are distinct:
               
               1. Multiple Listeners with the same Port that all use the "HTTP"
                  Protocol that all have unique Hostname values.
               2. Multiple Listeners with the same Port that use either the "HTTPS" or
                  "TLS" Protocol that all have unique Hostname values.
               3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
                  with the same Protocol has the same Port value.
               
               Some fields in the Listener struct have possible values that affect
               whether the Listener is distinct. Hostname is particularly relevant
               for HTTP or HTTPS protocols.
               
               When using the Hostname value to select between same-Port, same-Protocol
               Listeners, the Hostname value must be different on each Listener for the
               Listener to be distinct.
               
               When the Listeners are distinct based on Hostname, inbound request
               hostnames MUST match from the most specific to least specific Hostname
               values to choose the correct Listener and its associated set of Routes.
               
               Exact matches must be processed before wildcard matches, and wildcard
               matches must be processed before fallback (empty Hostname value)
               matches. For example, `"foo.example.com"` takes precedence over
               `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
               
               Additionally, if there are multiple wildcard entries, more specific
               wildcard entries must be processed before less specific wildcard entries.
               For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
               The precise definition here is that the higher the number of dots in the
               hostname to the right of the wildcard character, the higher the precedence.
               
               The wildcard character will match any number of characters _and dots_ to
               the left, however, so `"*.example.com"` will match both
               `"foo.bar.example.com"` _and_ `"bar.example.com"`.
               
               If a set of Listeners contains Listeners that are not distinct, then those
               Listeners are Conflicted, and the implementation MUST set the "Conflicted"
               condition in the Listener Status to "True".
               
               Implementations MAY choose to accept a Gateway with some Conflicted
               Listeners only if they only accept the partial Listener set that contains
               no Conflicted Listeners. To put this another way, implementations may
               accept a partial Listener set only if they throw out *all* the conflicting
               Listeners. No picking one of the conflicting listeners as the winner.
               This also means that the Gateway must have at least one non-conflicting
               Listener in this case, otherwise it violates the requirement that at
               least one Listener must be present.
               
               The implementation MUST set a "ListenersNotValid" condition on the
               Gateway Status when the Gateway contains Conflicted Listeners whether or
               not they accept the Gateway. That Condition SHOULD clearly
               indicate in the Message which Listeners are conflicted, and which are
               Accepted. Additionally, the Listener status for those listeners SHOULD
               indicate which Listeners are conflicted and not Accepted.
               
               A Gateway's Listeners are considered "compatible" if:
               
               1. They are distinct.
               2. The implementation can serve them in compliance with the Addresses
                  requirement that all Listeners are available on all assigned
                  addresses.
               
               Compatible combinations in Extended support are expected to vary across
               implementations. A combination that is compatible for one implementation
               may not be compatible for another.
               
               For example, an implementation that cannot serve both TCP and UDP listeners
               on the same address, or cannot mix HTTPS and generic TLS listens on the same port
               would not consider those cases compatible, even though they are distinct.
               
               Note that requests SHOULD match at most one Listener. For example, if
               Listeners are defined for "foo.example.com" and "*.example.com", a
               request to "foo.example.com" SHOULD only be routed using routes attached
               to the "foo.example.com" Listener (and not the "*.example.com" Listener).
               This concept is known as "Listener Isolation". Implementations that do
               not support Listener Isolation MUST clearly document this.
               
               Implementations MAY merge separate Gateways onto a single set of
               Addresses if all Listeners across all Gateways are compatible.
               
               Support: Core
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if gateway_class_name is not None:
            pulumi.set(__self__, "gateway_class_name", gateway_class_name)
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesPatchArgs']]]]:
        """
        Addresses requested for this Gateway. This is optional and behavior can
        depend on the implementation. If a value is set in the spec and the
        requested address is invalid or unavailable, the implementation MUST
        indicate this in the associated entry in GatewayStatus.Addresses.

        The Addresses field represents a request for the address(es) on the
        "outside of the Gateway", that traffic bound for this Gateway will use.
        This could be the IP address or hostname of an external load balancer or
        other networking infrastructure, or some other address that traffic will
        be sent to.

        If no Addresses are specified, the implementation MAY schedule the
        Gateway in an implementation-specific manner, assigning an appropriate
        set of Addresses.

        The implementation MUST bind all Listeners to every GatewayAddress that
        it assigns to the Gateway and add a corresponding entry in
        GatewayStatus.Addresses.

        Support: Extended
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesPatchArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="gatewayClassName")
    def gateway_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        GatewayClassName used for this Gateway. This is the name of a
        GatewayClass resource.
        """
        return pulumi.get(self, "gateway_class_name")

    @gateway_class_name.setter
    def gateway_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_class_name", value)

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional[pulumi.Input['GatewaySpecInfrastructurePatchArgs']]:
        return pulumi.get(self, "infrastructure")

    @infrastructure.setter
    def infrastructure(self, value: Optional[pulumi.Input['GatewaySpecInfrastructurePatchArgs']]):
        pulumi.set(self, "infrastructure", value)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersPatchArgs']]]]:
        """
        Listeners associated with this Gateway. Listeners define
        logical endpoints that are bound on this Gateway's addresses.
        At least one Listener MUST be specified.

        Each Listener in a set of Listeners (for example, in a single Gateway)
        MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
        exactly one listener. (This section uses "set of Listeners" rather than
        "Listeners in a single Gateway" because implementations MAY merge configuration
        from multiple Gateways onto a single data plane, and these rules _also_
        apply in that case).

        Practically, this means that each listener in a set MUST have a unique
        combination of Port, Protocol, and, if supported by the protocol, Hostname.

        Some combinations of port, protocol, and TLS settings are considered
        Core support and MUST be supported by implementations based on their
        targeted conformance profile:

        HTTP Profile

        1. HTTPRoute, Port: 80, Protocol: HTTP
        2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided

        TLS Profile

        1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough

        "Distinct" Listeners have the following property:

        The implementation can match inbound requests to a single distinct
        Listener. When multiple Listeners share values for fields (for
        example, two Listeners with the same Port value), the implementation
        can match requests to only one of the Listeners using other
        Listener fields.

        For example, the following Listener scenarios are distinct:

        1. Multiple Listeners with the same Port that all use the "HTTP"
           Protocol that all have unique Hostname values.
        2. Multiple Listeners with the same Port that use either the "HTTPS" or
           "TLS" Protocol that all have unique Hostname values.
        3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
           with the same Protocol has the same Port value.

        Some fields in the Listener struct have possible values that affect
        whether the Listener is distinct. Hostname is particularly relevant
        for HTTP or HTTPS protocols.

        When using the Hostname value to select between same-Port, same-Protocol
        Listeners, the Hostname value must be different on each Listener for the
        Listener to be distinct.

        When the Listeners are distinct based on Hostname, inbound request
        hostnames MUST match from the most specific to least specific Hostname
        values to choose the correct Listener and its associated set of Routes.

        Exact matches must be processed before wildcard matches, and wildcard
        matches must be processed before fallback (empty Hostname value)
        matches. For example, `"foo.example.com"` takes precedence over
        `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.

        Additionally, if there are multiple wildcard entries, more specific
        wildcard entries must be processed before less specific wildcard entries.
        For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
        The precise definition here is that the higher the number of dots in the
        hostname to the right of the wildcard character, the higher the precedence.

        The wildcard character will match any number of characters _and dots_ to
        the left, however, so `"*.example.com"` will match both
        `"foo.bar.example.com"` _and_ `"bar.example.com"`.

        If a set of Listeners contains Listeners that are not distinct, then those
        Listeners are Conflicted, and the implementation MUST set the "Conflicted"
        condition in the Listener Status to "True".

        Implementations MAY choose to accept a Gateway with some Conflicted
        Listeners only if they only accept the partial Listener set that contains
        no Conflicted Listeners. To put this another way, implementations may
        accept a partial Listener set only if they throw out *all* the conflicting
        Listeners. No picking one of the conflicting listeners as the winner.
        This also means that the Gateway must have at least one non-conflicting
        Listener in this case, otherwise it violates the requirement that at
        least one Listener must be present.

        The implementation MUST set a "ListenersNotValid" condition on the
        Gateway Status when the Gateway contains Conflicted Listeners whether or
        not they accept the Gateway. That Condition SHOULD clearly
        indicate in the Message which Listeners are conflicted, and which are
        Accepted. Additionally, the Listener status for those listeners SHOULD
        indicate which Listeners are conflicted and not Accepted.

        A Gateway's Listeners are considered "compatible" if:

        1. They are distinct.
        2. The implementation can serve them in compliance with the Addresses
           requirement that all Listeners are available on all assigned
           addresses.

        Compatible combinations in Extended support are expected to vary across
        implementations. A combination that is compatible for one implementation
        may not be compatible for another.

        For example, an implementation that cannot serve both TCP and UDP listeners
        on the same address, or cannot mix HTTPS and generic TLS listens on the same port
        would not consider those cases compatible, even though they are distinct.

        Note that requests SHOULD match at most one Listener. For example, if
        Listeners are defined for "foo.example.com" and "*.example.com", a
        request to "foo.example.com" SHOULD only be routed using routes attached
        to the "foo.example.com" Listener (and not the "*.example.com" Listener).
        This concept is known as "Listener Isolation". Implementations that do
        not support Listener Isolation MUST clearly document this.

        Implementations MAY merge separate Gateways onto a single set of
        Addresses if all Listeners across all Gateways are compatible.

        Support: Core
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersPatchArgs']]]]):
        pulumi.set(self, "listeners", value)


if not MYPY:
    class GatewaySpecArgsDict(TypedDict):
        """
        Spec defines the desired state of Gateway.
        """
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesArgsDict']]]]
        """
        Addresses requested for this Gateway. This is optional and behavior can
        depend on the implementation. If a value is set in the spec and the
        requested address is invalid or unavailable, the implementation MUST
        indicate this in the associated entry in GatewayStatus.Addresses.

        The Addresses field represents a request for the address(es) on the
        "outside of the Gateway", that traffic bound for this Gateway will use.
        This could be the IP address or hostname of an external load balancer or
        other networking infrastructure, or some other address that traffic will
        be sent to.

        If no Addresses are specified, the implementation MAY schedule the
        Gateway in an implementation-specific manner, assigning an appropriate
        set of Addresses.

        The implementation MUST bind all Listeners to every GatewayAddress that
        it assigns to the Gateway and add a corresponding entry in
        GatewayStatus.Addresses.

        Support: Extended
        """
        gateway_class_name: NotRequired[pulumi.Input[str]]
        """
        GatewayClassName used for this Gateway. This is the name of a
        GatewayClass resource.
        """
        infrastructure: NotRequired[pulumi.Input['GatewaySpecInfrastructureArgsDict']]
        listeners: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersArgsDict']]]]
        """
        Listeners associated with this Gateway. Listeners define
        logical endpoints that are bound on this Gateway's addresses.
        At least one Listener MUST be specified.

        Each Listener in a set of Listeners (for example, in a single Gateway)
        MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
        exactly one listener. (This section uses "set of Listeners" rather than
        "Listeners in a single Gateway" because implementations MAY merge configuration
        from multiple Gateways onto a single data plane, and these rules _also_
        apply in that case).

        Practically, this means that each listener in a set MUST have a unique
        combination of Port, Protocol, and, if supported by the protocol, Hostname.

        Some combinations of port, protocol, and TLS settings are considered
        Core support and MUST be supported by implementations based on their
        targeted conformance profile:

        HTTP Profile

        1. HTTPRoute, Port: 80, Protocol: HTTP
        2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided

        TLS Profile

        1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough

        "Distinct" Listeners have the following property:

        The implementation can match inbound requests to a single distinct
        Listener. When multiple Listeners share values for fields (for
        example, two Listeners with the same Port value), the implementation
        can match requests to only one of the Listeners using other
        Listener fields.

        For example, the following Listener scenarios are distinct:

        1. Multiple Listeners with the same Port that all use the "HTTP"
           Protocol that all have unique Hostname values.
        2. Multiple Listeners with the same Port that use either the "HTTPS" or
           "TLS" Protocol that all have unique Hostname values.
        3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
           with the same Protocol has the same Port value.

        Some fields in the Listener struct have possible values that affect
        whether the Listener is distinct. Hostname is particularly relevant
        for HTTP or HTTPS protocols.

        When using the Hostname value to select between same-Port, same-Protocol
        Listeners, the Hostname value must be different on each Listener for the
        Listener to be distinct.

        When the Listeners are distinct based on Hostname, inbound request
        hostnames MUST match from the most specific to least specific Hostname
        values to choose the correct Listener and its associated set of Routes.

        Exact matches must be processed before wildcard matches, and wildcard
        matches must be processed before fallback (empty Hostname value)
        matches. For example, `"foo.example.com"` takes precedence over
        `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.

        Additionally, if there are multiple wildcard entries, more specific
        wildcard entries must be processed before less specific wildcard entries.
        For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
        The precise definition here is that the higher the number of dots in the
        hostname to the right of the wildcard character, the higher the precedence.

        The wildcard character will match any number of characters _and dots_ to
        the left, however, so `"*.example.com"` will match both
        `"foo.bar.example.com"` _and_ `"bar.example.com"`.

        If a set of Listeners contains Listeners that are not distinct, then those
        Listeners are Conflicted, and the implementation MUST set the "Conflicted"
        condition in the Listener Status to "True".

        Implementations MAY choose to accept a Gateway with some Conflicted
        Listeners only if they only accept the partial Listener set that contains
        no Conflicted Listeners. To put this another way, implementations may
        accept a partial Listener set only if they throw out *all* the conflicting
        Listeners. No picking one of the conflicting listeners as the winner.
        This also means that the Gateway must have at least one non-conflicting
        Listener in this case, otherwise it violates the requirement that at
        least one Listener must be present.

        The implementation MUST set a "ListenersNotValid" condition on the
        Gateway Status when the Gateway contains Conflicted Listeners whether or
        not they accept the Gateway. That Condition SHOULD clearly
        indicate in the Message which Listeners are conflicted, and which are
        Accepted. Additionally, the Listener status for those listeners SHOULD
        indicate which Listeners are conflicted and not Accepted.

        A Gateway's Listeners are considered "compatible" if:

        1. They are distinct.
        2. The implementation can serve them in compliance with the Addresses
           requirement that all Listeners are available on all assigned
           addresses.

        Compatible combinations in Extended support are expected to vary across
        implementations. A combination that is compatible for one implementation
        may not be compatible for another.

        For example, an implementation that cannot serve both TCP and UDP listeners
        on the same address, or cannot mix HTTPS and generic TLS listens on the same port
        would not consider those cases compatible, even though they are distinct.

        Note that requests SHOULD match at most one Listener. For example, if
        Listeners are defined for "foo.example.com" and "*.example.com", a
        request to "foo.example.com" SHOULD only be routed using routes attached
        to the "foo.example.com" Listener (and not the "*.example.com" Listener).
        This concept is known as "Listener Isolation". Implementations that do
        not support Listener Isolation MUST clearly document this.

        Implementations MAY merge separate Gateways onto a single set of
        Addresses if all Listeners across all Gateways are compatible.

        Support: Core
        """
elif False:
    GatewaySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaySpecArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesArgs']]]] = None,
                 gateway_class_name: Optional[pulumi.Input[str]] = None,
                 infrastructure: Optional[pulumi.Input['GatewaySpecInfrastructureArgs']] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersArgs']]]] = None):
        """
        Spec defines the desired state of Gateway.
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesArgs']]] addresses: Addresses requested for this Gateway. This is optional and behavior can
               depend on the implementation. If a value is set in the spec and the
               requested address is invalid or unavailable, the implementation MUST
               indicate this in the associated entry in GatewayStatus.Addresses.
               
               The Addresses field represents a request for the address(es) on the
               "outside of the Gateway", that traffic bound for this Gateway will use.
               This could be the IP address or hostname of an external load balancer or
               other networking infrastructure, or some other address that traffic will
               be sent to.
               
               If no Addresses are specified, the implementation MAY schedule the
               Gateway in an implementation-specific manner, assigning an appropriate
               set of Addresses.
               
               The implementation MUST bind all Listeners to every GatewayAddress that
               it assigns to the Gateway and add a corresponding entry in
               GatewayStatus.Addresses.
               
               Support: Extended
        :param pulumi.Input[str] gateway_class_name: GatewayClassName used for this Gateway. This is the name of a
               GatewayClass resource.
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersArgs']]] listeners: Listeners associated with this Gateway. Listeners define
               logical endpoints that are bound on this Gateway's addresses.
               At least one Listener MUST be specified.
               
               Each Listener in a set of Listeners (for example, in a single Gateway)
               MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
               exactly one listener. (This section uses "set of Listeners" rather than
               "Listeners in a single Gateway" because implementations MAY merge configuration
               from multiple Gateways onto a single data plane, and these rules _also_
               apply in that case).
               
               Practically, this means that each listener in a set MUST have a unique
               combination of Port, Protocol, and, if supported by the protocol, Hostname.
               
               Some combinations of port, protocol, and TLS settings are considered
               Core support and MUST be supported by implementations based on their
               targeted conformance profile:
               
               HTTP Profile
               
               1. HTTPRoute, Port: 80, Protocol: HTTP
               2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
               
               TLS Profile
               
               1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
               
               "Distinct" Listeners have the following property:
               
               The implementation can match inbound requests to a single distinct
               Listener. When multiple Listeners share values for fields (for
               example, two Listeners with the same Port value), the implementation
               can match requests to only one of the Listeners using other
               Listener fields.
               
               For example, the following Listener scenarios are distinct:
               
               1. Multiple Listeners with the same Port that all use the "HTTP"
                  Protocol that all have unique Hostname values.
               2. Multiple Listeners with the same Port that use either the "HTTPS" or
                  "TLS" Protocol that all have unique Hostname values.
               3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
                  with the same Protocol has the same Port value.
               
               Some fields in the Listener struct have possible values that affect
               whether the Listener is distinct. Hostname is particularly relevant
               for HTTP or HTTPS protocols.
               
               When using the Hostname value to select between same-Port, same-Protocol
               Listeners, the Hostname value must be different on each Listener for the
               Listener to be distinct.
               
               When the Listeners are distinct based on Hostname, inbound request
               hostnames MUST match from the most specific to least specific Hostname
               values to choose the correct Listener and its associated set of Routes.
               
               Exact matches must be processed before wildcard matches, and wildcard
               matches must be processed before fallback (empty Hostname value)
               matches. For example, `"foo.example.com"` takes precedence over
               `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
               
               Additionally, if there are multiple wildcard entries, more specific
               wildcard entries must be processed before less specific wildcard entries.
               For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
               The precise definition here is that the higher the number of dots in the
               hostname to the right of the wildcard character, the higher the precedence.
               
               The wildcard character will match any number of characters _and dots_ to
               the left, however, so `"*.example.com"` will match both
               `"foo.bar.example.com"` _and_ `"bar.example.com"`.
               
               If a set of Listeners contains Listeners that are not distinct, then those
               Listeners are Conflicted, and the implementation MUST set the "Conflicted"
               condition in the Listener Status to "True".
               
               Implementations MAY choose to accept a Gateway with some Conflicted
               Listeners only if they only accept the partial Listener set that contains
               no Conflicted Listeners. To put this another way, implementations may
               accept a partial Listener set only if they throw out *all* the conflicting
               Listeners. No picking one of the conflicting listeners as the winner.
               This also means that the Gateway must have at least one non-conflicting
               Listener in this case, otherwise it violates the requirement that at
               least one Listener must be present.
               
               The implementation MUST set a "ListenersNotValid" condition on the
               Gateway Status when the Gateway contains Conflicted Listeners whether or
               not they accept the Gateway. That Condition SHOULD clearly
               indicate in the Message which Listeners are conflicted, and which are
               Accepted. Additionally, the Listener status for those listeners SHOULD
               indicate which Listeners are conflicted and not Accepted.
               
               A Gateway's Listeners are considered "compatible" if:
               
               1. They are distinct.
               2. The implementation can serve them in compliance with the Addresses
                  requirement that all Listeners are available on all assigned
                  addresses.
               
               Compatible combinations in Extended support are expected to vary across
               implementations. A combination that is compatible for one implementation
               may not be compatible for another.
               
               For example, an implementation that cannot serve both TCP and UDP listeners
               on the same address, or cannot mix HTTPS and generic TLS listens on the same port
               would not consider those cases compatible, even though they are distinct.
               
               Note that requests SHOULD match at most one Listener. For example, if
               Listeners are defined for "foo.example.com" and "*.example.com", a
               request to "foo.example.com" SHOULD only be routed using routes attached
               to the "foo.example.com" Listener (and not the "*.example.com" Listener).
               This concept is known as "Listener Isolation". Implementations that do
               not support Listener Isolation MUST clearly document this.
               
               Implementations MAY merge separate Gateways onto a single set of
               Addresses if all Listeners across all Gateways are compatible.
               
               Support: Core
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if gateway_class_name is not None:
            pulumi.set(__self__, "gateway_class_name", gateway_class_name)
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesArgs']]]]:
        """
        Addresses requested for this Gateway. This is optional and behavior can
        depend on the implementation. If a value is set in the spec and the
        requested address is invalid or unavailable, the implementation MUST
        indicate this in the associated entry in GatewayStatus.Addresses.

        The Addresses field represents a request for the address(es) on the
        "outside of the Gateway", that traffic bound for this Gateway will use.
        This could be the IP address or hostname of an external load balancer or
        other networking infrastructure, or some other address that traffic will
        be sent to.

        If no Addresses are specified, the implementation MAY schedule the
        Gateway in an implementation-specific manner, assigning an appropriate
        set of Addresses.

        The implementation MUST bind all Listeners to every GatewayAddress that
        it assigns to the Gateway and add a corresponding entry in
        GatewayStatus.Addresses.

        Support: Extended
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecAddressesArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="gatewayClassName")
    def gateway_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        GatewayClassName used for this Gateway. This is the name of a
        GatewayClass resource.
        """
        return pulumi.get(self, "gateway_class_name")

    @gateway_class_name.setter
    def gateway_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_class_name", value)

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional[pulumi.Input['GatewaySpecInfrastructureArgs']]:
        return pulumi.get(self, "infrastructure")

    @infrastructure.setter
    def infrastructure(self, value: Optional[pulumi.Input['GatewaySpecInfrastructureArgs']]):
        pulumi.set(self, "infrastructure", value)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersArgs']]]]:
        """
        Listeners associated with this Gateway. Listeners define
        logical endpoints that are bound on this Gateway's addresses.
        At least one Listener MUST be specified.

        Each Listener in a set of Listeners (for example, in a single Gateway)
        MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
        exactly one listener. (This section uses "set of Listeners" rather than
        "Listeners in a single Gateway" because implementations MAY merge configuration
        from multiple Gateways onto a single data plane, and these rules _also_
        apply in that case).

        Practically, this means that each listener in a set MUST have a unique
        combination of Port, Protocol, and, if supported by the protocol, Hostname.

        Some combinations of port, protocol, and TLS settings are considered
        Core support and MUST be supported by implementations based on their
        targeted conformance profile:

        HTTP Profile

        1. HTTPRoute, Port: 80, Protocol: HTTP
        2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided

        TLS Profile

        1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough

        "Distinct" Listeners have the following property:

        The implementation can match inbound requests to a single distinct
        Listener. When multiple Listeners share values for fields (for
        example, two Listeners with the same Port value), the implementation
        can match requests to only one of the Listeners using other
        Listener fields.

        For example, the following Listener scenarios are distinct:

        1. Multiple Listeners with the same Port that all use the "HTTP"
           Protocol that all have unique Hostname values.
        2. Multiple Listeners with the same Port that use either the "HTTPS" or
           "TLS" Protocol that all have unique Hostname values.
        3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
           with the same Protocol has the same Port value.

        Some fields in the Listener struct have possible values that affect
        whether the Listener is distinct. Hostname is particularly relevant
        for HTTP or HTTPS protocols.

        When using the Hostname value to select between same-Port, same-Protocol
        Listeners, the Hostname value must be different on each Listener for the
        Listener to be distinct.

        When the Listeners are distinct based on Hostname, inbound request
        hostnames MUST match from the most specific to least specific Hostname
        values to choose the correct Listener and its associated set of Routes.

        Exact matches must be processed before wildcard matches, and wildcard
        matches must be processed before fallback (empty Hostname value)
        matches. For example, `"foo.example.com"` takes precedence over
        `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.

        Additionally, if there are multiple wildcard entries, more specific
        wildcard entries must be processed before less specific wildcard entries.
        For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
        The precise definition here is that the higher the number of dots in the
        hostname to the right of the wildcard character, the higher the precedence.

        The wildcard character will match any number of characters _and dots_ to
        the left, however, so `"*.example.com"` will match both
        `"foo.bar.example.com"` _and_ `"bar.example.com"`.

        If a set of Listeners contains Listeners that are not distinct, then those
        Listeners are Conflicted, and the implementation MUST set the "Conflicted"
        condition in the Listener Status to "True".

        Implementations MAY choose to accept a Gateway with some Conflicted
        Listeners only if they only accept the partial Listener set that contains
        no Conflicted Listeners. To put this another way, implementations may
        accept a partial Listener set only if they throw out *all* the conflicting
        Listeners. No picking one of the conflicting listeners as the winner.
        This also means that the Gateway must have at least one non-conflicting
        Listener in this case, otherwise it violates the requirement that at
        least one Listener must be present.

        The implementation MUST set a "ListenersNotValid" condition on the
        Gateway Status when the Gateway contains Conflicted Listeners whether or
        not they accept the Gateway. That Condition SHOULD clearly
        indicate in the Message which Listeners are conflicted, and which are
        Accepted. Additionally, the Listener status for those listeners SHOULD
        indicate which Listeners are conflicted and not Accepted.

        A Gateway's Listeners are considered "compatible" if:

        1. They are distinct.
        2. The implementation can serve them in compliance with the Addresses
           requirement that all Listeners are available on all assigned
           addresses.

        Compatible combinations in Extended support are expected to vary across
        implementations. A combination that is compatible for one implementation
        may not be compatible for another.

        For example, an implementation that cannot serve both TCP and UDP listeners
        on the same address, or cannot mix HTTPS and generic TLS listens on the same port
        would not consider those cases compatible, even though they are distinct.

        Note that requests SHOULD match at most one Listener. For example, if
        Listeners are defined for "foo.example.com" and "*.example.com", a
        request to "foo.example.com" SHOULD only be routed using routes attached
        to the "foo.example.com" Listener (and not the "*.example.com" Listener).
        This concept is known as "Listener Isolation". Implementations that do
        not support Listener Isolation MUST clearly document this.

        Implementations MAY merge separate Gateways onto a single set of
        Addresses if all Listeners across all Gateways are compatible.

        Support: Core
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecListenersArgs']]]]):
        pulumi.set(self, "listeners", value)


if not MYPY:
    class GatewayStatusAddressesArgsDict(TypedDict):
        """
        GatewayStatusAddress describes a network address that is bound to a Gateway.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the address.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
elif False:
    GatewayStatusAddressesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayStatusAddressesArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        GatewayStatusAddress describes a network address that is bound to a Gateway.
        :param pulumi.Input[str] type: Type of the address.
        :param pulumi.Input[str] value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewayStatusConditionsArgsDict(TypedDict):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        """
        last_transition_time: NotRequired[pulumi.Input[str]]
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        observed_generation: NotRequired[pulumi.Input[int]]
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of the condition, one of True, False, Unknown.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
elif False:
    GatewayStatusConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param pulumi.Input[str] last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param pulumi.Input[int] observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param pulumi.Input[str] reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param pulumi.Input[str] status: status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayStatusListenersConditionsArgsDict(TypedDict):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        """
        last_transition_time: NotRequired[pulumi.Input[str]]
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        observed_generation: NotRequired[pulumi.Input[int]]
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of the condition, one of True, False, Unknown.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
elif False:
    GatewayStatusListenersConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayStatusListenersConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param pulumi.Input[str] last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param pulumi.Input[int] observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param pulumi.Input[str] reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param pulumi.Input[str] status: status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayStatusListenersSupportedKindsArgsDict(TypedDict):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the Route.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the kind of the Route.
        """
elif False:
    GatewayStatusListenersSupportedKindsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayStatusListenersSupportedKindsArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param pulumi.Input[str] group: Group is the group of the Route.
        :param pulumi.Input[str] kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GatewayStatusListenersArgsDict(TypedDict):
        """
        ListenerStatus is the status associated with a Listener.
        """
        attached_routes: NotRequired[pulumi.Input[int]]
        """
        AttachedRoutes represents the total number of Routes that have been
        successfully attached to this Listener.

        Successful attachment of a Route to a Listener is based solely on the
        combination of the AllowedRoutes field on the corresponding Listener
        and the Route's ParentRefs field. A Route is successfully attached to
        a Listener when it is selected by the Listener's AllowedRoutes field
        AND the Route has a valid ParentRef selecting the whole Gateway
        resource or a specific Listener as a parent resource (more detail on
        attachment semantics can be found in the documentation on the various
        Route kinds ParentRefs fields). Listener or Route status does not impact
        successful attachment, i.e. the AttachedRoutes field count MUST be set
        for Listeners with condition Accepted: false and MUST count successfully
        attached Routes that may themselves have Accepted: false conditions.

        Uses for this field include troubleshooting Route attachment and
        measuring blast radius/impact of changes to a Listener.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersConditionsArgsDict']]]]
        """
        Conditions describe the current condition of this listener.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the Listener that this status corresponds to.
        """
        supported_kinds: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersSupportedKindsArgsDict']]]]
        """
        SupportedKinds is the list indicating the Kinds supported by this
        listener. This MUST represent the kinds an implementation supports for
        that Listener configuration.

        If kinds are specified in Spec that are not supported, they MUST NOT
        appear in this list and an implementation MUST set the "ResolvedRefs"
        condition to "False" with the "InvalidRouteKinds" reason. If both valid
        and invalid Route kinds are specified, the implementation MUST
        reference the valid Route kinds that have been specified.
        """
elif False:
    GatewayStatusListenersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayStatusListenersArgs:
    def __init__(__self__, *,
                 attached_routes: Optional[pulumi.Input[int]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersConditionsArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 supported_kinds: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersSupportedKindsArgs']]]] = None):
        """
        ListenerStatus is the status associated with a Listener.
        :param pulumi.Input[int] attached_routes: AttachedRoutes represents the total number of Routes that have been
               successfully attached to this Listener.
               
               Successful attachment of a Route to a Listener is based solely on the
               combination of the AllowedRoutes field on the corresponding Listener
               and the Route's ParentRefs field. A Route is successfully attached to
               a Listener when it is selected by the Listener's AllowedRoutes field
               AND the Route has a valid ParentRef selecting the whole Gateway
               resource or a specific Listener as a parent resource (more detail on
               attachment semantics can be found in the documentation on the various
               Route kinds ParentRefs fields). Listener or Route status does not impact
               successful attachment, i.e. the AttachedRoutes field count MUST be set
               for Listeners with condition Accepted: false and MUST count successfully
               attached Routes that may themselves have Accepted: false conditions.
               
               Uses for this field include troubleshooting Route attachment and
               measuring blast radius/impact of changes to a Listener.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersConditionsArgs']]] conditions: Conditions describe the current condition of this listener.
        :param pulumi.Input[str] name: Name is the name of the Listener that this status corresponds to.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersSupportedKindsArgs']]] supported_kinds: SupportedKinds is the list indicating the Kinds supported by this
               listener. This MUST represent the kinds an implementation supports for
               that Listener configuration.
               
               If kinds are specified in Spec that are not supported, they MUST NOT
               appear in this list and an implementation MUST set the "ResolvedRefs"
               condition to "False" with the "InvalidRouteKinds" reason. If both valid
               and invalid Route kinds are specified, the implementation MUST
               reference the valid Route kinds that have been specified.
        """
        if attached_routes is not None:
            pulumi.set(__self__, "attached_routes", attached_routes)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if supported_kinds is not None:
            pulumi.set(__self__, "supported_kinds", supported_kinds)

    @property
    @pulumi.getter(name="attachedRoutes")
    def attached_routes(self) -> Optional[pulumi.Input[int]]:
        """
        AttachedRoutes represents the total number of Routes that have been
        successfully attached to this Listener.

        Successful attachment of a Route to a Listener is based solely on the
        combination of the AllowedRoutes field on the corresponding Listener
        and the Route's ParentRefs field. A Route is successfully attached to
        a Listener when it is selected by the Listener's AllowedRoutes field
        AND the Route has a valid ParentRef selecting the whole Gateway
        resource or a specific Listener as a parent resource (more detail on
        attachment semantics can be found in the documentation on the various
        Route kinds ParentRefs fields). Listener or Route status does not impact
        successful attachment, i.e. the AttachedRoutes field count MUST be set
        for Listeners with condition Accepted: false and MUST count successfully
        attached Routes that may themselves have Accepted: false conditions.

        Uses for this field include troubleshooting Route attachment and
        measuring blast radius/impact of changes to a Listener.
        """
        return pulumi.get(self, "attached_routes")

    @attached_routes.setter
    def attached_routes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "attached_routes", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersConditionsArgs']]]]:
        """
        Conditions describe the current condition of this listener.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the Listener that this status corresponds to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="supportedKinds")
    def supported_kinds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersSupportedKindsArgs']]]]:
        """
        SupportedKinds is the list indicating the Kinds supported by this
        listener. This MUST represent the kinds an implementation supports for
        that Listener configuration.

        If kinds are specified in Spec that are not supported, they MUST NOT
        appear in this list and an implementation MUST set the "ResolvedRefs"
        condition to "False" with the "InvalidRouteKinds" reason. If both valid
        and invalid Route kinds are specified, the implementation MUST
        reference the valid Route kinds that have been specified.
        """
        return pulumi.get(self, "supported_kinds")

    @supported_kinds.setter
    def supported_kinds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersSupportedKindsArgs']]]]):
        pulumi.set(self, "supported_kinds", value)


if not MYPY:
    class GatewayStatusArgsDict(TypedDict):
        """
        Status defines the current state of Gateway.
        """
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayStatusAddressesArgsDict']]]]
        """
        Addresses lists the network addresses that have been bound to the
        Gateway.

        This list may differ from the addresses provided in the spec under some
        conditions:

          * no addresses are specified, all addresses are dynamically assigned
          * a combination of specified and dynamic addresses are assigned
          * a specified address was unusable (e.g. already in use)
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayStatusConditionsArgsDict']]]]
        """
        Conditions describe the current conditions of the Gateway.

        Implementations should prefer to express Gateway conditions
        using the `GatewayConditionType` and `GatewayConditionReason`
        constants so that operators and tools can converge on a common
        vocabulary to describe Gateway state.

        Known condition types are:

        * "Accepted"
        * "Programmed"
        * "Ready"
        """
        listeners: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersArgsDict']]]]
        """
        Listeners provide status for each unique listener port defined in the Spec.
        """
elif False:
    GatewayStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayStatusArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusAddressesArgs']]]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusConditionsArgs']]]] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersArgs']]]] = None):
        """
        Status defines the current state of Gateway.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayStatusAddressesArgs']]] addresses: Addresses lists the network addresses that have been bound to the
               Gateway.
               
               This list may differ from the addresses provided in the spec under some
               conditions:
               
                 * no addresses are specified, all addresses are dynamically assigned
                 * a combination of specified and dynamic addresses are assigned
                 * a specified address was unusable (e.g. already in use)
        :param pulumi.Input[Sequence[pulumi.Input['GatewayStatusConditionsArgs']]] conditions: Conditions describe the current conditions of the Gateway.
               
               Implementations should prefer to express Gateway conditions
               using the `GatewayConditionType` and `GatewayConditionReason`
               constants so that operators and tools can converge on a common
               vocabulary to describe Gateway state.
               
               Known condition types are:
               
               * "Accepted"
               * "Programmed"
               * "Ready"
        :param pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersArgs']]] listeners: Listeners provide status for each unique listener port defined in the Spec.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusAddressesArgs']]]]:
        """
        Addresses lists the network addresses that have been bound to the
        Gateway.

        This list may differ from the addresses provided in the spec under some
        conditions:

          * no addresses are specified, all addresses are dynamically assigned
          * a combination of specified and dynamic addresses are assigned
          * a specified address was unusable (e.g. already in use)
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusAddressesArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusConditionsArgs']]]]:
        """
        Conditions describe the current conditions of the Gateway.

        Implementations should prefer to express Gateway conditions
        using the `GatewayConditionType` and `GatewayConditionReason`
        constants so that operators and tools can converge on a common
        vocabulary to describe Gateway state.

        Known condition types are:

        * "Accepted"
        * "Programmed"
        * "Ready"
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersArgs']]]]:
        """
        Listeners provide status for each unique listener port defined in the Spec.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayStatusListenersArgs']]]]):
        pulumi.set(self, "listeners", value)


if not MYPY:
    class GatewayArgsDict(TypedDict):
        """
        Gateway represents an instance of a service-traffic handling infrastructure
        by binding Listeners to a set of IP addresses.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['GatewaySpecArgsDict']]
        status: NotRequired[pulumi.Input['GatewayStatusArgsDict']]
elif False:
    GatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['GatewaySpecArgs']] = None,
                 status: Optional[pulumi.Input['GatewayStatusArgs']] = None):
        """
        Gateway represents an instance of a service-traffic handling infrastructure
        by binding Listeners to a set of IP addresses.
        :param pulumi.Input[str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'Gateway')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['GatewaySpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['GatewaySpecArgs']]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['GatewayStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['GatewayStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class HTTPRouteSpecParentRefsPatchArgsDict(TypedDict):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.

        Support: Core
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        section_name: NotRequired[pulumi.Input[str]]
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
elif False:
    HTTPRouteSpecParentRefsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecParentRefsPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 section_name: Optional[pulumi.Input[str]] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param pulumi.Input[str] group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param pulumi.Input[str] kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param pulumi.Input[str] name: Name is the name of the referent.
               
               Support: Core
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param pulumi.Input[str] section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[pulumi.Input[str]]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")

    @section_name.setter
    def section_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_name", value)


if not MYPY:
    class HTTPRouteSpecParentRefsArgsDict(TypedDict):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.

        Support: Core
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        section_name: NotRequired[pulumi.Input[str]]
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
elif False:
    HTTPRouteSpecParentRefsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecParentRefsArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 section_name: Optional[pulumi.Input[str]] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param pulumi.Input[str] group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param pulumi.Input[str] kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param pulumi.Input[str] name: Name is the name of the referent.
               
               Support: Core
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param pulumi.Input[str] section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[pulumi.Input[str]]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")

    @section_name.setter
    def section_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_name", value)


if not MYPY:
    class HTTPRouteSpecPatchArgsDict(TypedDict):
        """
        Spec defines the desired state of HTTPRoute.
        """
        hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Hostnames defines a set of hostnames that should match against the HTTP Host
        header to select a HTTPRoute used to process the request. Implementations
        MUST ignore any port value specified in the HTTP Host header while
        performing a match and (absent of any applicable header modification
        configuration) MUST forward this header unmodified to the backend.

        Valid values for Hostnames are determined by RFC 1123 definition of a
        hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label must appear by itself as the first label.

        If a hostname is specified by both the Listener and HTTPRoute, there
        must be at least one intersecting hostname for the HTTPRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `*.example.com`, `test.example.com`, and `foo.test.example.com` would
          all match. On the other hand, `example.com` and `test.example.net` would
          not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and HTTPRoute have specified hostnames, any
        HTTPRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        HTTPRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` must not be considered for a match.

        If both the Listener and HTTPRoute have specified hostnames, and none
        match with the criteria above, then the HTTPRoute is not accepted. The
        implementation must raise an 'Accepted' Condition with a status of
        `False` in the corresponding RouteParentStatus.

        In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
        overlapping wildcard matching and exact matching hostnames), precedence must
        be given to rules from the HTTPRoute with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.

        If ties exist across multiple Routes, the matching precedence rules for
        HTTPRouteMatches takes over.

        Support: Core
        """
        parent_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsPatchArgsDict']]]]
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesPatchArgsDict']]]]
        """
        Rules are a list of HTTP matchers, filters and actions.
        """
elif False:
    HTTPRouteSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecPatchArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parent_refs: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsPatchArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesPatchArgs']]]] = None):
        """
        Spec defines the desired state of HTTPRoute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: Hostnames defines a set of hostnames that should match against the HTTP Host
               header to select a HTTPRoute used to process the request. Implementations
               MUST ignore any port value specified in the HTTP Host header while
               performing a match and (absent of any applicable header modification
               configuration) MUST forward this header unmodified to the backend.
               
               Valid values for Hostnames are determined by RFC 1123 definition of a
               hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label must appear by itself as the first label.
               
               If a hostname is specified by both the Listener and HTTPRoute, there
               must be at least one intersecting hostname for the HTTPRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `*.example.com`, `test.example.com`, and `foo.test.example.com` would
                 all match. On the other hand, `example.com` and `test.example.net` would
                 not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and HTTPRoute have specified hostnames, any
               HTTPRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               HTTPRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` must not be considered for a match.
               
               If both the Listener and HTTPRoute have specified hostnames, and none
               match with the criteria above, then the HTTPRoute is not accepted. The
               implementation must raise an 'Accepted' Condition with a status of
               `False` in the corresponding RouteParentStatus.
               
               In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
               overlapping wildcard matching and exact matching hostnames), precedence must
               be given to rules from the HTTPRoute with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               
               If ties exist across multiple Routes, the matching precedence rules for
               HTTPRouteMatches takes over.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsPatchArgs']]] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesPatchArgs']]] rules: Rules are a list of HTTP matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Hostnames defines a set of hostnames that should match against the HTTP Host
        header to select a HTTPRoute used to process the request. Implementations
        MUST ignore any port value specified in the HTTP Host header while
        performing a match and (absent of any applicable header modification
        configuration) MUST forward this header unmodified to the backend.

        Valid values for Hostnames are determined by RFC 1123 definition of a
        hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label must appear by itself as the first label.

        If a hostname is specified by both the Listener and HTTPRoute, there
        must be at least one intersecting hostname for the HTTPRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `*.example.com`, `test.example.com`, and `foo.test.example.com` would
          all match. On the other hand, `example.com` and `test.example.net` would
          not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and HTTPRoute have specified hostnames, any
        HTTPRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        HTTPRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` must not be considered for a match.

        If both the Listener and HTTPRoute have specified hostnames, and none
        match with the criteria above, then the HTTPRoute is not accepted. The
        implementation must raise an 'Accepted' Condition with a status of
        `False` in the corresponding RouteParentStatus.

        In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
        overlapping wildcard matching and exact matching hostnames), precedence must
        be given to rules from the HTTPRoute with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.

        If ties exist across multiple Routes, the matching precedence rules for
        HTTPRouteMatches takes over.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsPatchArgs']]]]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @parent_refs.setter
    def parent_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsPatchArgs']]]]):
        pulumi.set(self, "parent_refs", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesPatchArgs']]]]:
        """
        Rules are a list of HTTP matchers, filters and actions.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesPatchArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersPatchArgsDict(TypedDict):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict']]
        request_mirror: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict']]
        request_redirect: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        url_rewrite: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgsDict']]
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersPatchArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs']] = None,
                 request_mirror: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs']] = None,
                 request_redirect: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url_rewrite: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs']] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatchArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs']]:
        return pulumi.get(self, "request_redirect")

    @request_redirect.setter
    def request_redirect(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs']]):
        pulumi.set(self, "request_redirect", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs']]:
        return pulumi.get(self, "url_rewrite")

    @url_rewrite.setter
    def url_rewrite(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs']]):
        pulumi.set(self, "url_rewrite", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgsDict']]
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatchArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatchArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsDict']]
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgsDict(TypedDict):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgsDict']]
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatchArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param pulumi.Input[str] hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param pulumi.Input[int] port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param pulumi.Input[str] scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param pulumi.Input[int] status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgsDict(TypedDict):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatchArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgsDict(TypedDict):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgsDict(TypedDict):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgsDict']]
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param pulumi.Input[str] hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param pulumi.Input[int] port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param pulumi.Input[str] scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param pulumi.Input[int] status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgsDict(TypedDict):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgsDict']]
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatchArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs']] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param pulumi.Input[str] hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgsDict(TypedDict):
        """
        Path defines a path rewrite.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatchArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgsDict(TypedDict):
        """
        Path defines a path rewrite.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgsDict(TypedDict):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgsDict']]
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs']] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param pulumi.Input[str] hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsFiltersArgsDict(TypedDict):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgsDict']]
        request_mirror: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgsDict']]
        request_redirect: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        url_rewrite: NotRequired[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgsDict']]
elif False:
    HTTPRouteSpecRulesBackendRefsFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsFiltersArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs']] = None,
                 request_mirror: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs']] = None,
                 request_redirect: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url_rewrite: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs']] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs']]:
        return pulumi.get(self, "request_redirect")

    @request_redirect.setter
    def request_redirect(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs']]):
        pulumi.set(self, "request_redirect", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs']]:
        return pulumi.get(self, "url_rewrite")

    @url_rewrite.setter
    def url_rewrite(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs']]):
        pulumi.set(self, "url_rewrite", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsPatchArgsDict(TypedDict):
        """
        HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersPatchArgsDict']]]]
        """
        Filters defined at this level should be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in HTTPRouteRule.)
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsPatchArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersPatchArgs']]]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersPatchArgs']]] filters: Filters defined at this level should be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in HTTPRouteRule.)
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param pulumi.Input[int] weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersPatchArgs']]]]:
        """
        Filters defined at this level should be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in HTTPRouteRule.)
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersPatchArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class HTTPRouteSpecRulesBackendRefsArgsDict(TypedDict):
        """
        HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersArgsDict']]]]
        """
        Filters defined at this level should be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in HTTPRouteRule.)
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
elif False:
    HTTPRouteSpecRulesBackendRefsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesBackendRefsArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersArgs']]]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersArgs']]] filters: Filters defined at this level should be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in HTTPRouteRule.)
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param pulumi.Input[int] weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersArgs']]]]:
        """
        Filters defined at this level should be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in HTTPRouteRule.)
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsFiltersArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersExtensionRefPatchArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    HTTPRouteSpecRulesFiltersExtensionRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersExtensionRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersExtensionRefArgsDict(TypedDict):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
elif False:
    HTTPRouteSpecRulesFiltersExtensionRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersExtensionRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param pulumi.Input[str] name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersPatchArgsDict(TypedDict):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefPatchArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict']]
        request_mirror: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorPatchArgsDict']]
        request_redirect: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPatchArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        url_rewrite: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePatchArgsDict']]
elif False:
    HTTPRouteSpecRulesFiltersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersPatchArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefPatchArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs']] = None,
                 request_mirror: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs']] = None,
                 request_redirect: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url_rewrite: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePatchArgs']] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefPatchArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefPatchArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs']]:
        return pulumi.get(self, "request_redirect")

    @request_redirect.setter
    def request_redirect(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs']]):
        pulumi.set(self, "request_redirect", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePatchArgs']]:
        return pulumi.get(self, "url_rewrite")

    @url_rewrite.setter
    def url_rewrite(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePatchArgs']]):
        pulumi.set(self, "url_rewrite", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestHeaderModifierArgsDict(TypedDict):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]]] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict(TypedDict):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param pulumi.Input[str] group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param pulumi.Input[str] kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param pulumi.Input[str] name: Name is the name of the referent.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param pulumi.Input[int] port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestMirrorPatchArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgsDict']]
elif False:
    HTTPRouteSpecRulesFiltersRequestMirrorPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestMirrorPatchArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatchArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestMirrorArgsDict(TypedDict):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        backend_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgsDict']]
elif False:
    HTTPRouteSpecRulesFiltersRequestMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestMirrorArgs:
    def __init__(__self__, *,
                 backend_ref: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs']] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs']]:
        return pulumi.get(self, "backend_ref")

    @backend_ref.setter
    def backend_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs']]):
        pulumi.set(self, "backend_ref", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestRedirectPatchArgsDict(TypedDict):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgsDict']]
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestRedirectPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestRedirectPatchArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param pulumi.Input[str] hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param pulumi.Input[int] port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param pulumi.Input[str] scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param pulumi.Input[int] status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgsDict(TypedDict):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestRedirectPathPatchArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestRedirectPathArgsDict(TypedDict):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestRedirectPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestRedirectPathArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersRequestRedirectArgsDict(TypedDict):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathArgsDict']]
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
elif False:
    HTTPRouteSpecRulesFiltersRequestRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersRequestRedirectArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param pulumi.Input[str] hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param pulumi.Input[int] port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param pulumi.Input[str] scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param pulumi.Input[int] status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierPatchArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict(TypedDict):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersResponseHeaderModifierArgsDict(TypedDict):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        """
        add: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgsDict']]]]
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        set: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgsDict']]]]
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
elif False:
    HTTPRouteSpecRulesFiltersResponseHeaderModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]]] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]]]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs']]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]]]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs']]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersUrlRewritePatchArgsDict(TypedDict):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgsDict']]
elif False:
    HTTPRouteSpecRulesFiltersUrlRewritePatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersUrlRewritePatchArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs']] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param pulumi.Input[str] hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgsDict(TypedDict):
        """
        Path defines a path rewrite.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersUrlRewritePathPatchArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersUrlRewritePathArgsDict(TypedDict):
        """
        Path defines a path rewrite.

        Support: Extended
        """
        replace_full_path: NotRequired[pulumi.Input[str]]
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        replace_prefix_match: NotRequired[pulumi.Input[str]]
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
elif False:
    HTTPRouteSpecRulesFiltersUrlRewritePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersUrlRewritePathArgs:
    def __init__(__self__, *,
                 replace_full_path: Optional[pulumi.Input[str]] = None,
                 replace_prefix_match: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param pulumi.Input[str] replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param pulumi.Input[str] replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param pulumi.Input[str] type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[pulumi.Input[str]]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @replace_full_path.setter
    def replace_full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_full_path", value)

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[pulumi.Input[str]]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @replace_prefix_match.setter
    def replace_prefix_match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_prefix_match", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersUrlRewriteArgsDict(TypedDict):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathArgsDict']]
elif False:
    HTTPRouteSpecRulesFiltersUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersUrlRewriteArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathArgs']] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param pulumi.Input[str] hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewritePathArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class HTTPRouteSpecRulesFiltersArgsDict(TypedDict):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        """
        extension_ref: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefArgsDict']]
        request_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierArgsDict']]
        request_mirror: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorArgsDict']]
        request_redirect: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectArgsDict']]
        response_header_modifier: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierArgsDict']]
        type: NotRequired[pulumi.Input[str]]
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        url_rewrite: NotRequired[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewriteArgsDict']]
elif False:
    HTTPRouteSpecRulesFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesFiltersArgs:
    def __init__(__self__, *,
                 extension_ref: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefArgs']] = None,
                 request_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs']] = None,
                 request_mirror: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorArgs']] = None,
                 request_redirect: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectArgs']] = None,
                 response_header_modifier: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url_rewrite: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewriteArgs']] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param pulumi.Input[str] type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefArgs']]:
        return pulumi.get(self, "extension_ref")

    @extension_ref.setter
    def extension_ref(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersExtensionRefArgs']]):
        pulumi.set(self, "extension_ref", value)

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs']]:
        return pulumi.get(self, "request_header_modifier")

    @request_header_modifier.setter
    def request_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs']]):
        pulumi.set(self, "request_header_modifier", value)

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorArgs']]:
        return pulumi.get(self, "request_mirror")

    @request_mirror.setter
    def request_mirror(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestMirrorArgs']]):
        pulumi.set(self, "request_mirror", value)

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectArgs']]:
        return pulumi.get(self, "request_redirect")

    @request_redirect.setter
    def request_redirect(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersRequestRedirectArgs']]):
        pulumi.set(self, "request_redirect", value)

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs']]:
        return pulumi.get(self, "response_header_modifier")

    @response_header_modifier.setter
    def response_header_modifier(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs']]):
        pulumi.set(self, "response_header_modifier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewriteArgs']]:
        return pulumi.get(self, "url_rewrite")

    @url_rewrite.setter
    def url_rewrite(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesFiltersUrlRewriteArgs']]):
        pulumi.set(self, "url_rewrite", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesHeadersPatchArgsDict(TypedDict):
        """
        HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
        headers.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.

        When a header is repeated in an HTTP request, it is
        implementation-specific behavior as to how this is represented.
        Generally, proxies should follow the guidance from the RFC:
        https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
        processing a repeated header, with special handling for "Set-Cookie".
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the value of the header.

        Support: Core (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression HeaderMatchType has implementation-specific
        conformance, implementations can support POSIX, PCRE or any other dialects
        of regular expressions. Please read the implementation's documentation to
        determine the supported dialect.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesMatchesHeadersPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesHeadersPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
        headers.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
               
               When a header is repeated in an HTTP request, it is
               implementation-specific behavior as to how this is represented.
               Generally, proxies should follow the guidance from the RFC:
               https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
               processing a repeated header, with special handling for "Set-Cookie".
        :param pulumi.Input[str] type: Type specifies how to match against the value of the header.
               
               Support: Core (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression HeaderMatchType has implementation-specific
               conformance, implementations can support POSIX, PCRE or any other dialects
               of regular expressions. Please read the implementation's documentation to
               determine the supported dialect.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.

        When a header is repeated in an HTTP request, it is
        implementation-specific behavior as to how this is represented.
        Generally, proxies should follow the guidance from the RFC:
        https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
        processing a repeated header, with special handling for "Set-Cookie".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the value of the header.

        Support: Core (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression HeaderMatchType has implementation-specific
        conformance, implementations can support POSIX, PCRE or any other dialects
        of regular expressions. Please read the implementation's documentation to
        determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesHeadersArgsDict(TypedDict):
        """
        HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
        headers.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.

        When a header is repeated in an HTTP request, it is
        implementation-specific behavior as to how this is represented.
        Generally, proxies should follow the guidance from the RFC:
        https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
        processing a repeated header, with special handling for "Set-Cookie".
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the value of the header.

        Support: Core (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression HeaderMatchType has implementation-specific
        conformance, implementations can support POSIX, PCRE or any other dialects
        of regular expressions. Please read the implementation's documentation to
        determine the supported dialect.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP Header to be matched.
        """
elif False:
    HTTPRouteSpecRulesMatchesHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesHeadersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
        headers.
        :param pulumi.Input[str] name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
               
               When a header is repeated in an HTTP request, it is
               implementation-specific behavior as to how this is represented.
               Generally, proxies should follow the guidance from the RFC:
               https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
               processing a repeated header, with special handling for "Set-Cookie".
        :param pulumi.Input[str] type: Type specifies how to match against the value of the header.
               
               Support: Core (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression HeaderMatchType has implementation-specific
               conformance, implementations can support POSIX, PCRE or any other dialects
               of regular expressions. Please read the implementation's documentation to
               determine the supported dialect.
        :param pulumi.Input[str] value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.

        When a header is repeated in an HTTP request, it is
        implementation-specific behavior as to how this is represented.
        Generally, proxies should follow the guidance from the RFC:
        https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
        processing a repeated header, with special handling for "Set-Cookie".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the value of the header.

        Support: Core (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression HeaderMatchType has implementation-specific
        conformance, implementations can support POSIX, PCRE or any other dialects
        of regular expressions. Please read the implementation's documentation to
        determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesPatchArgsDict(TypedDict):
        """
        HTTPRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a HTTP request only if its path
        starts with `/foo` AND it contains the `version: v1` header:

        ```
        match:

        	path:
        	  value: "/foo"
        	headers:
        	- name: "version"
        	  value "v1"

        ```
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersPatchArgsDict']]]]
        """
        Headers specifies HTTP request header matchers. Multiple match values are
        ANDed together, meaning, a request must match all the specified headers
        to select the route.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Method specifies HTTP method matcher.
        When specified, this route will be matched only if the request has the
        specified method.

        Support: Extended
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesMatchesPathPatchArgsDict']]
        query_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsPatchArgsDict']]]]
        """
        QueryParams specifies HTTP query parameter matchers. Multiple match
        values are ANDed together, meaning, a request must match all the
        specified query parameters to select the route.

        Support: Extended
        """
elif False:
    HTTPRouteSpecRulesMatchesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesPatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersPatchArgs']]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesMatchesPathPatchArgs']] = None,
                 query_params: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsPatchArgs']]]] = None):
        """
        HTTPRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a HTTP request only if its path
        starts with `/foo` AND it contains the `version: v1` header:

        ```
        match:

        	path:
        	  value: "/foo"
        	headers:
        	- name: "version"
        	  value "v1"

        ```
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersPatchArgs']]] headers: Headers specifies HTTP request header matchers. Multiple match values are
               ANDed together, meaning, a request must match all the specified headers
               to select the route.
        :param pulumi.Input[str] method: Method specifies HTTP method matcher.
               When specified, this route will be matched only if the request has the
               specified method.
               
               Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsPatchArgs']]] query_params: QueryParams specifies HTTP query parameter matchers. Multiple match
               values are ANDed together, meaning, a request must match all the
               specified query parameters to select the route.
               
               Support: Extended
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersPatchArgs']]]]:
        """
        Headers specifies HTTP request header matchers. Multiple match values are
        ANDed together, meaning, a request must match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersPatchArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Method specifies HTTP method matcher.
        When specified, this route will be matched only if the request has the
        specified method.

        Support: Extended
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesMatchesPathPatchArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesMatchesPathPatchArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsPatchArgs']]]]:
        """
        QueryParams specifies HTTP query parameter matchers. Multiple match
        values are ANDed together, meaning, a request must match all the
        specified query parameters to select the route.

        Support: Extended
        """
        return pulumi.get(self, "query_params")

    @query_params.setter
    def query_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsPatchArgs']]]]):
        pulumi.set(self, "query_params", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesPathPatchArgsDict(TypedDict):
        """
        Path specifies a HTTP request path matcher. If this field is not
        specified, a default prefix match on the "/" path is provided.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the path Value.

        Support: Core (Exact, PathPrefix)

        Support: Implementation-specific (RegularExpression)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the HTTP path to match against.
        """
elif False:
    HTTPRouteSpecRulesMatchesPathPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesPathPatchArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Path specifies a HTTP request path matcher. If this field is not
        specified, a default prefix match on the "/" path is provided.
        :param pulumi.Input[str] type: Type specifies how to match against the path Value.
               
               Support: Core (Exact, PathPrefix)
               
               Support: Implementation-specific (RegularExpression)
        :param pulumi.Input[str] value: Value of the HTTP path to match against.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the path Value.

        Support: Core (Exact, PathPrefix)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the HTTP path to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesPathArgsDict(TypedDict):
        """
        Path specifies a HTTP request path matcher. If this field is not
        specified, a default prefix match on the "/" path is provided.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the path Value.

        Support: Core (Exact, PathPrefix)

        Support: Implementation-specific (RegularExpression)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the HTTP path to match against.
        """
elif False:
    HTTPRouteSpecRulesMatchesPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesPathArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Path specifies a HTTP request path matcher. If this field is not
        specified, a default prefix match on the "/" path is provided.
        :param pulumi.Input[str] type: Type specifies how to match against the path Value.
               
               Support: Core (Exact, PathPrefix)
               
               Support: Implementation-specific (RegularExpression)
        :param pulumi.Input[str] value: Value of the HTTP path to match against.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the path Value.

        Support: Core (Exact, PathPrefix)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the HTTP path to match against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesQueryParamsPatchArgsDict(TypedDict):
        """
        HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
        query parameters.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP query param to be matched. This must be an
        exact string match. (See
        https://tools.ietf.org/html/rfc7230#section-2.7.3).

        If multiple entries specify equivalent query param names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent query param name MUST be ignored.

        If a query param is repeated in an HTTP request, the behavior is
        purposely left undefined, since different data planes have different
        capabilities. However, it is *recommended* that implementations should
        match against the first value of the param if the data plane supports it,
        as this behavior is expected in other load balancing contexts outside of
        the Gateway API.

        Users SHOULD NOT route traffic based on repeated query params to guard
        themselves against potential differences in the implementations.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the value of the query parameter.

        Support: Extended (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression QueryParamMatchType has Implementation-specific
        conformance, implementations can support POSIX, PCRE or any other
        dialects of regular expressions. Please read the implementation's
        documentation to determine the supported dialect.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP query param to be matched.
        """
elif False:
    HTTPRouteSpecRulesMatchesQueryParamsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesQueryParamsPatchArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
        query parameters.
        :param pulumi.Input[str] name: Name is the name of the HTTP query param to be matched. This must be an
               exact string match. (See
               https://tools.ietf.org/html/rfc7230#section-2.7.3).
               
               If multiple entries specify equivalent query param names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent query param name MUST be ignored.
               
               If a query param is repeated in an HTTP request, the behavior is
               purposely left undefined, since different data planes have different
               capabilities. However, it is *recommended* that implementations should
               match against the first value of the param if the data plane supports it,
               as this behavior is expected in other load balancing contexts outside of
               the Gateway API.
               
               Users SHOULD NOT route traffic based on repeated query params to guard
               themselves against potential differences in the implementations.
        :param pulumi.Input[str] type: Type specifies how to match against the value of the query parameter.
               
               Support: Extended (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression QueryParamMatchType has Implementation-specific
               conformance, implementations can support POSIX, PCRE or any other
               dialects of regular expressions. Please read the implementation's
               documentation to determine the supported dialect.
        :param pulumi.Input[str] value: Value is the value of HTTP query param to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP query param to be matched. This must be an
        exact string match. (See
        https://tools.ietf.org/html/rfc7230#section-2.7.3).

        If multiple entries specify equivalent query param names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent query param name MUST be ignored.

        If a query param is repeated in an HTTP request, the behavior is
        purposely left undefined, since different data planes have different
        capabilities. However, it is *recommended* that implementations should
        match against the first value of the param if the data plane supports it,
        as this behavior is expected in other load balancing contexts outside of
        the Gateway API.

        Users SHOULD NOT route traffic based on repeated query params to guard
        themselves against potential differences in the implementations.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the value of the query parameter.

        Support: Extended (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression QueryParamMatchType has Implementation-specific
        conformance, implementations can support POSIX, PCRE or any other
        dialects of regular expressions. Please read the implementation's
        documentation to determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP query param to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesQueryParamsArgsDict(TypedDict):
        """
        HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
        query parameters.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the HTTP query param to be matched. This must be an
        exact string match. (See
        https://tools.ietf.org/html/rfc7230#section-2.7.3).

        If multiple entries specify equivalent query param names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent query param name MUST be ignored.

        If a query param is repeated in an HTTP request, the behavior is
        purposely left undefined, since different data planes have different
        capabilities. However, it is *recommended* that implementations should
        match against the first value of the param if the data plane supports it,
        as this behavior is expected in other load balancing contexts outside of
        the Gateway API.

        Users SHOULD NOT route traffic based on repeated query params to guard
        themselves against potential differences in the implementations.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type specifies how to match against the value of the query parameter.

        Support: Extended (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression QueryParamMatchType has Implementation-specific
        conformance, implementations can support POSIX, PCRE or any other
        dialects of regular expressions. Please read the implementation's
        documentation to determine the supported dialect.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value is the value of HTTP query param to be matched.
        """
elif False:
    HTTPRouteSpecRulesMatchesQueryParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesQueryParamsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
        query parameters.
        :param pulumi.Input[str] name: Name is the name of the HTTP query param to be matched. This must be an
               exact string match. (See
               https://tools.ietf.org/html/rfc7230#section-2.7.3).
               
               If multiple entries specify equivalent query param names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent query param name MUST be ignored.
               
               If a query param is repeated in an HTTP request, the behavior is
               purposely left undefined, since different data planes have different
               capabilities. However, it is *recommended* that implementations should
               match against the first value of the param if the data plane supports it,
               as this behavior is expected in other load balancing contexts outside of
               the Gateway API.
               
               Users SHOULD NOT route traffic based on repeated query params to guard
               themselves against potential differences in the implementations.
        :param pulumi.Input[str] type: Type specifies how to match against the value of the query parameter.
               
               Support: Extended (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression QueryParamMatchType has Implementation-specific
               conformance, implementations can support POSIX, PCRE or any other
               dialects of regular expressions. Please read the implementation's
               documentation to determine the supported dialect.
        :param pulumi.Input[str] value: Value is the value of HTTP query param to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the HTTP query param to be matched. This must be an
        exact string match. (See
        https://tools.ietf.org/html/rfc7230#section-2.7.3).

        If multiple entries specify equivalent query param names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent query param name MUST be ignored.

        If a query param is repeated in an HTTP request, the behavior is
        purposely left undefined, since different data planes have different
        capabilities. However, it is *recommended* that implementations should
        match against the first value of the param if the data plane supports it,
        as this behavior is expected in other load balancing contexts outside of
        the Gateway API.

        Users SHOULD NOT route traffic based on repeated query params to guard
        themselves against potential differences in the implementations.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type specifies how to match against the value of the query parameter.

        Support: Extended (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression QueryParamMatchType has Implementation-specific
        conformance, implementations can support POSIX, PCRE or any other
        dialects of regular expressions. Please read the implementation's
        documentation to determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the value of HTTP query param to be matched.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HTTPRouteSpecRulesMatchesArgsDict(TypedDict):
        """
        HTTPRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a HTTP request only if its path
        starts with `/foo` AND it contains the `version: v1` header:

        ```
        match:

        	path:
        	  value: "/foo"
        	headers:
        	- name: "version"
        	  value "v1"

        ```
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersArgsDict']]]]
        """
        Headers specifies HTTP request header matchers. Multiple match values are
        ANDed together, meaning, a request must match all the specified headers
        to select the route.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Method specifies HTTP method matcher.
        When specified, this route will be matched only if the request has the
        specified method.

        Support: Extended
        """
        path: NotRequired[pulumi.Input['HTTPRouteSpecRulesMatchesPathArgsDict']]
        query_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsArgsDict']]]]
        """
        QueryParams specifies HTTP query parameter matchers. Multiple match
        values are ANDed together, meaning, a request must match all the
        specified query parameters to select the route.

        Support: Extended
        """
elif False:
    HTTPRouteSpecRulesMatchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesMatchesArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersArgs']]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['HTTPRouteSpecRulesMatchesPathArgs']] = None,
                 query_params: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsArgs']]]] = None):
        """
        HTTPRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a HTTP request only if its path
        starts with `/foo` AND it contains the `version: v1` header:

        ```
        match:

        	path:
        	  value: "/foo"
        	headers:
        	- name: "version"
        	  value "v1"

        ```
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersArgs']]] headers: Headers specifies HTTP request header matchers. Multiple match values are
               ANDed together, meaning, a request must match all the specified headers
               to select the route.
        :param pulumi.Input[str] method: Method specifies HTTP method matcher.
               When specified, this route will be matched only if the request has the
               specified method.
               
               Support: Extended
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsArgs']]] query_params: QueryParams specifies HTTP query parameter matchers. Multiple match
               values are ANDed together, meaning, a request must match all the
               specified query parameters to select the route.
               
               Support: Extended
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersArgs']]]]:
        """
        Headers specifies HTTP request header matchers. Multiple match values are
        ANDed together, meaning, a request must match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesHeadersArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Method specifies HTTP method matcher.
        When specified, this route will be matched only if the request has the
        specified method.

        Support: Extended
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesMatchesPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesMatchesPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsArgs']]]]:
        """
        QueryParams specifies HTTP query parameter matchers. Multiple match
        values are ANDed together, meaning, a request must match all the
        specified query parameters to select the route.

        Support: Extended
        """
        return pulumi.get(self, "query_params")

    @query_params.setter
    def query_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesQueryParamsArgs']]]]):
        pulumi.set(self, "query_params", value)


if not MYPY:
    class HTTPRouteSpecRulesPatchArgsDict(TypedDict):
        """
        HTTPRouteRule defines semantics for matching an HTTP request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        """
        backend_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsPatchArgsDict']]]]
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive a 500 status code.

        See the HTTPBackendRef definition for the rules about what makes a single
        HTTPBackendRef invalid.

        When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive a 500 status code.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic must receive a 500. Implementations may
        choose how that 50 percent is determined.

        When a HTTPBackendRef refers to a Service that has no ready endpoints,
        implementations SHOULD return a 503 for requests to that backend instead.
        If an implementation chooses to do this, all of the above rules for 500 responses
        MUST also apply for responses that return a 503.

        Support: Core for Kubernetes Service

        Support: Extended for Kubernetes ServiceImport

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersPatchArgsDict']]]]
        """
        Filters define the filters that are applied to requests that match
        this rule.

        Wherever possible, implementations SHOULD implement filters in the order
        they are specified.

        Implementations MAY choose to implement this ordering strictly, rejecting
        any combination or order of filters that can not be supported. If implementations
        choose a strict interpretation of filter ordering, they MUST clearly document
        that behavior.

        To reject an invalid combination or order of filters, implementations SHOULD
        consider the Route Rules with this configuration invalid. If all Route Rules
        in a Route are invalid, the entire Route would be considered invalid. If only
        a portion of Route Rules are invalid, implementations MUST set the
        "PartiallyInvalid" condition for the Route.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        All filters are expected to be compatible with each other except for the
        URLRewrite and RequestRedirect filters, which may not be combined. If an
        implementation can not support other combinations of filters, they must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesPatchArgsDict']]]]
        """
        Matches define conditions used for matching the rule against incoming
        HTTP requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - path:
            value: "/foo"
          headers:
          - name: "version"
            value: "v2"
        - path:
            value: "/v2/foo"
        ```

        For a request to match against this rule, a request must satisfy
        EITHER of the two conditions:

        - path prefixed with `/foo` AND contains the header `version: v2`
        - path prefix of `/v2/foo`

        See the documentation for HTTPRouteMatch on how to specify multiple
        match conditions that should be ANDed together.

        If no matches are specified, the default is a prefix
        path match on "/", which has the effect of matching every
        HTTP request.

        Proxy or Load Balancer routing configuration generated from HTTPRoutes
        MUST prioritize matches based on the following criteria, continuing on
        ties. Across all rules specified on applicable Routes, precedence must be
        given to the match having:

        * "Exact" path match.
        * "Prefix" path match with largest number of characters.
        * Method match.
        * Largest number of header matches.
        * Largest number of query param matches.

        Note: The precedence of RegularExpression path matches are implementation-specific.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within an HTTPRoute, matching precedence MUST be granted
        to the FIRST matching rule (in list order) with a match meeting the above
        criteria.

        When no rules matching a request have been successfully attached to the
        parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        timeouts: NotRequired[pulumi.Input['HTTPRouteSpecRulesTimeoutsPatchArgsDict']]
elif False:
    HTTPRouteSpecRulesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesPatchArgs:
    def __init__(__self__, *,
                 backend_refs: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsPatchArgs']]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersPatchArgs']]]] = None,
                 matches: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesPatchArgs']]]] = None,
                 timeouts: Optional[pulumi.Input['HTTPRouteSpecRulesTimeoutsPatchArgs']] = None):
        """
        HTTPRouteRule defines semantics for matching an HTTP request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsPatchArgs']]] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive a 500 status code.
               
               See the HTTPBackendRef definition for the rules about what makes a single
               HTTPBackendRef invalid.
               
               When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive a 500 status code.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic must receive a 500. Implementations may
               choose how that 50 percent is determined.
               
               When a HTTPBackendRef refers to a Service that has no ready endpoints,
               implementations SHOULD return a 503 for requests to that backend instead.
               If an implementation chooses to do this, all of the above rules for 500 responses
               MUST also apply for responses that return a 503.
               
               Support: Core for Kubernetes Service
               
               Support: Extended for Kubernetes ServiceImport
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersPatchArgs']]] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               Wherever possible, implementations SHOULD implement filters in the order
               they are specified.
               
               Implementations MAY choose to implement this ordering strictly, rejecting
               any combination or order of filters that can not be supported. If implementations
               choose a strict interpretation of filter ordering, they MUST clearly document
               that behavior.
               
               To reject an invalid combination or order of filters, implementations SHOULD
               consider the Route Rules with this configuration invalid. If all Route Rules
               in a Route are invalid, the entire Route would be considered invalid. If only
               a portion of Route Rules are invalid, implementations MUST set the
               "PartiallyInvalid" condition for the Route.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               All filters are expected to be compatible with each other except for the
               URLRewrite and RequestRedirect filters, which may not be combined. If an
               implementation can not support other combinations of filters, they must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesPatchArgs']]] matches: Matches define conditions used for matching the rule against incoming
               HTTP requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - path:
                   value: "/foo"
                 headers:
                 - name: "version"
                   value: "v2"
               - path:
                   value: "/v2/foo"
               ```
               
               For a request to match against this rule, a request must satisfy
               EITHER of the two conditions:
               
               - path prefixed with `/foo` AND contains the header `version: v2`
               - path prefix of `/v2/foo`
               
               See the documentation for HTTPRouteMatch on how to specify multiple
               match conditions that should be ANDed together.
               
               If no matches are specified, the default is a prefix
               path match on "/", which has the effect of matching every
               HTTP request.
               
               Proxy or Load Balancer routing configuration generated from HTTPRoutes
               MUST prioritize matches based on the following criteria, continuing on
               ties. Across all rules specified on applicable Routes, precedence must be
               given to the match having:
               
               * "Exact" path match.
               * "Prefix" path match with largest number of characters.
               * Method match.
               * Largest number of header matches.
               * Largest number of query param matches.
               
               Note: The precedence of RegularExpression path matches are implementation-specific.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within an HTTPRoute, matching precedence MUST be granted
               to the FIRST matching rule (in list order) with a match meeting the above
               criteria.
               
               When no rules matching a request have been successfully attached to the
               parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsPatchArgs']]]]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive a 500 status code.

        See the HTTPBackendRef definition for the rules about what makes a single
        HTTPBackendRef invalid.

        When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive a 500 status code.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic must receive a 500. Implementations may
        choose how that 50 percent is determined.

        When a HTTPBackendRef refers to a Service that has no ready endpoints,
        implementations SHOULD return a 503 for requests to that backend instead.
        If an implementation chooses to do this, all of the above rules for 500 responses
        MUST also apply for responses that return a 503.

        Support: Core for Kubernetes Service

        Support: Extended for Kubernetes ServiceImport

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @backend_refs.setter
    def backend_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsPatchArgs']]]]):
        pulumi.set(self, "backend_refs", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersPatchArgs']]]]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        Wherever possible, implementations SHOULD implement filters in the order
        they are specified.

        Implementations MAY choose to implement this ordering strictly, rejecting
        any combination or order of filters that can not be supported. If implementations
        choose a strict interpretation of filter ordering, they MUST clearly document
        that behavior.

        To reject an invalid combination or order of filters, implementations SHOULD
        consider the Route Rules with this configuration invalid. If all Route Rules
        in a Route are invalid, the entire Route would be considered invalid. If only
        a portion of Route Rules are invalid, implementations MUST set the
        "PartiallyInvalid" condition for the Route.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        All filters are expected to be compatible with each other except for the
        URLRewrite and RequestRedirect filters, which may not be combined. If an
        implementation can not support other combinations of filters, they must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersPatchArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesPatchArgs']]]]:
        """
        Matches define conditions used for matching the rule against incoming
        HTTP requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - path:
            value: "/foo"
          headers:
          - name: "version"
            value: "v2"
        - path:
            value: "/v2/foo"
        ```

        For a request to match against this rule, a request must satisfy
        EITHER of the two conditions:

        - path prefixed with `/foo` AND contains the header `version: v2`
        - path prefix of `/v2/foo`

        See the documentation for HTTPRouteMatch on how to specify multiple
        match conditions that should be ANDed together.

        If no matches are specified, the default is a prefix
        path match on "/", which has the effect of matching every
        HTTP request.

        Proxy or Load Balancer routing configuration generated from HTTPRoutes
        MUST prioritize matches based on the following criteria, continuing on
        ties. Across all rules specified on applicable Routes, precedence must be
        given to the match having:

        * "Exact" path match.
        * "Prefix" path match with largest number of characters.
        * Method match.
        * Largest number of header matches.
        * Largest number of query param matches.

        Note: The precedence of RegularExpression path matches are implementation-specific.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within an HTTPRoute, matching precedence MUST be granted
        to the FIRST matching rule (in list order) with a match meeting the above
        criteria.

        When no rules matching a request have been successfully attached to the
        parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesPatchArgs']]]]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def timeouts(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesTimeoutsPatchArgs']]:
        return pulumi.get(self, "timeouts")

    @timeouts.setter
    def timeouts(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesTimeoutsPatchArgs']]):
        pulumi.set(self, "timeouts", value)


if not MYPY:
    class HTTPRouteSpecRulesTimeoutsPatchArgsDict(TypedDict):
        """
        Timeouts defines the timeouts that can be configured for an HTTP request.

        Support: Extended
        """
        backend_request: NotRequired[pulumi.Input[str]]
        """
        BackendRequest specifies a timeout for an individual request from the gateway
        to a backend. This covers the time from when the request first starts being
        sent from the gateway to when the full response has been received from the backend.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        An entire client HTTP transaction with a gateway, covered by the Request timeout,
        may result in more than one call from the gateway to the destination backend,
        for example, if automatic retries are supported.

        The value of BackendRequest must be a Gateway API Duration string as defined by
        GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
        when specified, the value of BackendRequest must be no more than the value of the
        Request timeout (since the Request timeout encompasses the BackendRequest timeout).

        Support: Extended
        """
        request: NotRequired[pulumi.Input[str]]
        """
        Request specifies the maximum duration for a gateway to respond to an HTTP request.
        If the gateway has not been able to respond before this deadline is met, the gateway
        MUST return a timeout error.

        For example, setting the `rules.timeouts.request` field to the value `10s` in an
        `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
        to complete.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        This timeout is intended to cover as close to the whole request-response transaction
        as possible although an implementation MAY choose to start the timeout after the entire
        request stream has been received instead of immediately after the transaction is
        initiated by the client.

        The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
        field is unspecified, request timeout behavior is implementation-specific.

        Support: Extended
        """
elif False:
    HTTPRouteSpecRulesTimeoutsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesTimeoutsPatchArgs:
    def __init__(__self__, *,
                 backend_request: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input[str]] = None):
        """
        Timeouts defines the timeouts that can be configured for an HTTP request.

        Support: Extended
        :param pulumi.Input[str] backend_request: BackendRequest specifies a timeout for an individual request from the gateway
               to a backend. This covers the time from when the request first starts being
               sent from the gateway to when the full response has been received from the backend.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               An entire client HTTP transaction with a gateway, covered by the Request timeout,
               may result in more than one call from the gateway to the destination backend,
               for example, if automatic retries are supported.
               
               The value of BackendRequest must be a Gateway API Duration string as defined by
               GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
               when specified, the value of BackendRequest must be no more than the value of the
               Request timeout (since the Request timeout encompasses the BackendRequest timeout).
               
               Support: Extended
        :param pulumi.Input[str] request: Request specifies the maximum duration for a gateway to respond to an HTTP request.
               If the gateway has not been able to respond before this deadline is met, the gateway
               MUST return a timeout error.
               
               For example, setting the `rules.timeouts.request` field to the value `10s` in an
               `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
               to complete.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               This timeout is intended to cover as close to the whole request-response transaction
               as possible although an implementation MAY choose to start the timeout after the entire
               request stream has been received instead of immediately after the transaction is
               initiated by the client.
               
               The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
               field is unspecified, request timeout behavior is implementation-specific.
               
               Support: Extended
        """
        if backend_request is not None:
            pulumi.set(__self__, "backend_request", backend_request)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @property
    @pulumi.getter(name="backendRequest")
    def backend_request(self) -> Optional[pulumi.Input[str]]:
        """
        BackendRequest specifies a timeout for an individual request from the gateway
        to a backend. This covers the time from when the request first starts being
        sent from the gateway to when the full response has been received from the backend.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        An entire client HTTP transaction with a gateway, covered by the Request timeout,
        may result in more than one call from the gateway to the destination backend,
        for example, if automatic retries are supported.

        The value of BackendRequest must be a Gateway API Duration string as defined by
        GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
        when specified, the value of BackendRequest must be no more than the value of the
        Request timeout (since the Request timeout encompasses the BackendRequest timeout).

        Support: Extended
        """
        return pulumi.get(self, "backend_request")

    @backend_request.setter
    def backend_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_request", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[str]]:
        """
        Request specifies the maximum duration for a gateway to respond to an HTTP request.
        If the gateway has not been able to respond before this deadline is met, the gateway
        MUST return a timeout error.

        For example, setting the `rules.timeouts.request` field to the value `10s` in an
        `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
        to complete.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        This timeout is intended to cover as close to the whole request-response transaction
        as possible although an implementation MAY choose to start the timeout after the entire
        request stream has been received instead of immediately after the transaction is
        initiated by the client.

        The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
        field is unspecified, request timeout behavior is implementation-specific.

        Support: Extended
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request", value)


if not MYPY:
    class HTTPRouteSpecRulesTimeoutsArgsDict(TypedDict):
        """
        Timeouts defines the timeouts that can be configured for an HTTP request.

        Support: Extended
        """
        backend_request: NotRequired[pulumi.Input[str]]
        """
        BackendRequest specifies a timeout for an individual request from the gateway
        to a backend. This covers the time from when the request first starts being
        sent from the gateway to when the full response has been received from the backend.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        An entire client HTTP transaction with a gateway, covered by the Request timeout,
        may result in more than one call from the gateway to the destination backend,
        for example, if automatic retries are supported.

        The value of BackendRequest must be a Gateway API Duration string as defined by
        GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
        when specified, the value of BackendRequest must be no more than the value of the
        Request timeout (since the Request timeout encompasses the BackendRequest timeout).

        Support: Extended
        """
        request: NotRequired[pulumi.Input[str]]
        """
        Request specifies the maximum duration for a gateway to respond to an HTTP request.
        If the gateway has not been able to respond before this deadline is met, the gateway
        MUST return a timeout error.

        For example, setting the `rules.timeouts.request` field to the value `10s` in an
        `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
        to complete.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        This timeout is intended to cover as close to the whole request-response transaction
        as possible although an implementation MAY choose to start the timeout after the entire
        request stream has been received instead of immediately after the transaction is
        initiated by the client.

        The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
        field is unspecified, request timeout behavior is implementation-specific.

        Support: Extended
        """
elif False:
    HTTPRouteSpecRulesTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesTimeoutsArgs:
    def __init__(__self__, *,
                 backend_request: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input[str]] = None):
        """
        Timeouts defines the timeouts that can be configured for an HTTP request.

        Support: Extended
        :param pulumi.Input[str] backend_request: BackendRequest specifies a timeout for an individual request from the gateway
               to a backend. This covers the time from when the request first starts being
               sent from the gateway to when the full response has been received from the backend.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               An entire client HTTP transaction with a gateway, covered by the Request timeout,
               may result in more than one call from the gateway to the destination backend,
               for example, if automatic retries are supported.
               
               The value of BackendRequest must be a Gateway API Duration string as defined by
               GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
               when specified, the value of BackendRequest must be no more than the value of the
               Request timeout (since the Request timeout encompasses the BackendRequest timeout).
               
               Support: Extended
        :param pulumi.Input[str] request: Request specifies the maximum duration for a gateway to respond to an HTTP request.
               If the gateway has not been able to respond before this deadline is met, the gateway
               MUST return a timeout error.
               
               For example, setting the `rules.timeouts.request` field to the value `10s` in an
               `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
               to complete.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               This timeout is intended to cover as close to the whole request-response transaction
               as possible although an implementation MAY choose to start the timeout after the entire
               request stream has been received instead of immediately after the transaction is
               initiated by the client.
               
               The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
               field is unspecified, request timeout behavior is implementation-specific.
               
               Support: Extended
        """
        if backend_request is not None:
            pulumi.set(__self__, "backend_request", backend_request)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @property
    @pulumi.getter(name="backendRequest")
    def backend_request(self) -> Optional[pulumi.Input[str]]:
        """
        BackendRequest specifies a timeout for an individual request from the gateway
        to a backend. This covers the time from when the request first starts being
        sent from the gateway to when the full response has been received from the backend.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        An entire client HTTP transaction with a gateway, covered by the Request timeout,
        may result in more than one call from the gateway to the destination backend,
        for example, if automatic retries are supported.

        The value of BackendRequest must be a Gateway API Duration string as defined by
        GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
        when specified, the value of BackendRequest must be no more than the value of the
        Request timeout (since the Request timeout encompasses the BackendRequest timeout).

        Support: Extended
        """
        return pulumi.get(self, "backend_request")

    @backend_request.setter
    def backend_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_request", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[str]]:
        """
        Request specifies the maximum duration for a gateway to respond to an HTTP request.
        If the gateway has not been able to respond before this deadline is met, the gateway
        MUST return a timeout error.

        For example, setting the `rules.timeouts.request` field to the value `10s` in an
        `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
        to complete.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        This timeout is intended to cover as close to the whole request-response transaction
        as possible although an implementation MAY choose to start the timeout after the entire
        request stream has been received instead of immediately after the transaction is
        initiated by the client.

        The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
        field is unspecified, request timeout behavior is implementation-specific.

        Support: Extended
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request", value)


if not MYPY:
    class HTTPRouteSpecRulesArgsDict(TypedDict):
        """
        HTTPRouteRule defines semantics for matching an HTTP request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        """
        backend_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsArgsDict']]]]
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive a 500 status code.

        See the HTTPBackendRef definition for the rules about what makes a single
        HTTPBackendRef invalid.

        When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive a 500 status code.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic must receive a 500. Implementations may
        choose how that 50 percent is determined.

        When a HTTPBackendRef refers to a Service that has no ready endpoints,
        implementations SHOULD return a 503 for requests to that backend instead.
        If an implementation chooses to do this, all of the above rules for 500 responses
        MUST also apply for responses that return a 503.

        Support: Core for Kubernetes Service

        Support: Extended for Kubernetes ServiceImport

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersArgsDict']]]]
        """
        Filters define the filters that are applied to requests that match
        this rule.

        Wherever possible, implementations SHOULD implement filters in the order
        they are specified.

        Implementations MAY choose to implement this ordering strictly, rejecting
        any combination or order of filters that can not be supported. If implementations
        choose a strict interpretation of filter ordering, they MUST clearly document
        that behavior.

        To reject an invalid combination or order of filters, implementations SHOULD
        consider the Route Rules with this configuration invalid. If all Route Rules
        in a Route are invalid, the entire Route would be considered invalid. If only
        a portion of Route Rules are invalid, implementations MUST set the
        "PartiallyInvalid" condition for the Route.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        All filters are expected to be compatible with each other except for the
        URLRewrite and RequestRedirect filters, which may not be combined. If an
        implementation can not support other combinations of filters, they must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesArgsDict']]]]
        """
        Matches define conditions used for matching the rule against incoming
        HTTP requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - path:
            value: "/foo"
          headers:
          - name: "version"
            value: "v2"
        - path:
            value: "/v2/foo"
        ```

        For a request to match against this rule, a request must satisfy
        EITHER of the two conditions:

        - path prefixed with `/foo` AND contains the header `version: v2`
        - path prefix of `/v2/foo`

        See the documentation for HTTPRouteMatch on how to specify multiple
        match conditions that should be ANDed together.

        If no matches are specified, the default is a prefix
        path match on "/", which has the effect of matching every
        HTTP request.

        Proxy or Load Balancer routing configuration generated from HTTPRoutes
        MUST prioritize matches based on the following criteria, continuing on
        ties. Across all rules specified on applicable Routes, precedence must be
        given to the match having:

        * "Exact" path match.
        * "Prefix" path match with largest number of characters.
        * Method match.
        * Largest number of header matches.
        * Largest number of query param matches.

        Note: The precedence of RegularExpression path matches are implementation-specific.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within an HTTPRoute, matching precedence MUST be granted
        to the FIRST matching rule (in list order) with a match meeting the above
        criteria.

        When no rules matching a request have been successfully attached to the
        parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        timeouts: NotRequired[pulumi.Input['HTTPRouteSpecRulesTimeoutsArgsDict']]
elif False:
    HTTPRouteSpecRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecRulesArgs:
    def __init__(__self__, *,
                 backend_refs: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsArgs']]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersArgs']]]] = None,
                 matches: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesArgs']]]] = None,
                 timeouts: Optional[pulumi.Input['HTTPRouteSpecRulesTimeoutsArgs']] = None):
        """
        HTTPRouteRule defines semantics for matching an HTTP request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsArgs']]] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive a 500 status code.
               
               See the HTTPBackendRef definition for the rules about what makes a single
               HTTPBackendRef invalid.
               
               When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive a 500 status code.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic must receive a 500. Implementations may
               choose how that 50 percent is determined.
               
               When a HTTPBackendRef refers to a Service that has no ready endpoints,
               implementations SHOULD return a 503 for requests to that backend instead.
               If an implementation chooses to do this, all of the above rules for 500 responses
               MUST also apply for responses that return a 503.
               
               Support: Core for Kubernetes Service
               
               Support: Extended for Kubernetes ServiceImport
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersArgs']]] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               Wherever possible, implementations SHOULD implement filters in the order
               they are specified.
               
               Implementations MAY choose to implement this ordering strictly, rejecting
               any combination or order of filters that can not be supported. If implementations
               choose a strict interpretation of filter ordering, they MUST clearly document
               that behavior.
               
               To reject an invalid combination or order of filters, implementations SHOULD
               consider the Route Rules with this configuration invalid. If all Route Rules
               in a Route are invalid, the entire Route would be considered invalid. If only
               a portion of Route Rules are invalid, implementations MUST set the
               "PartiallyInvalid" condition for the Route.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               All filters are expected to be compatible with each other except for the
               URLRewrite and RequestRedirect filters, which may not be combined. If an
               implementation can not support other combinations of filters, they must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesArgs']]] matches: Matches define conditions used for matching the rule against incoming
               HTTP requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - path:
                   value: "/foo"
                 headers:
                 - name: "version"
                   value: "v2"
               - path:
                   value: "/v2/foo"
               ```
               
               For a request to match against this rule, a request must satisfy
               EITHER of the two conditions:
               
               - path prefixed with `/foo` AND contains the header `version: v2`
               - path prefix of `/v2/foo`
               
               See the documentation for HTTPRouteMatch on how to specify multiple
               match conditions that should be ANDed together.
               
               If no matches are specified, the default is a prefix
               path match on "/", which has the effect of matching every
               HTTP request.
               
               Proxy or Load Balancer routing configuration generated from HTTPRoutes
               MUST prioritize matches based on the following criteria, continuing on
               ties. Across all rules specified on applicable Routes, precedence must be
               given to the match having:
               
               * "Exact" path match.
               * "Prefix" path match with largest number of characters.
               * Method match.
               * Largest number of header matches.
               * Largest number of query param matches.
               
               Note: The precedence of RegularExpression path matches are implementation-specific.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within an HTTPRoute, matching precedence MUST be granted
               to the FIRST matching rule (in list order) with a match meeting the above
               criteria.
               
               When no rules matching a request have been successfully attached to the
               parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsArgs']]]]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive a 500 status code.

        See the HTTPBackendRef definition for the rules about what makes a single
        HTTPBackendRef invalid.

        When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive a 500 status code.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic must receive a 500. Implementations may
        choose how that 50 percent is determined.

        When a HTTPBackendRef refers to a Service that has no ready endpoints,
        implementations SHOULD return a 503 for requests to that backend instead.
        If an implementation chooses to do this, all of the above rules for 500 responses
        MUST also apply for responses that return a 503.

        Support: Core for Kubernetes Service

        Support: Extended for Kubernetes ServiceImport

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @backend_refs.setter
    def backend_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesBackendRefsArgs']]]]):
        pulumi.set(self, "backend_refs", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersArgs']]]]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        Wherever possible, implementations SHOULD implement filters in the order
        they are specified.

        Implementations MAY choose to implement this ordering strictly, rejecting
        any combination or order of filters that can not be supported. If implementations
        choose a strict interpretation of filter ordering, they MUST clearly document
        that behavior.

        To reject an invalid combination or order of filters, implementations SHOULD
        consider the Route Rules with this configuration invalid. If all Route Rules
        in a Route are invalid, the entire Route would be considered invalid. If only
        a portion of Route Rules are invalid, implementations MUST set the
        "PartiallyInvalid" condition for the Route.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        All filters are expected to be compatible with each other except for the
        URLRewrite and RequestRedirect filters, which may not be combined. If an
        implementation can not support other combinations of filters, they must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesFiltersArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesArgs']]]]:
        """
        Matches define conditions used for matching the rule against incoming
        HTTP requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - path:
            value: "/foo"
          headers:
          - name: "version"
            value: "v2"
        - path:
            value: "/v2/foo"
        ```

        For a request to match against this rule, a request must satisfy
        EITHER of the two conditions:

        - path prefixed with `/foo` AND contains the header `version: v2`
        - path prefix of `/v2/foo`

        See the documentation for HTTPRouteMatch on how to specify multiple
        match conditions that should be ANDed together.

        If no matches are specified, the default is a prefix
        path match on "/", which has the effect of matching every
        HTTP request.

        Proxy or Load Balancer routing configuration generated from HTTPRoutes
        MUST prioritize matches based on the following criteria, continuing on
        ties. Across all rules specified on applicable Routes, precedence must be
        given to the match having:

        * "Exact" path match.
        * "Prefix" path match with largest number of characters.
        * Method match.
        * Largest number of header matches.
        * Largest number of query param matches.

        Note: The precedence of RegularExpression path matches are implementation-specific.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within an HTTPRoute, matching precedence MUST be granted
        to the FIRST matching rule (in list order) with a match meeting the above
        criteria.

        When no rules matching a request have been successfully attached to the
        parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesMatchesArgs']]]]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def timeouts(self) -> Optional[pulumi.Input['HTTPRouteSpecRulesTimeoutsArgs']]:
        return pulumi.get(self, "timeouts")

    @timeouts.setter
    def timeouts(self, value: Optional[pulumi.Input['HTTPRouteSpecRulesTimeoutsArgs']]):
        pulumi.set(self, "timeouts", value)


if not MYPY:
    class HTTPRouteSpecArgsDict(TypedDict):
        """
        Spec defines the desired state of HTTPRoute.
        """
        hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Hostnames defines a set of hostnames that should match against the HTTP Host
        header to select a HTTPRoute used to process the request. Implementations
        MUST ignore any port value specified in the HTTP Host header while
        performing a match and (absent of any applicable header modification
        configuration) MUST forward this header unmodified to the backend.

        Valid values for Hostnames are determined by RFC 1123 definition of a
        hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label must appear by itself as the first label.

        If a hostname is specified by both the Listener and HTTPRoute, there
        must be at least one intersecting hostname for the HTTPRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `*.example.com`, `test.example.com`, and `foo.test.example.com` would
          all match. On the other hand, `example.com` and `test.example.net` would
          not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and HTTPRoute have specified hostnames, any
        HTTPRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        HTTPRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` must not be considered for a match.

        If both the Listener and HTTPRoute have specified hostnames, and none
        match with the criteria above, then the HTTPRoute is not accepted. The
        implementation must raise an 'Accepted' Condition with a status of
        `False` in the corresponding RouteParentStatus.

        In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
        overlapping wildcard matching and exact matching hostnames), precedence must
        be given to rules from the HTTPRoute with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.

        If ties exist across multiple Routes, the matching precedence rules for
        HTTPRouteMatches takes over.

        Support: Core
        """
        parent_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsArgsDict']]]]
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesArgsDict']]]]
        """
        Rules are a list of HTTP matchers, filters and actions.
        """
elif False:
    HTTPRouteSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteSpecArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parent_refs: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesArgs']]]] = None):
        """
        Spec defines the desired state of HTTPRoute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: Hostnames defines a set of hostnames that should match against the HTTP Host
               header to select a HTTPRoute used to process the request. Implementations
               MUST ignore any port value specified in the HTTP Host header while
               performing a match and (absent of any applicable header modification
               configuration) MUST forward this header unmodified to the backend.
               
               Valid values for Hostnames are determined by RFC 1123 definition of a
               hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label must appear by itself as the first label.
               
               If a hostname is specified by both the Listener and HTTPRoute, there
               must be at least one intersecting hostname for the HTTPRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `*.example.com`, `test.example.com`, and `foo.test.example.com` would
                 all match. On the other hand, `example.com` and `test.example.net` would
                 not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and HTTPRoute have specified hostnames, any
               HTTPRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               HTTPRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` must not be considered for a match.
               
               If both the Listener and HTTPRoute have specified hostnames, and none
               match with the criteria above, then the HTTPRoute is not accepted. The
               implementation must raise an 'Accepted' Condition with a status of
               `False` in the corresponding RouteParentStatus.
               
               In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
               overlapping wildcard matching and exact matching hostnames), precedence must
               be given to rules from the HTTPRoute with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               
               If ties exist across multiple Routes, the matching precedence rules for
               HTTPRouteMatches takes over.
               
               Support: Core
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsArgs']]] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesArgs']]] rules: Rules are a list of HTTP matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Hostnames defines a set of hostnames that should match against the HTTP Host
        header to select a HTTPRoute used to process the request. Implementations
        MUST ignore any port value specified in the HTTP Host header while
        performing a match and (absent of any applicable header modification
        configuration) MUST forward this header unmodified to the backend.

        Valid values for Hostnames are determined by RFC 1123 definition of a
        hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label must appear by itself as the first label.

        If a hostname is specified by both the Listener and HTTPRoute, there
        must be at least one intersecting hostname for the HTTPRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `*.example.com`, `test.example.com`, and `foo.test.example.com` would
          all match. On the other hand, `example.com` and `test.example.net` would
          not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and HTTPRoute have specified hostnames, any
        HTTPRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        HTTPRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` must not be considered for a match.

        If both the Listener and HTTPRoute have specified hostnames, and none
        match with the criteria above, then the HTTPRoute is not accepted. The
        implementation must raise an 'Accepted' Condition with a status of
        `False` in the corresponding RouteParentStatus.

        In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
        overlapping wildcard matching and exact matching hostnames), precedence must
        be given to rules from the HTTPRoute with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.

        If ties exist across multiple Routes, the matching precedence rules for
        HTTPRouteMatches takes over.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsArgs']]]]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @parent_refs.setter
    def parent_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecParentRefsArgs']]]]):
        pulumi.set(self, "parent_refs", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesArgs']]]]:
        """
        Rules are a list of HTTP matchers, filters and actions.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteSpecRulesArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class HTTPRouteStatusParentsConditionsArgsDict(TypedDict):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        """
        last_transition_time: NotRequired[pulumi.Input[str]]
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        observed_generation: NotRequired[pulumi.Input[int]]
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of the condition, one of True, False, Unknown.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
elif False:
    HTTPRouteStatusParentsConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteStatusParentsConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param pulumi.Input[str] last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param pulumi.Input[int] observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param pulumi.Input[str] reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param pulumi.Input[str] status: status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HTTPRouteStatusParentsParentRefArgsDict(TypedDict):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name is the name of the referent.

        Support: Core
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        section_name: NotRequired[pulumi.Input[str]]
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
elif False:
    HTTPRouteStatusParentsParentRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteStatusParentsParentRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 section_name: Optional[pulumi.Input[str]] = None):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        :param pulumi.Input[str] group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param pulumi.Input[str] kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param pulumi.Input[str] name: Name is the name of the referent.
               
               Support: Core
        :param pulumi.Input[str] namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param pulumi.Input[int] port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param pulumi.Input[str] section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[pulumi.Input[str]]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")

    @section_name.setter
    def section_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section_name", value)


if not MYPY:
    class HTTPRouteStatusParentsArgsDict(TypedDict):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsConditionsArgsDict']]]]
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        controller_name: NotRequired[pulumi.Input[str]]
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        parent_ref: NotRequired[pulumi.Input['HTTPRouteStatusParentsParentRefArgsDict']]
elif False:
    HTTPRouteStatusParentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteStatusParentsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsConditionsArgs']]]] = None,
                 controller_name: Optional[pulumi.Input[str]] = None,
                 parent_ref: Optional[pulumi.Input['HTTPRouteStatusParentsParentRefArgs']] = None):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsConditionsArgs']]] conditions: Conditions describes the status of the route with respect to the Gateway.
               Note that the route's availability is also subject to the Gateway's own
               status conditions and listener status.
               
               If the Route's ParentRef specifies an existing Gateway that supports
               Routes of this kind AND that Gateway's controller has sufficient access,
               then that Gateway's controller MUST set the "Accepted" condition on the
               Route, to indicate whether the route has been accepted or rejected by the
               Gateway, and why.
               
               A Route MUST be considered "Accepted" if at least one of the Route's
               rules is implemented by the Gateway.
               
               There are a number of cases where the "Accepted" condition may not be set
               due to lack of controller visibility, that includes when:
               
               * The Route refers to a non-existent parent.
               * The Route is of a type that the controller does not support.
               * The Route is in a namespace the controller does not have access to.
        :param pulumi.Input[str] controller_name: ControllerName is a domain/path string that indicates the name of the
               controller that wrote this status. This corresponds with the
               controllerName field on GatewayClass.
               
               Example: "example.net/gateway-controller".
               
               The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
               valid Kubernetes names
               (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
               
               Controllers MUST populate this field when writing status. Controllers should ensure that
               entries to status populated with their ControllerName are cleaned up when they are no
               longer necessary.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if parent_ref is not None:
            pulumi.set(__self__, "parent_ref", parent_ref)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsConditionsArgs']]]]:
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[pulumi.Input[str]]:
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        return pulumi.get(self, "controller_name")

    @controller_name.setter
    def controller_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_name", value)

    @property
    @pulumi.getter(name="parentRef")
    def parent_ref(self) -> Optional[pulumi.Input['HTTPRouteStatusParentsParentRefArgs']]:
        return pulumi.get(self, "parent_ref")

    @parent_ref.setter
    def parent_ref(self, value: Optional[pulumi.Input['HTTPRouteStatusParentsParentRefArgs']]):
        pulumi.set(self, "parent_ref", value)


if not MYPY:
    class HTTPRouteStatusArgsDict(TypedDict):
        """
        Status defines the current state of HTTPRoute.
        """
        parents: NotRequired[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsArgsDict']]]]
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
elif False:
    HTTPRouteStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteStatusArgs:
    def __init__(__self__, *,
                 parents: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsArgs']]]] = None):
        """
        Status defines the current state of HTTPRoute.
        :param pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsArgs']]] parents: Parents is a list of parent resources (usually Gateways) that are
               associated with the route, and the status of the route with respect to
               each parent. When this route attaches to a parent, the controller that
               manages the parent must add an entry to this list when the controller
               first sees the route and should update the entry as appropriate when the
               route or gateway is modified.
               
               Note that parent references that cannot be resolved by an implementation
               of this API will not be added to this list. Implementations of this API
               can only populate Route status for the Gateways/parent resources they are
               responsible for.
               
               A maximum of 32 Gateways will be represented in this list. An empty list
               means the route has not been attached to any Gateway.
        """
        if parents is not None:
            pulumi.set(__self__, "parents", parents)

    @property
    @pulumi.getter
    def parents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsArgs']]]]:
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
        return pulumi.get(self, "parents")

    @parents.setter
    def parents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HTTPRouteStatusParentsArgs']]]]):
        pulumi.set(self, "parents", value)


if not MYPY:
    class HTTPRouteArgsDict(TypedDict):
        """
        HTTPRoute provides a way to route HTTP requests. This includes the capability
        to match requests by hostname, path, header, or query param. Filters can be
        used to specify additional processing steps. Backends specify where matching
        requests should be routed.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['HTTPRouteSpecArgsDict']]
        status: NotRequired[pulumi.Input['HTTPRouteStatusArgsDict']]
elif False:
    HTTPRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HTTPRouteArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['HTTPRouteSpecArgs']] = None,
                 status: Optional[pulumi.Input['HTTPRouteStatusArgs']] = None):
        """
        HTTPRoute provides a way to route HTTP requests. This includes the capability
        to match requests by hostname, path, header, or query param. Filters can be
        used to specify additional processing steps. Backends specify where matching
        requests should be routed.
        :param pulumi.Input[str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'HTTPRoute')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['HTTPRouteSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['HTTPRouteSpecArgs']]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['HTTPRouteStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['HTTPRouteStatusArgs']]):
        pulumi.set(self, "status", value)


