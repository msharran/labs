# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ... import meta as _meta

__all__ = [
    'GRPCRoute',
    'GRPCRouteSpec',
    'GRPCRouteSpecParentRefs',
    'GRPCRouteSpecParentRefsPatch',
    'GRPCRouteSpecPatch',
    'GRPCRouteSpecRules',
    'GRPCRouteSpecRulesBackendRefs',
    'GRPCRouteSpecRulesBackendRefsFilters',
    'GRPCRouteSpecRulesBackendRefsFiltersExtensionRef',
    'GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirror',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet',
    'GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch',
    'GRPCRouteSpecRulesBackendRefsPatch',
    'GRPCRouteSpecRulesFilters',
    'GRPCRouteSpecRulesFiltersExtensionRef',
    'GRPCRouteSpecRulesFiltersExtensionRefPatch',
    'GRPCRouteSpecRulesFiltersPatch',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifier',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierSet',
    'GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch',
    'GRPCRouteSpecRulesFiltersRequestMirror',
    'GRPCRouteSpecRulesFiltersRequestMirrorBackendRef',
    'GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch',
    'GRPCRouteSpecRulesFiltersRequestMirrorPatch',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifier',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierSet',
    'GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch',
    'GRPCRouteSpecRulesMatches',
    'GRPCRouteSpecRulesMatchesHeaders',
    'GRPCRouteSpecRulesMatchesHeadersPatch',
    'GRPCRouteSpecRulesMatchesMethod',
    'GRPCRouteSpecRulesMatchesMethodPatch',
    'GRPCRouteSpecRulesMatchesPatch',
    'GRPCRouteSpecRulesPatch',
    'GRPCRouteStatus',
    'GRPCRouteStatusParents',
    'GRPCRouteStatusParentsConditions',
    'GRPCRouteStatusParentsConditionsPatch',
    'GRPCRouteStatusParentsParentRef',
    'GRPCRouteStatusParentsParentRefPatch',
    'GRPCRouteStatusParentsPatch',
    'GRPCRouteStatusPatch',
    'Gateway',
    'GatewayClass',
    'GatewayClassSpec',
    'GatewayClassSpecParametersRef',
    'GatewayClassSpecParametersRefPatch',
    'GatewayClassSpecPatch',
    'GatewayClassStatus',
    'GatewayClassStatusConditions',
    'GatewayClassStatusConditionsPatch',
    'GatewayClassStatusPatch',
    'GatewaySpec',
    'GatewaySpecAddresses',
    'GatewaySpecAddressesPatch',
    'GatewaySpecInfrastructure',
    'GatewaySpecInfrastructureParametersRef',
    'GatewaySpecInfrastructureParametersRefPatch',
    'GatewaySpecInfrastructurePatch',
    'GatewaySpecListeners',
    'GatewaySpecListenersAllowedRoutes',
    'GatewaySpecListenersAllowedRoutesKinds',
    'GatewaySpecListenersAllowedRoutesKindsPatch',
    'GatewaySpecListenersAllowedRoutesNamespaces',
    'GatewaySpecListenersAllowedRoutesNamespacesPatch',
    'GatewaySpecListenersAllowedRoutesNamespacesSelector',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch',
    'GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch',
    'GatewaySpecListenersAllowedRoutesPatch',
    'GatewaySpecListenersPatch',
    'GatewaySpecListenersTls',
    'GatewaySpecListenersTlsCertificateRefs',
    'GatewaySpecListenersTlsCertificateRefsPatch',
    'GatewaySpecListenersTlsPatch',
    'GatewaySpecPatch',
    'GatewayStatus',
    'GatewayStatusAddresses',
    'GatewayStatusAddressesPatch',
    'GatewayStatusConditions',
    'GatewayStatusConditionsPatch',
    'GatewayStatusListeners',
    'GatewayStatusListenersConditions',
    'GatewayStatusListenersConditionsPatch',
    'GatewayStatusListenersPatch',
    'GatewayStatusListenersSupportedKinds',
    'GatewayStatusListenersSupportedKindsPatch',
    'GatewayStatusPatch',
    'HTTPRoute',
    'HTTPRouteSpec',
    'HTTPRouteSpecParentRefs',
    'HTTPRouteSpecParentRefsPatch',
    'HTTPRouteSpecPatch',
    'HTTPRouteSpecRules',
    'HTTPRouteSpecRulesBackendRefs',
    'HTTPRouteSpecRulesBackendRefsFilters',
    'HTTPRouteSpecRulesBackendRefsFiltersExtensionRef',
    'HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirror',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath',
    'HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet',
    'HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath',
    'HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch',
    'HTTPRouteSpecRulesBackendRefsPatch',
    'HTTPRouteSpecRulesFilters',
    'HTTPRouteSpecRulesFiltersExtensionRef',
    'HTTPRouteSpecRulesFiltersExtensionRefPatch',
    'HTTPRouteSpecRulesFiltersPatch',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifier',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierSet',
    'HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch',
    'HTTPRouteSpecRulesFiltersRequestMirror',
    'HTTPRouteSpecRulesFiltersRequestMirrorBackendRef',
    'HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch',
    'HTTPRouteSpecRulesFiltersRequestMirrorPatch',
    'HTTPRouteSpecRulesFiltersRequestRedirect',
    'HTTPRouteSpecRulesFiltersRequestRedirectPatch',
    'HTTPRouteSpecRulesFiltersRequestRedirectPath',
    'HTTPRouteSpecRulesFiltersRequestRedirectPathPatch',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifier',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierSet',
    'HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch',
    'HTTPRouteSpecRulesFiltersUrlRewrite',
    'HTTPRouteSpecRulesFiltersUrlRewritePatch',
    'HTTPRouteSpecRulesFiltersUrlRewritePath',
    'HTTPRouteSpecRulesFiltersUrlRewritePathPatch',
    'HTTPRouteSpecRulesMatches',
    'HTTPRouteSpecRulesMatchesHeaders',
    'HTTPRouteSpecRulesMatchesHeadersPatch',
    'HTTPRouteSpecRulesMatchesPatch',
    'HTTPRouteSpecRulesMatchesPath',
    'HTTPRouteSpecRulesMatchesPathPatch',
    'HTTPRouteSpecRulesMatchesQueryParams',
    'HTTPRouteSpecRulesMatchesQueryParamsPatch',
    'HTTPRouteSpecRulesPatch',
    'HTTPRouteSpecRulesTimeouts',
    'HTTPRouteSpecRulesTimeoutsPatch',
    'HTTPRouteStatus',
    'HTTPRouteStatusParents',
    'HTTPRouteStatusParentsConditions',
    'HTTPRouteStatusParentsConditionsPatch',
    'HTTPRouteStatusParentsParentRef',
    'HTTPRouteStatusParentsParentRefPatch',
    'HTTPRouteStatusParentsPatch',
    'HTTPRouteStatusPatch',
]

@pulumi.output_type
class GRPCRoute(dict):
    """
    GRPCRoute provides a way to route gRPC requests. This includes the capability
    to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
    Filters can be used to specify additional processing steps. Backends specify
    where matching requests will be routed.

    GRPCRoute falls under extended support within the Gateway API. Within the
    following specification, the word "MUST" indicates that an implementation
    supporting GRPCRoute must conform to the indicated requirement, but an
    implementation not supporting this route type need not follow the requirement
    unless explicitly indicated.

    Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
    accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
    ALPN. If the implementation does not support this, then it MUST set the
    "Accepted" condition to "False" for the affected listener with a reason of
    "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
    with an upgrade from HTTP/1.

    Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
    support HTTP/2 over cleartext TCP (h2c,
    https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
    upgrade from HTTP/1.1, i.e. with prior knowledge
    (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
    does not support this, then it MUST set the "Accepted" condition to "False"
    for the affected listener with a reason of "UnsupportedProtocol".
    Implementations MAY also accept HTTP/2 connections with an upgrade from
    HTTP/1, i.e. without prior knowledge.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 kind: Optional[str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.GRPCRouteSpec'] = None,
                 status: Optional['outputs.GRPCRouteStatus'] = None):
        """
        GRPCRoute provides a way to route gRPC requests. This includes the capability
        to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
        Filters can be used to specify additional processing steps. Backends specify
        where matching requests will be routed.

        GRPCRoute falls under extended support within the Gateway API. Within the
        following specification, the word "MUST" indicates that an implementation
        supporting GRPCRoute must conform to the indicated requirement, but an
        implementation not supporting this route type need not follow the requirement
        unless explicitly indicated.

        Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
        accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
        ALPN. If the implementation does not support this, then it MUST set the
        "Accepted" condition to "False" for the affected listener with a reason of
        "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
        with an upgrade from HTTP/1.

        Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
        support HTTP/2 over cleartext TCP (h2c,
        https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
        upgrade from HTTP/1.1, i.e. with prior knowledge
        (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
        does not support this, then it MUST set the "Accepted" condition to "False"
        for the affected listener with a reason of "UnsupportedProtocol".
        Implementations MAY also accept HTTP/2 connections with an upgrade from
        HTTP/1, i.e. without prior knowledge.
        :param str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'GRPCRoute')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GRPCRouteSpec']:
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.GRPCRouteStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class GRPCRouteSpec(dict):
    """
    Spec defines the desired state of GRPCRoute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRefs":
            suggest = "parent_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 parent_refs: Optional[Sequence['outputs.GRPCRouteSpecParentRefs']] = None,
                 rules: Optional[Sequence['outputs.GRPCRouteSpecRules']] = None):
        """
        Spec defines the desired state of GRPCRoute.
        :param Sequence[str] hostnames: Hostnames defines a set of hostnames to match against the GRPC
               Host header to select a GRPCRoute to process the request. This matches
               the RFC 1123 definition of a hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label MUST appear by itself as the first label.
               
               If a hostname is specified by both the Listener and GRPCRoute, there
               MUST be at least one intersecting hostname for the GRPCRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `test.example.com` and `*.example.com` would both match. On the other
                 hand, `example.com` and `test.example.net` would not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and GRPCRoute have specified hostnames, any
               GRPCRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               GRPCRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` MUST NOT be considered for a match.
               
               If both the Listener and GRPCRoute have specified hostnames, and none
               match with the criteria above, then the GRPCRoute MUST NOT be accepted by
               the implementation. The implementation MUST raise an 'Accepted' Condition
               with a status of `False` in the corresponding RouteParentStatus.
               
               If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
               Listener and that listener already has another Route (B) of the other
               type attached and the intersection of the hostnames of A and B is
               non-empty, then the implementation MUST accept exactly one of these two
               routes, determined by the following criteria, in order:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               The rejected Route MUST raise an 'Accepted' condition with a status of
               'False' in the corresponding RouteParentStatus.
               
               Support: Core
        :param Sequence['GRPCRouteSpecParentRefsArgs'] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param Sequence['GRPCRouteSpecRulesArgs'] rules: Rules are a list of GRPC matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        """
        Hostnames defines a set of hostnames to match against the GRPC
        Host header to select a GRPCRoute to process the request. This matches
        the RFC 1123 definition of a hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label MUST appear by itself as the first label.

        If a hostname is specified by both the Listener and GRPCRoute, there
        MUST be at least one intersecting hostname for the GRPCRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `test.example.com` and `*.example.com` would both match. On the other
          hand, `example.com` and `test.example.net` would not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and GRPCRoute have specified hostnames, any
        GRPCRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        GRPCRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` MUST NOT be considered for a match.

        If both the Listener and GRPCRoute have specified hostnames, and none
        match with the criteria above, then the GRPCRoute MUST NOT be accepted by
        the implementation. The implementation MUST raise an 'Accepted' Condition
        with a status of `False` in the corresponding RouteParentStatus.

        If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
        Listener and that listener already has another Route (B) of the other
        type attached and the intersection of the hostnames of A and B is
        non-empty, then the implementation MUST accept exactly one of these two
        routes, determined by the following criteria, in order:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        The rejected Route MUST raise an 'Accepted' condition with a status of
        'False' in the corresponding RouteParentStatus.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[Sequence['outputs.GRPCRouteSpecParentRefs']]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GRPCRouteSpecRules']]:
        """
        Rules are a list of GRPC matchers, filters and actions.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GRPCRouteSpecParentRefs(dict):
    """
    ParentReference identifies an API object (usually a Gateway) that can be considered
    a parent of this resource (usually a route). There are two kinds of parent resources
    with "Core" support:

    * Gateway (Gateway conformance profile)
    * Service (Mesh conformance profile, ClusterIP Services only)

    This API may be extended in the future to support additional kinds of parent
    resources.

    The API object must be valid in the cluster; the Group and Kind must
    be registered in the cluster for this reference to be valid.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecParentRefs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecParentRefs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecParentRefs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class GRPCRouteSpecParentRefsPatch(dict):
    """
    ParentReference identifies an API object (usually a Gateway) that can be considered
    a parent of this resource (usually a route). There are two kinds of parent resources
    with "Core" support:

    * Gateway (Gateway conformance profile)
    * Service (Mesh conformance profile, ClusterIP Services only)

    This API may be extended in the future to support additional kinds of parent
    resources.

    The API object must be valid in the cluster; the Group and Kind must
    be registered in the cluster for this reference to be valid.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecParentRefsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecParentRefsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecParentRefsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class GRPCRouteSpecPatch(dict):
    """
    Spec defines the desired state of GRPCRoute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRefs":
            suggest = "parent_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 parent_refs: Optional[Sequence['outputs.GRPCRouteSpecParentRefsPatch']] = None,
                 rules: Optional[Sequence['outputs.GRPCRouteSpecRulesPatch']] = None):
        """
        Spec defines the desired state of GRPCRoute.
        :param Sequence[str] hostnames: Hostnames defines a set of hostnames to match against the GRPC
               Host header to select a GRPCRoute to process the request. This matches
               the RFC 1123 definition of a hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label MUST appear by itself as the first label.
               
               If a hostname is specified by both the Listener and GRPCRoute, there
               MUST be at least one intersecting hostname for the GRPCRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches GRPCRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `test.example.com` and `*.example.com` would both match. On the other
                 hand, `example.com` and `test.example.net` would not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and GRPCRoute have specified hostnames, any
               GRPCRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               GRPCRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` MUST NOT be considered for a match.
               
               If both the Listener and GRPCRoute have specified hostnames, and none
               match with the criteria above, then the GRPCRoute MUST NOT be accepted by
               the implementation. The implementation MUST raise an 'Accepted' Condition
               with a status of `False` in the corresponding RouteParentStatus.
               
               If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
               Listener and that listener already has another Route (B) of the other
               type attached and the intersection of the hostnames of A and B is
               non-empty, then the implementation MUST accept exactly one of these two
               routes, determined by the following criteria, in order:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               The rejected Route MUST raise an 'Accepted' condition with a status of
               'False' in the corresponding RouteParentStatus.
               
               Support: Core
        :param Sequence['GRPCRouteSpecParentRefsPatchArgs'] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param Sequence['GRPCRouteSpecRulesPatchArgs'] rules: Rules are a list of GRPC matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        """
        Hostnames defines a set of hostnames to match against the GRPC
        Host header to select a GRPCRoute to process the request. This matches
        the RFC 1123 definition of a hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label MUST appear by itself as the first label.

        If a hostname is specified by both the Listener and GRPCRoute, there
        MUST be at least one intersecting hostname for the GRPCRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches GRPCRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `test.example.com` and `*.example.com` would both match. On the other
          hand, `example.com` and `test.example.net` would not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and GRPCRoute have specified hostnames, any
        GRPCRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        GRPCRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` MUST NOT be considered for a match.

        If both the Listener and GRPCRoute have specified hostnames, and none
        match with the criteria above, then the GRPCRoute MUST NOT be accepted by
        the implementation. The implementation MUST raise an 'Accepted' Condition
        with a status of `False` in the corresponding RouteParentStatus.

        If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
        Listener and that listener already has another Route (B) of the other
        type attached and the intersection of the hostnames of A and B is
        non-empty, then the implementation MUST accept exactly one of these two
        routes, determined by the following criteria, in order:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        The rejected Route MUST raise an 'Accepted' condition with a status of
        'False' in the corresponding RouteParentStatus.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[Sequence['outputs.GRPCRouteSpecParentRefsPatch']]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesPatch']]:
        """
        Rules are a list of GRPC matchers, filters and actions.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GRPCRouteSpecRules(dict):
    """
    GRPCRouteRule defines the semantics for matching a gRPC request based on
    conditions (matches), processing it (filters), and forwarding the request to
    an API object (backendRefs).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRefs":
            suggest = "backend_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_refs: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefs']] = None,
                 filters: Optional[Sequence['outputs.GRPCRouteSpecRulesFilters']] = None,
                 matches: Optional[Sequence['outputs.GRPCRouteSpecRulesMatches']] = None):
        """
        GRPCRouteRule defines the semantics for matching a gRPC request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param Sequence['GRPCRouteSpecRulesBackendRefsArgs'] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive an `UNAVAILABLE` status.
               
               See the GRPCBackendRef definition for the rules about what makes a single
               GRPCBackendRef invalid.
               
               When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive an `UNAVAILABLE` status.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
               Implementations may choose how that 50 percent is determined.
               
               Support: Core for Kubernetes Service
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param Sequence['GRPCRouteSpecRulesFiltersArgs'] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               The effects of ordering of multiple behaviors are currently unspecified.
               This can change in the future based on feedback during the alpha stage.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations that support
                 GRPCRoute.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               If an implementation can not support a combination of filters, it must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param Sequence['GRPCRouteSpecRulesMatchesArgs'] matches: Matches define conditions used for matching the rule against incoming
               gRPC requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - method:
                   service: foo.bar
                 headers:
                   values:
                     version: 2
               - method:
                   service: foo.bar.v2
               ```
               
               For a request to match against this rule, it MUST satisfy
               EITHER of the two conditions:
               
               - service of foo.bar AND contains the header `version: 2`
               - service of foo.bar.v2
               
               See the documentation for GRPCRouteMatch on how to specify multiple
               match conditions to be ANDed together.
               
               If no matches are specified, the implementation MUST match every gRPC request.
               
               Proxy or Load Balancer routing configuration generated from GRPCRoutes
               MUST prioritize rules based on the following criteria, continuing on
               ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
               Precedence MUST be given to the rule with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               * Characters in a matching service.
               * Characters in a matching method.
               * Header matches.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within the Route that has been given precedence,
               matching precedence MUST be granted to the first matching rule meeting
               the above criteria.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefs']]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive an `UNAVAILABLE` status.

        See the GRPCBackendRef definition for the rules about what makes a single
        GRPCBackendRef invalid.

        When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive an `UNAVAILABLE` status.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
        Implementations may choose how that 50 percent is determined.

        Support: Core for Kubernetes Service

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFilters']]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        The effects of ordering of multiple behaviors are currently unspecified.
        This can change in the future based on feedback during the alpha stage.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations that support
          GRPCRoute.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        If an implementation can not support a combination of filters, it must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesMatches']]:
        """
        Matches define conditions used for matching the rule against incoming
        gRPC requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - method:
            service: foo.bar
          headers:
            values:
              version: 2
        - method:
            service: foo.bar.v2
        ```

        For a request to match against this rule, it MUST satisfy
        EITHER of the two conditions:

        - service of foo.bar AND contains the header `version: 2`
        - service of foo.bar.v2

        See the documentation for GRPCRouteMatch on how to specify multiple
        match conditions to be ANDed together.

        If no matches are specified, the implementation MUST match every gRPC request.

        Proxy or Load Balancer routing configuration generated from GRPCRoutes
        MUST prioritize rules based on the following criteria, continuing on
        ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
        Precedence MUST be given to the rule with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.
        * Characters in a matching service.
        * Characters in a matching method.
        * Header matches.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within the Route that has been given precedence,
        matching precedence MUST be granted to the first matching rule meeting
        the above criteria.
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefs(dict):
    """
    GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

    Note that when a namespace different than the local namespace is specified, a
    ReferenceGrant object is required in the referent namespace to allow that
    namespace's owner to accept the reference. See the ReferenceGrant
    documentation for details.

    <gateway:experimental:description>

    When the BackendRef points to a Kubernetes Service, implementations SHOULD
    honor the appProtocol field if it is set for the target Service Port.

    Implementations supporting appProtocol SHOULD recognize the Kubernetes
    Standard Application Protocols defined in KEP-3726.

    If a Service appProtocol isn't specified, an implementation MAY infer the
    backend protocol through its own means. Implementations MAY infer the
    protocol from the Route type referring to the backend Service.

    If a Route is not able to send traffic to the backend using the specified
    protocol then the backend is considered invalid. Implementations MUST set the
    "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

    </gateway:experimental:description>
    """
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFilters']] = None,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersArgs'] filters: Filters defined at this level MUST be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in GRPCRouteRule.)
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param int weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFilters']]:
        """
        Filters defined at this level MUST be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in GRPCRouteRule.)
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFilters(dict):
    """
    GRPCRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. GRPCRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesBackendRefsFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesBackendRefsFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesBackendRefsFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersExtensionRef'] = None,
                 request_header_modifier: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier'] = None,
                 request_mirror: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirror'] = None,
                 response_header_modifier: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier'] = None,
                 type: Optional[str] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersExtensionRef']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirror']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersExtensionRef(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    Support: Implementation-specific

    This filter can be used multiple times within the same rule.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    Support: Implementation-specific

    This filter can be used multiple times within the same rule.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersPatch(dict):
    """
    GRPCRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. GRPCRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesBackendRefsFiltersPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesBackendRefsFiltersPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesBackendRefsFiltersPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch'] = None,
                 request_header_modifier: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch'] = None,
                 request_mirror: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch'] = None,
                 response_header_modifier: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch'] = None,
                 type: Optional[str] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPatch']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirror(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesBackendRefsFiltersRequestMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesBackendRefsFiltersRequestMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesBackendRefsFiltersRequestMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesBackendRefsPatch(dict):
    """
    GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

    Note that when a namespace different than the local namespace is specified, a
    ReferenceGrant object is required in the referent namespace to allow that
    namespace's owner to accept the reference. See the ReferenceGrant
    documentation for details.

    <gateway:experimental:description>

    When the BackendRef points to a Kubernetes Service, implementations SHOULD
    honor the appProtocol field if it is set for the target Service Port.

    Implementations supporting appProtocol SHOULD recognize the Kubernetes
    Standard Application Protocols defined in KEP-3726.

    If a Service appProtocol isn't specified, an implementation MAY infer the
    backend protocol through its own means. Implementations MAY infer the
    protocol from the Route type referring to the backend Service.

    If a Route is not able to send traffic to the backend using the specified
    protocol then the backend is considered invalid. Implementations MUST set the
    "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

    </gateway:experimental:description>
    """
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersPatch']] = None,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param Sequence['GRPCRouteSpecRulesBackendRefsFiltersPatchArgs'] filters: Filters defined at this level MUST be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in GRPCRouteRule.)
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param int weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsFiltersPatch']]:
        """
        Filters defined at this level MUST be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in GRPCRouteRule.)
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GRPCRouteSpecRulesFilters(dict):
    """
    GRPCRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. GRPCRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.GRPCRouteSpecRulesFiltersExtensionRef'] = None,
                 request_header_modifier: Optional['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifier'] = None,
                 request_mirror: Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirror'] = None,
                 response_header_modifier: Optional['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifier'] = None,
                 type: Optional[str] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersExtensionRef']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifier']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirror']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifier']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersExtensionRef(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    Support: Implementation-specific

    This filter can be used multiple times within the same rule.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersExtensionRefPatch(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    Support: Implementation-specific

    This filter can be used multiple times within the same rule.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        Support: Implementation-specific

        This filter can be used multiple times within the same rule.
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersPatch(dict):
    """
    GRPCRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. GRPCRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesFiltersPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesFiltersPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesFiltersPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.GRPCRouteSpecRulesFiltersExtensionRefPatch'] = None,
                 request_header_modifier: Optional['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch'] = None,
                 request_mirror: Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirrorPatch'] = None,
                 response_header_modifier: Optional['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch'] = None,
                 type: Optional[str] = None):
        """
        GRPCRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. GRPCRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations supporting GRPCRoute MUST support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` MUST be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersExtensionRefPatch']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirrorPatch']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations supporting GRPCRoute MUST support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` MUST be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifier(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierSet']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierPatch(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestMirror(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesFiltersRequestMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesFiltersRequestMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesFiltersRequestMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirrorBackendRef'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirrorBackendRef']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestMirrorBackendRef(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersRequestMirrorPatch(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesFiltersRequestMirrorPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesFiltersRequestMirrorPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesFiltersRequestMirrorPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPatch']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifier(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierSet']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierPatch(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesFiltersResponseHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesMatches(dict):
    """
    GRPCRouteMatch defines the predicate used to match requests to a given
    action. Multiple match types are ANDed together, i.e. the match will
    evaluate to true only if all conditions are satisfied.

    For example, the match below will match a gRPC request only if its service
    is `foo` AND it contains the `version: v1` header:

    ```
    matches:
      - method:
        type: Exact
        service: "foo"
        headers:
      - name: "version"
        value "v1"

    ```
    """
    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.GRPCRouteSpecRulesMatchesHeaders']] = None,
                 method: Optional['outputs.GRPCRouteSpecRulesMatchesMethod'] = None):
        """
        GRPCRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a gRPC request only if its service
        is `foo` AND it contains the `version: v1` header:

        ```
        matches:
          - method:
            type: Exact
            service: "foo"
            headers:
          - name: "version"
            value "v1"

        ```
        :param Sequence['GRPCRouteSpecRulesMatchesHeadersArgs'] headers: Headers specifies gRPC request header matchers. Multiple match values are
               ANDed together, meaning, a request MUST match all the specified headers
               to select the route.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesMatchesHeaders']]:
        """
        Headers specifies gRPC request header matchers. Multiple match values are
        ANDed together, meaning, a request MUST match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.GRPCRouteSpecRulesMatchesMethod']:
        return pulumi.get(self, "method")


@pulumi.output_type
class GRPCRouteSpecRulesMatchesHeaders(dict):
    """
    GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
    headers.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
        headers.
        :param str name: Name is the name of the gRPC Header to be matched.
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str type: Type specifies how to match against the value of the header.
        :param str value: Value is the value of the gRPC Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the gRPC Header to be matched.

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the value of the header.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of the gRPC Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesMatchesHeadersPatch(dict):
    """
    GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
    headers.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
        headers.
        :param str name: Name is the name of the gRPC Header to be matched.
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str type: Type specifies how to match against the value of the header.
        :param str value: Value is the value of the gRPC Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the gRPC Header to be matched.

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the value of the header.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of the gRPC Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GRPCRouteSpecRulesMatchesMethod(dict):
    """
    Method specifies a gRPC request service/method matcher. If this field is
    not specified, all services and methods will match.
    """
    def __init__(__self__, *,
                 method: Optional[str] = None,
                 service: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Method specifies a gRPC request service/method matcher. If this field is
        not specified, all services and methods will match.
        :param str method: Value of the method to match against. If left empty or omitted, will
               match all services.
               
               At least one of Service and Method MUST be a non-empty string.
        :param str service: Value of the service to match against. If left empty or omitted, will
               match any service.
               
               At least one of Service and Method MUST be a non-empty string.
        :param str type: Type specifies how to match against the service and/or method.
               Support: Core (Exact with service and method specified)
               
               Support: Implementation-specific (Exact with method specified but no service specified)
               
               Support: Implementation-specific (RegularExpression)
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Value of the method to match against. If left empty or omitted, will
        match all services.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Value of the service to match against. If left empty or omitted, will
        match any service.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the service and/or method.
        Support: Core (Exact with service and method specified)

        Support: Implementation-specific (Exact with method specified but no service specified)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteSpecRulesMatchesMethodPatch(dict):
    """
    Method specifies a gRPC request service/method matcher. If this field is
    not specified, all services and methods will match.
    """
    def __init__(__self__, *,
                 method: Optional[str] = None,
                 service: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Method specifies a gRPC request service/method matcher. If this field is
        not specified, all services and methods will match.
        :param str method: Value of the method to match against. If left empty or omitted, will
               match all services.
               
               At least one of Service and Method MUST be a non-empty string.
        :param str service: Value of the service to match against. If left empty or omitted, will
               match any service.
               
               At least one of Service and Method MUST be a non-empty string.
        :param str type: Type specifies how to match against the service and/or method.
               Support: Core (Exact with service and method specified)
               
               Support: Implementation-specific (Exact with method specified but no service specified)
               
               Support: Implementation-specific (RegularExpression)
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Value of the method to match against. If left empty or omitted, will
        match all services.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Value of the service to match against. If left empty or omitted, will
        match any service.

        At least one of Service and Method MUST be a non-empty string.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the service and/or method.
        Support: Core (Exact with service and method specified)

        Support: Implementation-specific (Exact with method specified but no service specified)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteSpecRulesMatchesPatch(dict):
    """
    GRPCRouteMatch defines the predicate used to match requests to a given
    action. Multiple match types are ANDed together, i.e. the match will
    evaluate to true only if all conditions are satisfied.

    For example, the match below will match a gRPC request only if its service
    is `foo` AND it contains the `version: v1` header:

    ```
    matches:
      - method:
        type: Exact
        service: "foo"
        headers:
      - name: "version"
        value "v1"

    ```
    """
    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.GRPCRouteSpecRulesMatchesHeadersPatch']] = None,
                 method: Optional['outputs.GRPCRouteSpecRulesMatchesMethodPatch'] = None):
        """
        GRPCRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a gRPC request only if its service
        is `foo` AND it contains the `version: v1` header:

        ```
        matches:
          - method:
            type: Exact
            service: "foo"
            headers:
          - name: "version"
            value "v1"

        ```
        :param Sequence['GRPCRouteSpecRulesMatchesHeadersPatchArgs'] headers: Headers specifies gRPC request header matchers. Multiple match values are
               ANDed together, meaning, a request MUST match all the specified headers
               to select the route.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesMatchesHeadersPatch']]:
        """
        Headers specifies gRPC request header matchers. Multiple match values are
        ANDed together, meaning, a request MUST match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.GRPCRouteSpecRulesMatchesMethodPatch']:
        return pulumi.get(self, "method")


@pulumi.output_type
class GRPCRouteSpecRulesPatch(dict):
    """
    GRPCRouteRule defines the semantics for matching a gRPC request based on
    conditions (matches), processing it (filters), and forwarding the request to
    an API object (backendRefs).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRefs":
            suggest = "backend_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteSpecRulesPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteSpecRulesPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteSpecRulesPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_refs: Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsPatch']] = None,
                 filters: Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersPatch']] = None,
                 matches: Optional[Sequence['outputs.GRPCRouteSpecRulesMatchesPatch']] = None):
        """
        GRPCRouteRule defines the semantics for matching a gRPC request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param Sequence['GRPCRouteSpecRulesBackendRefsPatchArgs'] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive an `UNAVAILABLE` status.
               
               See the GRPCBackendRef definition for the rules about what makes a single
               GRPCBackendRef invalid.
               
               When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive an `UNAVAILABLE` status.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
               Implementations may choose how that 50 percent is determined.
               
               Support: Core for Kubernetes Service
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param Sequence['GRPCRouteSpecRulesFiltersPatchArgs'] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               The effects of ordering of multiple behaviors are currently unspecified.
               This can change in the future based on feedback during the alpha stage.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations that support
                 GRPCRoute.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               If an implementation can not support a combination of filters, it must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param Sequence['GRPCRouteSpecRulesMatchesPatchArgs'] matches: Matches define conditions used for matching the rule against incoming
               gRPC requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - method:
                   service: foo.bar
                 headers:
                   values:
                     version: 2
               - method:
                   service: foo.bar.v2
               ```
               
               For a request to match against this rule, it MUST satisfy
               EITHER of the two conditions:
               
               - service of foo.bar AND contains the header `version: 2`
               - service of foo.bar.v2
               
               See the documentation for GRPCRouteMatch on how to specify multiple
               match conditions to be ANDed together.
               
               If no matches are specified, the implementation MUST match every gRPC request.
               
               Proxy or Load Balancer routing configuration generated from GRPCRoutes
               MUST prioritize rules based on the following criteria, continuing on
               ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
               Precedence MUST be given to the rule with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               * Characters in a matching service.
               * Characters in a matching method.
               * Header matches.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within the Route that has been given precedence,
               matching precedence MUST be granted to the first matching rule meeting
               the above criteria.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesBackendRefsPatch']]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive an `UNAVAILABLE` status.

        See the GRPCBackendRef definition for the rules about what makes a single
        GRPCBackendRef invalid.

        When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive an `UNAVAILABLE` status.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
        Implementations may choose how that 50 percent is determined.

        Support: Core for Kubernetes Service

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesFiltersPatch']]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        The effects of ordering of multiple behaviors are currently unspecified.
        This can change in the future based on feedback during the alpha stage.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations that support
          GRPCRoute.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        If an implementation can not support a combination of filters, it must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GRPCRouteSpecRulesMatchesPatch']]:
        """
        Matches define conditions used for matching the rule against incoming
        gRPC requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - method:
            service: foo.bar
          headers:
            values:
              version: 2
        - method:
            service: foo.bar.v2
        ```

        For a request to match against this rule, it MUST satisfy
        EITHER of the two conditions:

        - service of foo.bar AND contains the header `version: 2`
        - service of foo.bar.v2

        See the documentation for GRPCRouteMatch on how to specify multiple
        match conditions to be ANDed together.

        If no matches are specified, the implementation MUST match every gRPC request.

        Proxy or Load Balancer routing configuration generated from GRPCRoutes
        MUST prioritize rules based on the following criteria, continuing on
        ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
        Precedence MUST be given to the rule with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.
        * Characters in a matching service.
        * Characters in a matching method.
        * Header matches.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within the Route that has been given precedence,
        matching precedence MUST be granted to the first matching rule meeting
        the above criteria.
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class GRPCRouteStatus(dict):
    """
    Status defines the current state of GRPCRoute.
    """
    def __init__(__self__, *,
                 parents: Optional[Sequence['outputs.GRPCRouteStatusParents']] = None):
        """
        Status defines the current state of GRPCRoute.
        :param Sequence['GRPCRouteStatusParentsArgs'] parents: Parents is a list of parent resources (usually Gateways) that are
               associated with the route, and the status of the route with respect to
               each parent. When this route attaches to a parent, the controller that
               manages the parent must add an entry to this list when the controller
               first sees the route and should update the entry as appropriate when the
               route or gateway is modified.
               
               Note that parent references that cannot be resolved by an implementation
               of this API will not be added to this list. Implementations of this API
               can only populate Route status for the Gateways/parent resources they are
               responsible for.
               
               A maximum of 32 Gateways will be represented in this list. An empty list
               means the route has not been attached to any Gateway.
        """
        if parents is not None:
            pulumi.set(__self__, "parents", parents)

    @property
    @pulumi.getter
    def parents(self) -> Optional[Sequence['outputs.GRPCRouteStatusParents']]:
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
        return pulumi.get(self, "parents")


@pulumi.output_type
class GRPCRouteStatusParents(dict):
    """
    RouteParentStatus describes the status of a route with respect to an
    associated Parent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerName":
            suggest = "controller_name"
        elif key == "parentRef":
            suggest = "parent_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteStatusParents. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteStatusParents.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteStatusParents.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GRPCRouteStatusParentsConditions']] = None,
                 controller_name: Optional[str] = None,
                 parent_ref: Optional['outputs.GRPCRouteStatusParentsParentRef'] = None):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        :param Sequence['GRPCRouteStatusParentsConditionsArgs'] conditions: Conditions describes the status of the route with respect to the Gateway.
               Note that the route's availability is also subject to the Gateway's own
               status conditions and listener status.
               
               If the Route's ParentRef specifies an existing Gateway that supports
               Routes of this kind AND that Gateway's controller has sufficient access,
               then that Gateway's controller MUST set the "Accepted" condition on the
               Route, to indicate whether the route has been accepted or rejected by the
               Gateway, and why.
               
               A Route MUST be considered "Accepted" if at least one of the Route's
               rules is implemented by the Gateway.
               
               There are a number of cases where the "Accepted" condition may not be set
               due to lack of controller visibility, that includes when:
               
               * The Route refers to a non-existent parent.
               * The Route is of a type that the controller does not support.
               * The Route is in a namespace the controller does not have access to.
        :param str controller_name: ControllerName is a domain/path string that indicates the name of the
               controller that wrote this status. This corresponds with the
               controllerName field on GatewayClass.
               
               Example: "example.net/gateway-controller".
               
               The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
               valid Kubernetes names
               (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
               
               Controllers MUST populate this field when writing status. Controllers should ensure that
               entries to status populated with their ControllerName are cleaned up when they are no
               longer necessary.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if parent_ref is not None:
            pulumi.set(__self__, "parent_ref", parent_ref)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GRPCRouteStatusParentsConditions']]:
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[str]:
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        return pulumi.get(self, "controller_name")

    @property
    @pulumi.getter(name="parentRef")
    def parent_ref(self) -> Optional['outputs.GRPCRouteStatusParentsParentRef']:
        return pulumi.get(self, "parent_ref")


@pulumi.output_type
class GRPCRouteStatusParentsConditions(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteStatusParentsConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteStatusParentsConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteStatusParentsConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteStatusParentsConditionsPatch(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteStatusParentsConditionsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteStatusParentsConditionsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteStatusParentsConditionsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GRPCRouteStatusParentsParentRef(dict):
    """
    ParentRef corresponds with a ParentRef in the spec that this
    RouteParentStatus struct describes the status of.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteStatusParentsParentRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteStatusParentsParentRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteStatusParentsParentRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class GRPCRouteStatusParentsParentRefPatch(dict):
    """
    ParentRef corresponds with a ParentRef in the spec that this
    RouteParentStatus struct describes the status of.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteStatusParentsParentRefPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteStatusParentsParentRefPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteStatusParentsParentRefPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class GRPCRouteStatusParentsPatch(dict):
    """
    RouteParentStatus describes the status of a route with respect to an
    associated Parent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerName":
            suggest = "controller_name"
        elif key == "parentRef":
            suggest = "parent_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GRPCRouteStatusParentsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GRPCRouteStatusParentsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GRPCRouteStatusParentsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GRPCRouteStatusParentsConditionsPatch']] = None,
                 controller_name: Optional[str] = None,
                 parent_ref: Optional['outputs.GRPCRouteStatusParentsParentRefPatch'] = None):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        :param Sequence['GRPCRouteStatusParentsConditionsPatchArgs'] conditions: Conditions describes the status of the route with respect to the Gateway.
               Note that the route's availability is also subject to the Gateway's own
               status conditions and listener status.
               
               If the Route's ParentRef specifies an existing Gateway that supports
               Routes of this kind AND that Gateway's controller has sufficient access,
               then that Gateway's controller MUST set the "Accepted" condition on the
               Route, to indicate whether the route has been accepted or rejected by the
               Gateway, and why.
               
               A Route MUST be considered "Accepted" if at least one of the Route's
               rules is implemented by the Gateway.
               
               There are a number of cases where the "Accepted" condition may not be set
               due to lack of controller visibility, that includes when:
               
               * The Route refers to a non-existent parent.
               * The Route is of a type that the controller does not support.
               * The Route is in a namespace the controller does not have access to.
        :param str controller_name: ControllerName is a domain/path string that indicates the name of the
               controller that wrote this status. This corresponds with the
               controllerName field on GatewayClass.
               
               Example: "example.net/gateway-controller".
               
               The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
               valid Kubernetes names
               (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
               
               Controllers MUST populate this field when writing status. Controllers should ensure that
               entries to status populated with their ControllerName are cleaned up when they are no
               longer necessary.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if parent_ref is not None:
            pulumi.set(__self__, "parent_ref", parent_ref)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GRPCRouteStatusParentsConditionsPatch']]:
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[str]:
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        return pulumi.get(self, "controller_name")

    @property
    @pulumi.getter(name="parentRef")
    def parent_ref(self) -> Optional['outputs.GRPCRouteStatusParentsParentRefPatch']:
        return pulumi.get(self, "parent_ref")


@pulumi.output_type
class GRPCRouteStatusPatch(dict):
    """
    Status defines the current state of GRPCRoute.
    """
    def __init__(__self__, *,
                 parents: Optional[Sequence['outputs.GRPCRouteStatusParentsPatch']] = None):
        """
        Status defines the current state of GRPCRoute.
        :param Sequence['GRPCRouteStatusParentsPatchArgs'] parents: Parents is a list of parent resources (usually Gateways) that are
               associated with the route, and the status of the route with respect to
               each parent. When this route attaches to a parent, the controller that
               manages the parent must add an entry to this list when the controller
               first sees the route and should update the entry as appropriate when the
               route or gateway is modified.
               
               Note that parent references that cannot be resolved by an implementation
               of this API will not be added to this list. Implementations of this API
               can only populate Route status for the Gateways/parent resources they are
               responsible for.
               
               A maximum of 32 Gateways will be represented in this list. An empty list
               means the route has not been attached to any Gateway.
        """
        if parents is not None:
            pulumi.set(__self__, "parents", parents)

    @property
    @pulumi.getter
    def parents(self) -> Optional[Sequence['outputs.GRPCRouteStatusParentsPatch']]:
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
        return pulumi.get(self, "parents")


@pulumi.output_type
class Gateway(dict):
    """
    Gateway represents an instance of a service-traffic handling infrastructure
    by binding Listeners to a set of IP addresses.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Gateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Gateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Gateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 kind: Optional[str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.GatewaySpec'] = None,
                 status: Optional['outputs.GatewayStatus'] = None):
        """
        Gateway represents an instance of a service-traffic handling infrastructure
        by binding Listeners to a set of IP addresses.
        :param str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'Gateway')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GatewaySpec']:
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.GatewayStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class GatewayClass(dict):
    """
    GatewayClass describes a class of Gateways available to the user for creating
    Gateway resources.

    It is recommended that this resource be used as a template for Gateways. This
    means that a Gateway is based on the state of the GatewayClass at the time it
    was created and changes to the GatewayClass or associated parameters are not
    propagated down to existing Gateways. This recommendation is intended to
    limit the blast radius of changes to GatewayClass or associated parameters.
    If implementations choose to propagate GatewayClass changes to existing
    Gateways, that MUST be clearly documented by the implementation.

    Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
    add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
    associated GatewayClass. This ensures that a GatewayClass associated with a
    Gateway is not deleted while in use.

    GatewayClass is a Cluster level resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 kind: Optional[str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.GatewayClassSpec'] = None,
                 status: Optional['outputs.GatewayClassStatus'] = None):
        """
        GatewayClass describes a class of Gateways available to the user for creating
        Gateway resources.

        It is recommended that this resource be used as a template for Gateways. This
        means that a Gateway is based on the state of the GatewayClass at the time it
        was created and changes to the GatewayClass or associated parameters are not
        propagated down to existing Gateways. This recommendation is intended to
        limit the blast radius of changes to GatewayClass or associated parameters.
        If implementations choose to propagate GatewayClass changes to existing
        Gateways, that MUST be clearly documented by the implementation.

        Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
        add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
        associated GatewayClass. This ensures that a GatewayClass associated with a
        Gateway is not deleted while in use.

        GatewayClass is a Cluster level resource.
        :param str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'GatewayClass')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GatewayClassSpec']:
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.GatewayClassStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class GatewayClassSpec(dict):
    """
    Spec defines the desired state of GatewayClass.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerName":
            suggest = "controller_name"
        elif key == "parametersRef":
            suggest = "parameters_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayClassSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayClassSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayClassSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 controller_name: Optional[str] = None,
                 description: Optional[str] = None,
                 parameters_ref: Optional['outputs.GatewayClassSpecParametersRef'] = None):
        """
        Spec defines the desired state of GatewayClass.
        :param str controller_name: ControllerName is the name of the controller that is managing Gateways of
               this class. The value of this field MUST be a domain prefixed path.
               
               Example: "example.net/gateway-controller".
               
               This field is not mutable and cannot be empty.
               
               Support: Core
        :param str description: Description helps describe a GatewayClass with more details.
        """
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[str]:
        """
        ControllerName is the name of the controller that is managing Gateways of
        this class. The value of this field MUST be a domain prefixed path.

        Example: "example.net/gateway-controller".

        This field is not mutable and cannot be empty.

        Support: Core
        """
        return pulumi.get(self, "controller_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description helps describe a GatewayClass with more details.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional['outputs.GatewayClassSpecParametersRef']:
        return pulumi.get(self, "parameters_ref")


@pulumi.output_type
class GatewayClassSpecParametersRef(dict):
    """
    ParametersRef is a reference to a resource that contains the configuration
    parameters corresponding to the GatewayClass. This is optional if the
    controller does not require any additional configuration.

    ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
    or an implementation-specific custom resource. The resource can be
    cluster-scoped or namespace-scoped.

    If the referent cannot be found, refers to an unsupported kind, or when
    the data within that resource is malformed, the GatewayClass SHOULD be
    rejected with the "Accepted" status condition set to "False" and an
    "InvalidParameters" reason.

    A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
    the merging behavior is implementation specific.
    It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the GatewayClass. This is optional if the
        controller does not require any additional configuration.

        ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
        or an implementation-specific custom resource. The resource can be
        cluster-scoped or namespace-scoped.

        If the referent cannot be found, refers to an unsupported kind, or when
        the data within that resource is malformed, the GatewayClass SHOULD be
        rejected with the "Accepted" status condition set to "False" and an
        "InvalidParameters" reason.

        A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param str group: Group is the group of the referent.
        :param str kind: Kind is kind of the referent.
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the referent.
               This field is required when referring to a Namespace-scoped resource and
               MUST be unset when referring to a Cluster-scoped resource.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent.
        This field is required when referring to a Namespace-scoped resource and
        MUST be unset when referring to a Cluster-scoped resource.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GatewayClassSpecParametersRefPatch(dict):
    """
    ParametersRef is a reference to a resource that contains the configuration
    parameters corresponding to the GatewayClass. This is optional if the
    controller does not require any additional configuration.

    ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
    or an implementation-specific custom resource. The resource can be
    cluster-scoped or namespace-scoped.

    If the referent cannot be found, refers to an unsupported kind, or when
    the data within that resource is malformed, the GatewayClass SHOULD be
    rejected with the "Accepted" status condition set to "False" and an
    "InvalidParameters" reason.

    A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
    the merging behavior is implementation specific.
    It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the GatewayClass. This is optional if the
        controller does not require any additional configuration.

        ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
        or an implementation-specific custom resource. The resource can be
        cluster-scoped or namespace-scoped.

        If the referent cannot be found, refers to an unsupported kind, or when
        the data within that resource is malformed, the GatewayClass SHOULD be
        rejected with the "Accepted" status condition set to "False" and an
        "InvalidParameters" reason.

        A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param str group: Group is the group of the referent.
        :param str kind: Kind is kind of the referent.
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the referent.
               This field is required when referring to a Namespace-scoped resource and
               MUST be unset when referring to a Cluster-scoped resource.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent.
        This field is required when referring to a Namespace-scoped resource and
        MUST be unset when referring to a Cluster-scoped resource.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GatewayClassSpecPatch(dict):
    """
    Spec defines the desired state of GatewayClass.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerName":
            suggest = "controller_name"
        elif key == "parametersRef":
            suggest = "parameters_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayClassSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayClassSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayClassSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 controller_name: Optional[str] = None,
                 description: Optional[str] = None,
                 parameters_ref: Optional['outputs.GatewayClassSpecParametersRefPatch'] = None):
        """
        Spec defines the desired state of GatewayClass.
        :param str controller_name: ControllerName is the name of the controller that is managing Gateways of
               this class. The value of this field MUST be a domain prefixed path.
               
               Example: "example.net/gateway-controller".
               
               This field is not mutable and cannot be empty.
               
               Support: Core
        :param str description: Description helps describe a GatewayClass with more details.
        """
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[str]:
        """
        ControllerName is the name of the controller that is managing Gateways of
        this class. The value of this field MUST be a domain prefixed path.

        Example: "example.net/gateway-controller".

        This field is not mutable and cannot be empty.

        Support: Core
        """
        return pulumi.get(self, "controller_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description helps describe a GatewayClass with more details.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional['outputs.GatewayClassSpecParametersRefPatch']:
        return pulumi.get(self, "parameters_ref")


@pulumi.output_type
class GatewayClassStatus(dict):
    """
    Status defines the current state of GatewayClass.

    Implementations MUST populate status on all GatewayClass resources which
    specify their controller name.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GatewayClassStatusConditions']] = None):
        """
        Status defines the current state of GatewayClass.

        Implementations MUST populate status on all GatewayClass resources which
        specify their controller name.
        :param Sequence['GatewayClassStatusConditionsArgs'] conditions: Conditions is the current status from the controller for
               this GatewayClass.
               
               Controllers should prefer to publish conditions using values
               of GatewayClassConditionType for the type of each Condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GatewayClassStatusConditions']]:
        """
        Conditions is the current status from the controller for
        this GatewayClass.

        Controllers should prefer to publish conditions using values
        of GatewayClassConditionType for the type of each Condition.
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class GatewayClassStatusConditions(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayClassStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayClassStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayClassStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayClassStatusConditionsPatch(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayClassStatusConditionsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayClassStatusConditionsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayClassStatusConditionsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayClassStatusPatch(dict):
    """
    Status defines the current state of GatewayClass.

    Implementations MUST populate status on all GatewayClass resources which
    specify their controller name.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GatewayClassStatusConditionsPatch']] = None):
        """
        Status defines the current state of GatewayClass.

        Implementations MUST populate status on all GatewayClass resources which
        specify their controller name.
        :param Sequence['GatewayClassStatusConditionsPatchArgs'] conditions: Conditions is the current status from the controller for
               this GatewayClass.
               
               Controllers should prefer to publish conditions using values
               of GatewayClassConditionType for the type of each Condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GatewayClassStatusConditionsPatch']]:
        """
        Conditions is the current status from the controller for
        this GatewayClass.

        Controllers should prefer to publish conditions using values
        of GatewayClassConditionType for the type of each Condition.
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class GatewaySpec(dict):
    """
    Spec defines the desired state of Gateway.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayClassName":
            suggest = "gateway_class_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.GatewaySpecAddresses']] = None,
                 gateway_class_name: Optional[str] = None,
                 infrastructure: Optional['outputs.GatewaySpecInfrastructure'] = None,
                 listeners: Optional[Sequence['outputs.GatewaySpecListeners']] = None):
        """
        Spec defines the desired state of Gateway.
        :param Sequence['GatewaySpecAddressesArgs'] addresses: Addresses requested for this Gateway. This is optional and behavior can
               depend on the implementation. If a value is set in the spec and the
               requested address is invalid or unavailable, the implementation MUST
               indicate this in the associated entry in GatewayStatus.Addresses.
               
               The Addresses field represents a request for the address(es) on the
               "outside of the Gateway", that traffic bound for this Gateway will use.
               This could be the IP address or hostname of an external load balancer or
               other networking infrastructure, or some other address that traffic will
               be sent to.
               
               If no Addresses are specified, the implementation MAY schedule the
               Gateway in an implementation-specific manner, assigning an appropriate
               set of Addresses.
               
               The implementation MUST bind all Listeners to every GatewayAddress that
               it assigns to the Gateway and add a corresponding entry in
               GatewayStatus.Addresses.
               
               Support: Extended
        :param str gateway_class_name: GatewayClassName used for this Gateway. This is the name of a
               GatewayClass resource.
        :param Sequence['GatewaySpecListenersArgs'] listeners: Listeners associated with this Gateway. Listeners define
               logical endpoints that are bound on this Gateway's addresses.
               At least one Listener MUST be specified.
               
               Each Listener in a set of Listeners (for example, in a single Gateway)
               MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
               exactly one listener. (This section uses "set of Listeners" rather than
               "Listeners in a single Gateway" because implementations MAY merge configuration
               from multiple Gateways onto a single data plane, and these rules _also_
               apply in that case).
               
               Practically, this means that each listener in a set MUST have a unique
               combination of Port, Protocol, and, if supported by the protocol, Hostname.
               
               Some combinations of port, protocol, and TLS settings are considered
               Core support and MUST be supported by implementations based on their
               targeted conformance profile:
               
               HTTP Profile
               
               1. HTTPRoute, Port: 80, Protocol: HTTP
               2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
               
               TLS Profile
               
               1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
               
               "Distinct" Listeners have the following property:
               
               The implementation can match inbound requests to a single distinct
               Listener. When multiple Listeners share values for fields (for
               example, two Listeners with the same Port value), the implementation
               can match requests to only one of the Listeners using other
               Listener fields.
               
               For example, the following Listener scenarios are distinct:
               
               1. Multiple Listeners with the same Port that all use the "HTTP"
                  Protocol that all have unique Hostname values.
               2. Multiple Listeners with the same Port that use either the "HTTPS" or
                  "TLS" Protocol that all have unique Hostname values.
               3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
                  with the same Protocol has the same Port value.
               
               Some fields in the Listener struct have possible values that affect
               whether the Listener is distinct. Hostname is particularly relevant
               for HTTP or HTTPS protocols.
               
               When using the Hostname value to select between same-Port, same-Protocol
               Listeners, the Hostname value must be different on each Listener for the
               Listener to be distinct.
               
               When the Listeners are distinct based on Hostname, inbound request
               hostnames MUST match from the most specific to least specific Hostname
               values to choose the correct Listener and its associated set of Routes.
               
               Exact matches must be processed before wildcard matches, and wildcard
               matches must be processed before fallback (empty Hostname value)
               matches. For example, `"foo.example.com"` takes precedence over
               `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
               
               Additionally, if there are multiple wildcard entries, more specific
               wildcard entries must be processed before less specific wildcard entries.
               For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
               The precise definition here is that the higher the number of dots in the
               hostname to the right of the wildcard character, the higher the precedence.
               
               The wildcard character will match any number of characters _and dots_ to
               the left, however, so `"*.example.com"` will match both
               `"foo.bar.example.com"` _and_ `"bar.example.com"`.
               
               If a set of Listeners contains Listeners that are not distinct, then those
               Listeners are Conflicted, and the implementation MUST set the "Conflicted"
               condition in the Listener Status to "True".
               
               Implementations MAY choose to accept a Gateway with some Conflicted
               Listeners only if they only accept the partial Listener set that contains
               no Conflicted Listeners. To put this another way, implementations may
               accept a partial Listener set only if they throw out *all* the conflicting
               Listeners. No picking one of the conflicting listeners as the winner.
               This also means that the Gateway must have at least one non-conflicting
               Listener in this case, otherwise it violates the requirement that at
               least one Listener must be present.
               
               The implementation MUST set a "ListenersNotValid" condition on the
               Gateway Status when the Gateway contains Conflicted Listeners whether or
               not they accept the Gateway. That Condition SHOULD clearly
               indicate in the Message which Listeners are conflicted, and which are
               Accepted. Additionally, the Listener status for those listeners SHOULD
               indicate which Listeners are conflicted and not Accepted.
               
               A Gateway's Listeners are considered "compatible" if:
               
               1. They are distinct.
               2. The implementation can serve them in compliance with the Addresses
                  requirement that all Listeners are available on all assigned
                  addresses.
               
               Compatible combinations in Extended support are expected to vary across
               implementations. A combination that is compatible for one implementation
               may not be compatible for another.
               
               For example, an implementation that cannot serve both TCP and UDP listeners
               on the same address, or cannot mix HTTPS and generic TLS listens on the same port
               would not consider those cases compatible, even though they are distinct.
               
               Note that requests SHOULD match at most one Listener. For example, if
               Listeners are defined for "foo.example.com" and "*.example.com", a
               request to "foo.example.com" SHOULD only be routed using routes attached
               to the "foo.example.com" Listener (and not the "*.example.com" Listener).
               This concept is known as "Listener Isolation". Implementations that do
               not support Listener Isolation MUST clearly document this.
               
               Implementations MAY merge separate Gateways onto a single set of
               Addresses if all Listeners across all Gateways are compatible.
               
               Support: Core
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if gateway_class_name is not None:
            pulumi.set(__self__, "gateway_class_name", gateway_class_name)
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.GatewaySpecAddresses']]:
        """
        Addresses requested for this Gateway. This is optional and behavior can
        depend on the implementation. If a value is set in the spec and the
        requested address is invalid or unavailable, the implementation MUST
        indicate this in the associated entry in GatewayStatus.Addresses.

        The Addresses field represents a request for the address(es) on the
        "outside of the Gateway", that traffic bound for this Gateway will use.
        This could be the IP address or hostname of an external load balancer or
        other networking infrastructure, or some other address that traffic will
        be sent to.

        If no Addresses are specified, the implementation MAY schedule the
        Gateway in an implementation-specific manner, assigning an appropriate
        set of Addresses.

        The implementation MUST bind all Listeners to every GatewayAddress that
        it assigns to the Gateway and add a corresponding entry in
        GatewayStatus.Addresses.

        Support: Extended
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="gatewayClassName")
    def gateway_class_name(self) -> Optional[str]:
        """
        GatewayClassName used for this Gateway. This is the name of a
        GatewayClass resource.
        """
        return pulumi.get(self, "gateway_class_name")

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional['outputs.GatewaySpecInfrastructure']:
        return pulumi.get(self, "infrastructure")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.GatewaySpecListeners']]:
        """
        Listeners associated with this Gateway. Listeners define
        logical endpoints that are bound on this Gateway's addresses.
        At least one Listener MUST be specified.

        Each Listener in a set of Listeners (for example, in a single Gateway)
        MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
        exactly one listener. (This section uses "set of Listeners" rather than
        "Listeners in a single Gateway" because implementations MAY merge configuration
        from multiple Gateways onto a single data plane, and these rules _also_
        apply in that case).

        Practically, this means that each listener in a set MUST have a unique
        combination of Port, Protocol, and, if supported by the protocol, Hostname.

        Some combinations of port, protocol, and TLS settings are considered
        Core support and MUST be supported by implementations based on their
        targeted conformance profile:

        HTTP Profile

        1. HTTPRoute, Port: 80, Protocol: HTTP
        2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided

        TLS Profile

        1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough

        "Distinct" Listeners have the following property:

        The implementation can match inbound requests to a single distinct
        Listener. When multiple Listeners share values for fields (for
        example, two Listeners with the same Port value), the implementation
        can match requests to only one of the Listeners using other
        Listener fields.

        For example, the following Listener scenarios are distinct:

        1. Multiple Listeners with the same Port that all use the "HTTP"
           Protocol that all have unique Hostname values.
        2. Multiple Listeners with the same Port that use either the "HTTPS" or
           "TLS" Protocol that all have unique Hostname values.
        3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
           with the same Protocol has the same Port value.

        Some fields in the Listener struct have possible values that affect
        whether the Listener is distinct. Hostname is particularly relevant
        for HTTP or HTTPS protocols.

        When using the Hostname value to select between same-Port, same-Protocol
        Listeners, the Hostname value must be different on each Listener for the
        Listener to be distinct.

        When the Listeners are distinct based on Hostname, inbound request
        hostnames MUST match from the most specific to least specific Hostname
        values to choose the correct Listener and its associated set of Routes.

        Exact matches must be processed before wildcard matches, and wildcard
        matches must be processed before fallback (empty Hostname value)
        matches. For example, `"foo.example.com"` takes precedence over
        `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.

        Additionally, if there are multiple wildcard entries, more specific
        wildcard entries must be processed before less specific wildcard entries.
        For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
        The precise definition here is that the higher the number of dots in the
        hostname to the right of the wildcard character, the higher the precedence.

        The wildcard character will match any number of characters _and dots_ to
        the left, however, so `"*.example.com"` will match both
        `"foo.bar.example.com"` _and_ `"bar.example.com"`.

        If a set of Listeners contains Listeners that are not distinct, then those
        Listeners are Conflicted, and the implementation MUST set the "Conflicted"
        condition in the Listener Status to "True".

        Implementations MAY choose to accept a Gateway with some Conflicted
        Listeners only if they only accept the partial Listener set that contains
        no Conflicted Listeners. To put this another way, implementations may
        accept a partial Listener set only if they throw out *all* the conflicting
        Listeners. No picking one of the conflicting listeners as the winner.
        This also means that the Gateway must have at least one non-conflicting
        Listener in this case, otherwise it violates the requirement that at
        least one Listener must be present.

        The implementation MUST set a "ListenersNotValid" condition on the
        Gateway Status when the Gateway contains Conflicted Listeners whether or
        not they accept the Gateway. That Condition SHOULD clearly
        indicate in the Message which Listeners are conflicted, and which are
        Accepted. Additionally, the Listener status for those listeners SHOULD
        indicate which Listeners are conflicted and not Accepted.

        A Gateway's Listeners are considered "compatible" if:

        1. They are distinct.
        2. The implementation can serve them in compliance with the Addresses
           requirement that all Listeners are available on all assigned
           addresses.

        Compatible combinations in Extended support are expected to vary across
        implementations. A combination that is compatible for one implementation
        may not be compatible for another.

        For example, an implementation that cannot serve both TCP and UDP listeners
        on the same address, or cannot mix HTTPS and generic TLS listens on the same port
        would not consider those cases compatible, even though they are distinct.

        Note that requests SHOULD match at most one Listener. For example, if
        Listeners are defined for "foo.example.com" and "*.example.com", a
        request to "foo.example.com" SHOULD only be routed using routes attached
        to the "foo.example.com" Listener (and not the "*.example.com" Listener).
        This concept is known as "Listener Isolation". Implementations that do
        not support Listener Isolation MUST clearly document this.

        Implementations MAY merge separate Gateways onto a single set of
        Addresses if all Listeners across all Gateways are compatible.

        Support: Core
        """
        return pulumi.get(self, "listeners")


@pulumi.output_type
class GatewaySpecAddresses(dict):
    """
    GatewayAddress describes an address that can be bound to a Gateway.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        GatewayAddress describes an address that can be bound to a Gateway.
        :param str type: Type of the address.
        :param str value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewaySpecAddressesPatch(dict):
    """
    GatewayAddress describes an address that can be bound to a Gateway.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        GatewayAddress describes an address that can be bound to a Gateway.
        :param str type: Type of the address.
        :param str value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewaySpecInfrastructure(dict):
    """
    Infrastructure defines infrastructure level attributes about this Gateway instance.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parametersRef":
            suggest = "parameters_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecInfrastructure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecInfrastructure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecInfrastructure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 parameters_ref: Optional['outputs.GatewaySpecInfrastructureParametersRef'] = None):
        """
        Infrastructure defines infrastructure level attributes about this Gateway instance.

        Support: Extended
        :param Mapping[str, str] annotations: Annotations that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
               
               An implementation may chose to add additional implementation-specific annotations as they see fit.
               
               Support: Extended
        :param Mapping[str, str] labels: Labels that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
               
               An implementation may chose to add additional implementation-specific labels as they see fit.
               
               If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
               change, it SHOULD clearly warn about this behavior in documentation.
               
               Support: Extended
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.

        An implementation may chose to add additional implementation-specific annotations as they see fit.

        Support: Extended
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "labels" concepts.

        An implementation may chose to add additional implementation-specific labels as they see fit.

        If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
        change, it SHOULD clearly warn about this behavior in documentation.

        Support: Extended
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional['outputs.GatewaySpecInfrastructureParametersRef']:
        return pulumi.get(self, "parameters_ref")


@pulumi.output_type
class GatewaySpecInfrastructureParametersRef(dict):
    """
    ParametersRef is a reference to a resource that contains the configuration
    parameters corresponding to the Gateway. This is optional if the
    controller does not require any additional configuration.

    This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

    The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
    the merging behavior is implementation specific.
    It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the Gateway. This is optional if the
        controller does not require any additional configuration.

        This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

        The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param str group: Group is the group of the referent.
        :param str kind: Kind is kind of the referent.
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewaySpecInfrastructureParametersRefPatch(dict):
    """
    ParametersRef is a reference to a resource that contains the configuration
    parameters corresponding to the Gateway. This is optional if the
    controller does not require any additional configuration.

    This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

    The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
    the merging behavior is implementation specific.
    It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ParametersRef is a reference to a resource that contains the configuration
        parameters corresponding to the Gateway. This is optional if the
        controller does not require any additional configuration.

        This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis

        The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
        the merging behavior is implementation specific.
        It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.

        Support: Implementation-specific
        :param str group: Group is the group of the referent.
        :param str kind: Kind is kind of the referent.
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewaySpecInfrastructurePatch(dict):
    """
    Infrastructure defines infrastructure level attributes about this Gateway instance.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parametersRef":
            suggest = "parameters_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecInfrastructurePatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecInfrastructurePatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecInfrastructurePatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 parameters_ref: Optional['outputs.GatewaySpecInfrastructureParametersRefPatch'] = None):
        """
        Infrastructure defines infrastructure level attributes about this Gateway instance.

        Support: Extended
        :param Mapping[str, str] annotations: Annotations that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
               
               An implementation may chose to add additional implementation-specific annotations as they see fit.
               
               Support: Extended
        :param Mapping[str, str] labels: Labels that SHOULD be applied to any resources created in response to this Gateway.
               
               For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
               For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
               
               An implementation may chose to add additional implementation-specific labels as they see fit.
               
               If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
               change, it SHOULD clearly warn about this behavior in documentation.
               
               Support: Extended
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if parameters_ref is not None:
            pulumi.set(__self__, "parameters_ref", parameters_ref)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.

        An implementation may chose to add additional implementation-specific annotations as they see fit.

        Support: Extended
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels that SHOULD be applied to any resources created in response to this Gateway.

        For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
        For other implementations, this refers to any relevant (implementation specific) "labels" concepts.

        An implementation may chose to add additional implementation-specific labels as they see fit.

        If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
        change, it SHOULD clearly warn about this behavior in documentation.

        Support: Extended
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="parametersRef")
    def parameters_ref(self) -> Optional['outputs.GatewaySpecInfrastructureParametersRefPatch']:
        return pulumi.get(self, "parameters_ref")


@pulumi.output_type
class GatewaySpecListeners(dict):
    """
    Listener embodies the concept of a logical endpoint where a Gateway accepts
    network connections.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRoutes":
            suggest = "allowed_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListeners. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListeners.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListeners.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_routes: Optional['outputs.GatewaySpecListenersAllowedRoutes'] = None,
                 hostname: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 tls: Optional['outputs.GatewaySpecListenersTls'] = None):
        """
        Listener embodies the concept of a logical endpoint where a Gateway accepts
        network connections.
        :param str hostname: Hostname specifies the virtual hostname to match for protocol types that
               define this concept. When unspecified, all hostnames are matched. This
               field is ignored for protocols that don't require hostname based
               matching.
               
               Implementations MUST apply Hostname matching appropriately for each of
               the following protocols:
               
               * TLS: The Listener Hostname MUST match the SNI.
               * HTTP: The Listener Hostname MUST match the Host header of the request.
               * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
                 protocol layers as described above. If an implementation does not
                 ensure that both the SNI and Host header match the Listener hostname,
                 it MUST clearly document that.
               
               For HTTPRoute and TLSRoute resources, there is an interaction with the
               `spec.hostnames` array. When both listener and route specify hostnames,
               there MUST be an intersection between the values for a Route to be
               accepted. For more information, refer to the Route specific Hostnames
               documentation.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               Support: Core
        :param str name: Name is the name of the Listener. This name MUST be unique within a
               Gateway.
               
               Support: Core
        :param int port: Port is the network port. Multiple listeners may use the
               same port, subject to the Listener compatibility rules.
               
               Support: Core
        :param str protocol: Protocol specifies the network protocol this listener expects to receive.
               
               Support: Core
        """
        if allowed_routes is not None:
            pulumi.set(__self__, "allowed_routes", allowed_routes)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="allowedRoutes")
    def allowed_routes(self) -> Optional['outputs.GatewaySpecListenersAllowedRoutes']:
        return pulumi.get(self, "allowed_routes")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname specifies the virtual hostname to match for protocol types that
        define this concept. When unspecified, all hostnames are matched. This
        field is ignored for protocols that don't require hostname based
        matching.

        Implementations MUST apply Hostname matching appropriately for each of
        the following protocols:

        * TLS: The Listener Hostname MUST match the SNI.
        * HTTP: The Listener Hostname MUST match the Host header of the request.
        * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
          protocol layers as described above. If an implementation does not
          ensure that both the SNI and Host header match the Listener hostname,
          it MUST clearly document that.

        For HTTPRoute and TLSRoute resources, there is an interaction with the
        `spec.hostnames` array. When both listener and route specify hostnames,
        there MUST be an intersection between the values for a Route to be
        accepted. For more information, refer to the Route specific Hostnames
        documentation.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the Listener. This name MUST be unique within a
        Gateway.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port. Multiple listeners may use the
        same port, subject to the Listener compatibility rules.

        Support: Core
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol specifies the network protocol this listener expects to receive.

        Support: Core
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.GatewaySpecListenersTls']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutes(dict):
    """
    AllowedRoutes defines the types of routes that MAY be attached to a
    Listener and the trusted namespaces where those Route resources MAY be
    present.

    Although a client request may match multiple route rules, only one rule
    may ultimately receive the request. Matching precedence MUST be
    determined in order of the following criteria:

    * The most specific match as defined by the Route type.
    * The oldest Route based on creation timestamp. For example, a Route with
      a creation timestamp of "2020-09-08 01:02:03" is given precedence over
      a Route with a creation timestamp of "2020-09-08 01:02:04".
    * If everything else is equivalent, the Route appearing first in
      alphabetical order (namespace/name) should be given precedence. For
      example, foo/bar is given precedence over foo/baz.

    All valid rules within a Route attached to this Listener should be
    implemented. Invalid Route rules can be ignored (sometimes that will mean
    the full Route). If a Route rule transitions from valid to invalid,
    support for that Route rule should be dropped to ensure consistency. For
    example, even if a filter specified by a Route rule is invalid, the rest
    of the rules within that Route should still be supported.

    Support: Core
    """
    def __init__(__self__, *,
                 kinds: Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesKinds']] = None,
                 namespaces: Optional['outputs.GatewaySpecListenersAllowedRoutesNamespaces'] = None):
        """
        AllowedRoutes defines the types of routes that MAY be attached to a
        Listener and the trusted namespaces where those Route resources MAY be
        present.

        Although a client request may match multiple route rules, only one rule
        may ultimately receive the request. Matching precedence MUST be
        determined in order of the following criteria:

        * The most specific match as defined by the Route type.
        * The oldest Route based on creation timestamp. For example, a Route with
          a creation timestamp of "2020-09-08 01:02:03" is given precedence over
          a Route with a creation timestamp of "2020-09-08 01:02:04".
        * If everything else is equivalent, the Route appearing first in
          alphabetical order (namespace/name) should be given precedence. For
          example, foo/bar is given precedence over foo/baz.

        All valid rules within a Route attached to this Listener should be
        implemented. Invalid Route rules can be ignored (sometimes that will mean
        the full Route). If a Route rule transitions from valid to invalid,
        support for that Route rule should be dropped to ensure consistency. For
        example, even if a filter specified by a Route rule is invalid, the rest
        of the rules within that Route should still be supported.

        Support: Core
        :param Sequence['GatewaySpecListenersAllowedRoutesKindsArgs'] kinds: Kinds specifies the groups and kinds of Routes that are allowed to bind
               to this Gateway Listener. When unspecified or empty, the kinds of Routes
               selected are determined using the Listener protocol.
               
               A RouteGroupKind MUST correspond to kinds of Routes that are compatible
               with the application protocol specified in the Listener's Protocol field.
               If an implementation does not support or recognize this resource type, it
               MUST set the "ResolvedRefs" condition to False for this Listener with the
               "InvalidRouteKinds" reason.
               
               Support: Core
        """
        if kinds is not None:
            pulumi.set(__self__, "kinds", kinds)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def kinds(self) -> Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesKinds']]:
        """
        Kinds specifies the groups and kinds of Routes that are allowed to bind
        to this Gateway Listener. When unspecified or empty, the kinds of Routes
        selected are determined using the Listener protocol.

        A RouteGroupKind MUST correspond to kinds of Routes that are compatible
        with the application protocol specified in the Listener's Protocol field.
        If an implementation does not support or recognize this resource type, it
        MUST set the "ResolvedRefs" condition to False for this Listener with the
        "InvalidRouteKinds" reason.

        Support: Core
        """
        return pulumi.get(self, "kinds")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional['outputs.GatewaySpecListenersAllowedRoutesNamespaces']:
        return pulumi.get(self, "namespaces")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesKinds(dict):
    """
    RouteGroupKind indicates the group and kind of a Route resource.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param str group: Group is the group of the Route.
        :param str kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesKindsPatch(dict):
    """
    RouteGroupKind indicates the group and kind of a Route resource.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param str group: Group is the group of the Route.
        :param str kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesNamespaces(dict):
    """
    Namespaces indicates namespaces from which Routes may be attached to this
    Listener. This is restricted to the namespace of this Gateway by default.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersAllowedRoutesNamespaces. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersAllowedRoutesNamespaces.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersAllowedRoutesNamespaces.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 selector: Optional['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelector'] = None):
        """
        Namespaces indicates namespaces from which Routes may be attached to this
        Listener. This is restricted to the namespace of this Gateway by default.

        Support: Core
        :param str from_: From indicates where Routes will be selected for this Gateway. Possible
               values are:
               
               * All: Routes in all namespaces may be used by this Gateway.
               * Selector: Routes in namespaces selected by the selector may be used by
                 this Gateway.
               * Same: Only Routes in the same namespace may be used by this Gateway.
               
               Support: Core
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        From indicates where Routes will be selected for this Gateway. Possible
        values are:

        * All: Routes in all namespaces may be used by this Gateway.
        * Selector: Routes in namespaces selected by the selector may be used by
          this Gateway.
        * Same: Only Routes in the same namespace may be used by this Gateway.

        Support: Core
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelector']:
        return pulumi.get(self, "selector")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesNamespacesPatch(dict):
    """
    Namespaces indicates namespaces from which Routes may be attached to this
    Listener. This is restricted to the namespace of this Gateway by default.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersAllowedRoutesNamespacesPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersAllowedRoutesNamespacesPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersAllowedRoutesNamespacesPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[str] = None,
                 selector: Optional['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch'] = None):
        """
        Namespaces indicates namespaces from which Routes may be attached to this
        Listener. This is restricted to the namespace of this Gateway by default.

        Support: Core
        :param str from_: From indicates where Routes will be selected for this Gateway. Possible
               values are:
               
               * All: Routes in all namespaces may be used by this Gateway.
               * Selector: Routes in namespaces selected by the selector may be used by
                 this Gateway.
               * Same: Only Routes in the same namespace may be used by this Gateway.
               
               Support: Core
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[str]:
        """
        From indicates where Routes will be selected for this Gateway. Possible
        values are:

        * All: Routes in all namespaces may be used by this Gateway.
        * Selector: Routes in namespaces selected by the selector may be used by
          this Gateway.
        * Same: Only Routes in the same namespace may be used by this Gateway.

        Support: Core
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch']:
        return pulumi.get(self, "selector")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesNamespacesSelector(dict):
    """
    Selector must be specified when From is set to "Selector". In that case,
    only Routes in Namespaces matching this Selector will be selected by this
    Gateway. This field is ignored for other values of "From".

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersAllowedRoutesNamespacesSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersAllowedRoutesNamespacesSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersAllowedRoutesNamespacesSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector must be specified when From is set to "Selector". In that case,
        only Routes in Namespaces matching this Selector will be selected by this
        Gateway. This field is ignored for other values of "From".

        Support: Core
        :param Sequence['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
               map is equivalent to an element of matchExpressions, whose key field is "key", the
               operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that
    relates the key and values.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that
        relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values.
               Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn,
               the values array must be non-empty. If the operator is Exists or DoesNotExist,
               the values array must be empty. This array is replaced during a strategic
               merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        operator represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that
    relates the key and values.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that
        relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values.
               Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn,
               the values array must be non-empty. If the operator is Exists or DoesNotExist,
               the values array must be empty. This array is replaced during a strategic
               merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        operator represents a key's relationship to a set of values.
        Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch(dict):
    """
    Selector must be specified when From is set to "Selector". In that case,
    only Routes in Namespaces matching this Selector will be selected by this
    Gateway. This field is ignored for other values of "From".

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersAllowedRoutesNamespacesSelectorPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector must be specified when From is set to "Selector". In that case,
        only Routes in Namespaces matching this Selector will be selected by this
        Gateway. This field is ignored for other values of "From".

        Support: Core
        :param Sequence['GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
               map is equivalent to an element of matchExpressions, whose key field is "key", the
               operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GatewaySpecListenersAllowedRoutesPatch(dict):
    """
    AllowedRoutes defines the types of routes that MAY be attached to a
    Listener and the trusted namespaces where those Route resources MAY be
    present.

    Although a client request may match multiple route rules, only one rule
    may ultimately receive the request. Matching precedence MUST be
    determined in order of the following criteria:

    * The most specific match as defined by the Route type.
    * The oldest Route based on creation timestamp. For example, a Route with
      a creation timestamp of "2020-09-08 01:02:03" is given precedence over
      a Route with a creation timestamp of "2020-09-08 01:02:04".
    * If everything else is equivalent, the Route appearing first in
      alphabetical order (namespace/name) should be given precedence. For
      example, foo/bar is given precedence over foo/baz.

    All valid rules within a Route attached to this Listener should be
    implemented. Invalid Route rules can be ignored (sometimes that will mean
    the full Route). If a Route rule transitions from valid to invalid,
    support for that Route rule should be dropped to ensure consistency. For
    example, even if a filter specified by a Route rule is invalid, the rest
    of the rules within that Route should still be supported.

    Support: Core
    """
    def __init__(__self__, *,
                 kinds: Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesKindsPatch']] = None,
                 namespaces: Optional['outputs.GatewaySpecListenersAllowedRoutesNamespacesPatch'] = None):
        """
        AllowedRoutes defines the types of routes that MAY be attached to a
        Listener and the trusted namespaces where those Route resources MAY be
        present.

        Although a client request may match multiple route rules, only one rule
        may ultimately receive the request. Matching precedence MUST be
        determined in order of the following criteria:

        * The most specific match as defined by the Route type.
        * The oldest Route based on creation timestamp. For example, a Route with
          a creation timestamp of "2020-09-08 01:02:03" is given precedence over
          a Route with a creation timestamp of "2020-09-08 01:02:04".
        * If everything else is equivalent, the Route appearing first in
          alphabetical order (namespace/name) should be given precedence. For
          example, foo/bar is given precedence over foo/baz.

        All valid rules within a Route attached to this Listener should be
        implemented. Invalid Route rules can be ignored (sometimes that will mean
        the full Route). If a Route rule transitions from valid to invalid,
        support for that Route rule should be dropped to ensure consistency. For
        example, even if a filter specified by a Route rule is invalid, the rest
        of the rules within that Route should still be supported.

        Support: Core
        :param Sequence['GatewaySpecListenersAllowedRoutesKindsPatchArgs'] kinds: Kinds specifies the groups and kinds of Routes that are allowed to bind
               to this Gateway Listener. When unspecified or empty, the kinds of Routes
               selected are determined using the Listener protocol.
               
               A RouteGroupKind MUST correspond to kinds of Routes that are compatible
               with the application protocol specified in the Listener's Protocol field.
               If an implementation does not support or recognize this resource type, it
               MUST set the "ResolvedRefs" condition to False for this Listener with the
               "InvalidRouteKinds" reason.
               
               Support: Core
        """
        if kinds is not None:
            pulumi.set(__self__, "kinds", kinds)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def kinds(self) -> Optional[Sequence['outputs.GatewaySpecListenersAllowedRoutesKindsPatch']]:
        """
        Kinds specifies the groups and kinds of Routes that are allowed to bind
        to this Gateway Listener. When unspecified or empty, the kinds of Routes
        selected are determined using the Listener protocol.

        A RouteGroupKind MUST correspond to kinds of Routes that are compatible
        with the application protocol specified in the Listener's Protocol field.
        If an implementation does not support or recognize this resource type, it
        MUST set the "ResolvedRefs" condition to False for this Listener with the
        "InvalidRouteKinds" reason.

        Support: Core
        """
        return pulumi.get(self, "kinds")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional['outputs.GatewaySpecListenersAllowedRoutesNamespacesPatch']:
        return pulumi.get(self, "namespaces")


@pulumi.output_type
class GatewaySpecListenersPatch(dict):
    """
    Listener embodies the concept of a logical endpoint where a Gateway accepts
    network connections.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRoutes":
            suggest = "allowed_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_routes: Optional['outputs.GatewaySpecListenersAllowedRoutesPatch'] = None,
                 hostname: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 tls: Optional['outputs.GatewaySpecListenersTlsPatch'] = None):
        """
        Listener embodies the concept of a logical endpoint where a Gateway accepts
        network connections.
        :param str hostname: Hostname specifies the virtual hostname to match for protocol types that
               define this concept. When unspecified, all hostnames are matched. This
               field is ignored for protocols that don't require hostname based
               matching.
               
               Implementations MUST apply Hostname matching appropriately for each of
               the following protocols:
               
               * TLS: The Listener Hostname MUST match the SNI.
               * HTTP: The Listener Hostname MUST match the Host header of the request.
               * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
                 protocol layers as described above. If an implementation does not
                 ensure that both the SNI and Host header match the Listener hostname,
                 it MUST clearly document that.
               
               For HTTPRoute and TLSRoute resources, there is an interaction with the
               `spec.hostnames` array. When both listener and route specify hostnames,
               there MUST be an intersection between the values for a Route to be
               accepted. For more information, refer to the Route specific Hostnames
               documentation.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               Support: Core
        :param str name: Name is the name of the Listener. This name MUST be unique within a
               Gateway.
               
               Support: Core
        :param int port: Port is the network port. Multiple listeners may use the
               same port, subject to the Listener compatibility rules.
               
               Support: Core
        :param str protocol: Protocol specifies the network protocol this listener expects to receive.
               
               Support: Core
        """
        if allowed_routes is not None:
            pulumi.set(__self__, "allowed_routes", allowed_routes)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="allowedRoutes")
    def allowed_routes(self) -> Optional['outputs.GatewaySpecListenersAllowedRoutesPatch']:
        return pulumi.get(self, "allowed_routes")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname specifies the virtual hostname to match for protocol types that
        define this concept. When unspecified, all hostnames are matched. This
        field is ignored for protocols that don't require hostname based
        matching.

        Implementations MUST apply Hostname matching appropriately for each of
        the following protocols:

        * TLS: The Listener Hostname MUST match the SNI.
        * HTTP: The Listener Hostname MUST match the Host header of the request.
        * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
          protocol layers as described above. If an implementation does not
          ensure that both the SNI and Host header match the Listener hostname,
          it MUST clearly document that.

        For HTTPRoute and TLSRoute resources, there is an interaction with the
        `spec.hostnames` array. When both listener and route specify hostnames,
        there MUST be an intersection between the values for a Route to be
        accepted. For more information, refer to the Route specific Hostnames
        documentation.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the Listener. This name MUST be unique within a
        Gateway.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port. Multiple listeners may use the
        same port, subject to the Listener compatibility rules.

        Support: Core
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol specifies the network protocol this listener expects to receive.

        Support: Core
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.GatewaySpecListenersTlsPatch']:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GatewaySpecListenersTls(dict):
    """
    TLS is the TLS configuration for the Listener. This field is required if
    the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
    if the Protocol field is "HTTP", "TCP", or "UDP".

    The association of SNIs to Certificate defined in GatewayTLSConfig is
    defined based on the Hostname field for this listener.

    The GatewayClass MUST use the longest matching SNI out of all
    available certificates for any TLS handshake.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateRefs":
            suggest = "certificate_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_refs: Optional[Sequence['outputs.GatewaySpecListenersTlsCertificateRefs']] = None,
                 mode: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None):
        """
        TLS is the TLS configuration for the Listener. This field is required if
        the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
        if the Protocol field is "HTTP", "TCP", or "UDP".

        The association of SNIs to Certificate defined in GatewayTLSConfig is
        defined based on the Hostname field for this listener.

        The GatewayClass MUST use the longest matching SNI out of all
        available certificates for any TLS handshake.

        Support: Core
        :param Sequence['GatewaySpecListenersTlsCertificateRefsArgs'] certificate_refs: CertificateRefs contains a series of references to Kubernetes objects that
               contains TLS certificates and private keys. These certificates are used to
               establish a TLS handshake for requests that match the hostname of the
               associated listener.
               
               A single CertificateRef to a Kubernetes Secret has "Core" support.
               Implementations MAY choose to support attaching multiple certificates to
               a Listener, but this behavior is implementation-specific.
               
               References to a resource in different namespace are invalid UNLESS there
               is a ReferenceGrant in the target namespace that allows the certificate
               to be attached. If a ReferenceGrant does not allow this reference, the
               "ResolvedRefs" condition MUST be set to False for this listener with the
               "RefNotPermitted" reason.
               
               This field is required to have at least one element when the mode is set
               to "Terminate" (default) and is optional otherwise.
               
               CertificateRefs can reference to standard Kubernetes resources, i.e.
               Secret, or implementation-specific custom resources.
               
               Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
               
               Support: Implementation-specific (More than one reference or other resource types)
        :param str mode: Mode defines the TLS behavior for the TLS session initiated by the client.
               There are two possible modes:
               
               - Terminate: The TLS session between the downstream client and the
                 Gateway is terminated at the Gateway. This mode requires certificates
                 to be specified in some way, such as populating the certificateRefs
                 field.
               - Passthrough: The TLS session is NOT terminated by the Gateway. This
                 implies that the Gateway can't decipher the TLS stream except for
                 the ClientHello message of the TLS protocol. The certificateRefs field
                 is ignored in this mode.
               
               Support: Core
        :param Mapping[str, str] options: Options are a list of key/value pairs to enable extended TLS
               configuration for each implementation. For example, configuring the
               minimum TLS version or supported cipher suites.
               
               A set of common keys MAY be defined by the API in the future. To avoid
               any ambiguity, implementation-specific definitions MUST use
               domain-prefixed names, such as `example.com/my-custom-option`.
               Un-prefixed names are reserved for key names defined by Gateway API.
               
               Support: Implementation-specific
        """
        if certificate_refs is not None:
            pulumi.set(__self__, "certificate_refs", certificate_refs)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter(name="certificateRefs")
    def certificate_refs(self) -> Optional[Sequence['outputs.GatewaySpecListenersTlsCertificateRefs']]:
        """
        CertificateRefs contains a series of references to Kubernetes objects that
        contains TLS certificates and private keys. These certificates are used to
        establish a TLS handshake for requests that match the hostname of the
        associated listener.

        A single CertificateRef to a Kubernetes Secret has "Core" support.
        Implementations MAY choose to support attaching multiple certificates to
        a Listener, but this behavior is implementation-specific.

        References to a resource in different namespace are invalid UNLESS there
        is a ReferenceGrant in the target namespace that allows the certificate
        to be attached. If a ReferenceGrant does not allow this reference, the
        "ResolvedRefs" condition MUST be set to False for this listener with the
        "RefNotPermitted" reason.

        This field is required to have at least one element when the mode is set
        to "Terminate" (default) and is optional otherwise.

        CertificateRefs can reference to standard Kubernetes resources, i.e.
        Secret, or implementation-specific custom resources.

        Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls

        Support: Implementation-specific (More than one reference or other resource types)
        """
        return pulumi.get(self, "certificate_refs")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode defines the TLS behavior for the TLS session initiated by the client.
        There are two possible modes:

        - Terminate: The TLS session between the downstream client and the
          Gateway is terminated at the Gateway. This mode requires certificates
          to be specified in some way, such as populating the certificateRefs
          field.
        - Passthrough: The TLS session is NOT terminated by the Gateway. This
          implies that the Gateway can't decipher the TLS stream except for
          the ClientHello message of the TLS protocol. The certificateRefs field
          is ignored in this mode.

        Support: Core
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        Options are a list of key/value pairs to enable extended TLS
        configuration for each implementation. For example, configuring the
        minimum TLS version or supported cipher suites.

        A set of common keys MAY be defined by the API in the future. To avoid
        any ambiguity, implementation-specific definitions MUST use
        domain-prefixed names, such as `example.com/my-custom-option`.
        Un-prefixed names are reserved for key names defined by Gateway API.

        Support: Implementation-specific
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class GatewaySpecListenersTlsCertificateRefs(dict):
    """
    SecretObjectReference identifies an API object including its namespace,
    defaulting to Secret.

    The API object must be valid in the cluster; the Group and Kind must
    be registered in the cluster for this reference to be valid.

    References to objects with invalid Group and Kind are not valid, and must
    be rejected by the implementation, with appropriate Conditions set
    on the containing object.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        SecretObjectReference identifies an API object including its namespace,
        defaulting to Secret.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        References to objects with invalid Group and Kind are not valid, and must
        be rejected by the implementation, with appropriate Conditions set
        on the containing object.
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "Secret".
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the referenced object. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "Secret".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referenced object. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GatewaySpecListenersTlsCertificateRefsPatch(dict):
    """
    SecretObjectReference identifies an API object including its namespace,
    defaulting to Secret.

    The API object must be valid in the cluster; the Group and Kind must
    be registered in the cluster for this reference to be valid.

    References to objects with invalid Group and Kind are not valid, and must
    be rejected by the implementation, with appropriate Conditions set
    on the containing object.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        SecretObjectReference identifies an API object including its namespace,
        defaulting to Secret.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.

        References to objects with invalid Group and Kind are not valid, and must
        be rejected by the implementation, with appropriate Conditions set
        on the containing object.
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "Secret".
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the referenced object. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "Secret".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referenced object. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GatewaySpecListenersTlsPatch(dict):
    """
    TLS is the TLS configuration for the Listener. This field is required if
    the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
    if the Protocol field is "HTTP", "TCP", or "UDP".

    The association of SNIs to Certificate defined in GatewayTLSConfig is
    defined based on the Hostname field for this listener.

    The GatewayClass MUST use the longest matching SNI out of all
    available certificates for any TLS handshake.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateRefs":
            suggest = "certificate_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecListenersTlsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecListenersTlsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecListenersTlsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_refs: Optional[Sequence['outputs.GatewaySpecListenersTlsCertificateRefsPatch']] = None,
                 mode: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None):
        """
        TLS is the TLS configuration for the Listener. This field is required if
        the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
        if the Protocol field is "HTTP", "TCP", or "UDP".

        The association of SNIs to Certificate defined in GatewayTLSConfig is
        defined based on the Hostname field for this listener.

        The GatewayClass MUST use the longest matching SNI out of all
        available certificates for any TLS handshake.

        Support: Core
        :param Sequence['GatewaySpecListenersTlsCertificateRefsPatchArgs'] certificate_refs: CertificateRefs contains a series of references to Kubernetes objects that
               contains TLS certificates and private keys. These certificates are used to
               establish a TLS handshake for requests that match the hostname of the
               associated listener.
               
               A single CertificateRef to a Kubernetes Secret has "Core" support.
               Implementations MAY choose to support attaching multiple certificates to
               a Listener, but this behavior is implementation-specific.
               
               References to a resource in different namespace are invalid UNLESS there
               is a ReferenceGrant in the target namespace that allows the certificate
               to be attached. If a ReferenceGrant does not allow this reference, the
               "ResolvedRefs" condition MUST be set to False for this listener with the
               "RefNotPermitted" reason.
               
               This field is required to have at least one element when the mode is set
               to "Terminate" (default) and is optional otherwise.
               
               CertificateRefs can reference to standard Kubernetes resources, i.e.
               Secret, or implementation-specific custom resources.
               
               Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
               
               Support: Implementation-specific (More than one reference or other resource types)
        :param str mode: Mode defines the TLS behavior for the TLS session initiated by the client.
               There are two possible modes:
               
               - Terminate: The TLS session between the downstream client and the
                 Gateway is terminated at the Gateway. This mode requires certificates
                 to be specified in some way, such as populating the certificateRefs
                 field.
               - Passthrough: The TLS session is NOT terminated by the Gateway. This
                 implies that the Gateway can't decipher the TLS stream except for
                 the ClientHello message of the TLS protocol. The certificateRefs field
                 is ignored in this mode.
               
               Support: Core
        :param Mapping[str, str] options: Options are a list of key/value pairs to enable extended TLS
               configuration for each implementation. For example, configuring the
               minimum TLS version or supported cipher suites.
               
               A set of common keys MAY be defined by the API in the future. To avoid
               any ambiguity, implementation-specific definitions MUST use
               domain-prefixed names, such as `example.com/my-custom-option`.
               Un-prefixed names are reserved for key names defined by Gateway API.
               
               Support: Implementation-specific
        """
        if certificate_refs is not None:
            pulumi.set(__self__, "certificate_refs", certificate_refs)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter(name="certificateRefs")
    def certificate_refs(self) -> Optional[Sequence['outputs.GatewaySpecListenersTlsCertificateRefsPatch']]:
        """
        CertificateRefs contains a series of references to Kubernetes objects that
        contains TLS certificates and private keys. These certificates are used to
        establish a TLS handshake for requests that match the hostname of the
        associated listener.

        A single CertificateRef to a Kubernetes Secret has "Core" support.
        Implementations MAY choose to support attaching multiple certificates to
        a Listener, but this behavior is implementation-specific.

        References to a resource in different namespace are invalid UNLESS there
        is a ReferenceGrant in the target namespace that allows the certificate
        to be attached. If a ReferenceGrant does not allow this reference, the
        "ResolvedRefs" condition MUST be set to False for this listener with the
        "RefNotPermitted" reason.

        This field is required to have at least one element when the mode is set
        to "Terminate" (default) and is optional otherwise.

        CertificateRefs can reference to standard Kubernetes resources, i.e.
        Secret, or implementation-specific custom resources.

        Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls

        Support: Implementation-specific (More than one reference or other resource types)
        """
        return pulumi.get(self, "certificate_refs")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode defines the TLS behavior for the TLS session initiated by the client.
        There are two possible modes:

        - Terminate: The TLS session between the downstream client and the
          Gateway is terminated at the Gateway. This mode requires certificates
          to be specified in some way, such as populating the certificateRefs
          field.
        - Passthrough: The TLS session is NOT terminated by the Gateway. This
          implies that the Gateway can't decipher the TLS stream except for
          the ClientHello message of the TLS protocol. The certificateRefs field
          is ignored in this mode.

        Support: Core
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        Options are a list of key/value pairs to enable extended TLS
        configuration for each implementation. For example, configuring the
        minimum TLS version or supported cipher suites.

        A set of common keys MAY be defined by the API in the future. To avoid
        any ambiguity, implementation-specific definitions MUST use
        domain-prefixed names, such as `example.com/my-custom-option`.
        Un-prefixed names are reserved for key names defined by Gateway API.

        Support: Implementation-specific
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class GatewaySpecPatch(dict):
    """
    Spec defines the desired state of Gateway.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayClassName":
            suggest = "gateway_class_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.GatewaySpecAddressesPatch']] = None,
                 gateway_class_name: Optional[str] = None,
                 infrastructure: Optional['outputs.GatewaySpecInfrastructurePatch'] = None,
                 listeners: Optional[Sequence['outputs.GatewaySpecListenersPatch']] = None):
        """
        Spec defines the desired state of Gateway.
        :param Sequence['GatewaySpecAddressesPatchArgs'] addresses: Addresses requested for this Gateway. This is optional and behavior can
               depend on the implementation. If a value is set in the spec and the
               requested address is invalid or unavailable, the implementation MUST
               indicate this in the associated entry in GatewayStatus.Addresses.
               
               The Addresses field represents a request for the address(es) on the
               "outside of the Gateway", that traffic bound for this Gateway will use.
               This could be the IP address or hostname of an external load balancer or
               other networking infrastructure, or some other address that traffic will
               be sent to.
               
               If no Addresses are specified, the implementation MAY schedule the
               Gateway in an implementation-specific manner, assigning an appropriate
               set of Addresses.
               
               The implementation MUST bind all Listeners to every GatewayAddress that
               it assigns to the Gateway and add a corresponding entry in
               GatewayStatus.Addresses.
               
               Support: Extended
        :param str gateway_class_name: GatewayClassName used for this Gateway. This is the name of a
               GatewayClass resource.
        :param Sequence['GatewaySpecListenersPatchArgs'] listeners: Listeners associated with this Gateway. Listeners define
               logical endpoints that are bound on this Gateway's addresses.
               At least one Listener MUST be specified.
               
               Each Listener in a set of Listeners (for example, in a single Gateway)
               MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
               exactly one listener. (This section uses "set of Listeners" rather than
               "Listeners in a single Gateway" because implementations MAY merge configuration
               from multiple Gateways onto a single data plane, and these rules _also_
               apply in that case).
               
               Practically, this means that each listener in a set MUST have a unique
               combination of Port, Protocol, and, if supported by the protocol, Hostname.
               
               Some combinations of port, protocol, and TLS settings are considered
               Core support and MUST be supported by implementations based on their
               targeted conformance profile:
               
               HTTP Profile
               
               1. HTTPRoute, Port: 80, Protocol: HTTP
               2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
               
               TLS Profile
               
               1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
               
               "Distinct" Listeners have the following property:
               
               The implementation can match inbound requests to a single distinct
               Listener. When multiple Listeners share values for fields (for
               example, two Listeners with the same Port value), the implementation
               can match requests to only one of the Listeners using other
               Listener fields.
               
               For example, the following Listener scenarios are distinct:
               
               1. Multiple Listeners with the same Port that all use the "HTTP"
                  Protocol that all have unique Hostname values.
               2. Multiple Listeners with the same Port that use either the "HTTPS" or
                  "TLS" Protocol that all have unique Hostname values.
               3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
                  with the same Protocol has the same Port value.
               
               Some fields in the Listener struct have possible values that affect
               whether the Listener is distinct. Hostname is particularly relevant
               for HTTP or HTTPS protocols.
               
               When using the Hostname value to select between same-Port, same-Protocol
               Listeners, the Hostname value must be different on each Listener for the
               Listener to be distinct.
               
               When the Listeners are distinct based on Hostname, inbound request
               hostnames MUST match from the most specific to least specific Hostname
               values to choose the correct Listener and its associated set of Routes.
               
               Exact matches must be processed before wildcard matches, and wildcard
               matches must be processed before fallback (empty Hostname value)
               matches. For example, `"foo.example.com"` takes precedence over
               `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
               
               Additionally, if there are multiple wildcard entries, more specific
               wildcard entries must be processed before less specific wildcard entries.
               For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
               The precise definition here is that the higher the number of dots in the
               hostname to the right of the wildcard character, the higher the precedence.
               
               The wildcard character will match any number of characters _and dots_ to
               the left, however, so `"*.example.com"` will match both
               `"foo.bar.example.com"` _and_ `"bar.example.com"`.
               
               If a set of Listeners contains Listeners that are not distinct, then those
               Listeners are Conflicted, and the implementation MUST set the "Conflicted"
               condition in the Listener Status to "True".
               
               Implementations MAY choose to accept a Gateway with some Conflicted
               Listeners only if they only accept the partial Listener set that contains
               no Conflicted Listeners. To put this another way, implementations may
               accept a partial Listener set only if they throw out *all* the conflicting
               Listeners. No picking one of the conflicting listeners as the winner.
               This also means that the Gateway must have at least one non-conflicting
               Listener in this case, otherwise it violates the requirement that at
               least one Listener must be present.
               
               The implementation MUST set a "ListenersNotValid" condition on the
               Gateway Status when the Gateway contains Conflicted Listeners whether or
               not they accept the Gateway. That Condition SHOULD clearly
               indicate in the Message which Listeners are conflicted, and which are
               Accepted. Additionally, the Listener status for those listeners SHOULD
               indicate which Listeners are conflicted and not Accepted.
               
               A Gateway's Listeners are considered "compatible" if:
               
               1. They are distinct.
               2. The implementation can serve them in compliance with the Addresses
                  requirement that all Listeners are available on all assigned
                  addresses.
               
               Compatible combinations in Extended support are expected to vary across
               implementations. A combination that is compatible for one implementation
               may not be compatible for another.
               
               For example, an implementation that cannot serve both TCP and UDP listeners
               on the same address, or cannot mix HTTPS and generic TLS listens on the same port
               would not consider those cases compatible, even though they are distinct.
               
               Note that requests SHOULD match at most one Listener. For example, if
               Listeners are defined for "foo.example.com" and "*.example.com", a
               request to "foo.example.com" SHOULD only be routed using routes attached
               to the "foo.example.com" Listener (and not the "*.example.com" Listener).
               This concept is known as "Listener Isolation". Implementations that do
               not support Listener Isolation MUST clearly document this.
               
               Implementations MAY merge separate Gateways onto a single set of
               Addresses if all Listeners across all Gateways are compatible.
               
               Support: Core
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if gateway_class_name is not None:
            pulumi.set(__self__, "gateway_class_name", gateway_class_name)
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.GatewaySpecAddressesPatch']]:
        """
        Addresses requested for this Gateway. This is optional and behavior can
        depend on the implementation. If a value is set in the spec and the
        requested address is invalid or unavailable, the implementation MUST
        indicate this in the associated entry in GatewayStatus.Addresses.

        The Addresses field represents a request for the address(es) on the
        "outside of the Gateway", that traffic bound for this Gateway will use.
        This could be the IP address or hostname of an external load balancer or
        other networking infrastructure, or some other address that traffic will
        be sent to.

        If no Addresses are specified, the implementation MAY schedule the
        Gateway in an implementation-specific manner, assigning an appropriate
        set of Addresses.

        The implementation MUST bind all Listeners to every GatewayAddress that
        it assigns to the Gateway and add a corresponding entry in
        GatewayStatus.Addresses.

        Support: Extended
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="gatewayClassName")
    def gateway_class_name(self) -> Optional[str]:
        """
        GatewayClassName used for this Gateway. This is the name of a
        GatewayClass resource.
        """
        return pulumi.get(self, "gateway_class_name")

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional['outputs.GatewaySpecInfrastructurePatch']:
        return pulumi.get(self, "infrastructure")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.GatewaySpecListenersPatch']]:
        """
        Listeners associated with this Gateway. Listeners define
        logical endpoints that are bound on this Gateway's addresses.
        At least one Listener MUST be specified.

        Each Listener in a set of Listeners (for example, in a single Gateway)
        MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
        exactly one listener. (This section uses "set of Listeners" rather than
        "Listeners in a single Gateway" because implementations MAY merge configuration
        from multiple Gateways onto a single data plane, and these rules _also_
        apply in that case).

        Practically, this means that each listener in a set MUST have a unique
        combination of Port, Protocol, and, if supported by the protocol, Hostname.

        Some combinations of port, protocol, and TLS settings are considered
        Core support and MUST be supported by implementations based on their
        targeted conformance profile:

        HTTP Profile

        1. HTTPRoute, Port: 80, Protocol: HTTP
        2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided

        TLS Profile

        1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough

        "Distinct" Listeners have the following property:

        The implementation can match inbound requests to a single distinct
        Listener. When multiple Listeners share values for fields (for
        example, two Listeners with the same Port value), the implementation
        can match requests to only one of the Listeners using other
        Listener fields.

        For example, the following Listener scenarios are distinct:

        1. Multiple Listeners with the same Port that all use the "HTTP"
           Protocol that all have unique Hostname values.
        2. Multiple Listeners with the same Port that use either the "HTTPS" or
           "TLS" Protocol that all have unique Hostname values.
        3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
           with the same Protocol has the same Port value.

        Some fields in the Listener struct have possible values that affect
        whether the Listener is distinct. Hostname is particularly relevant
        for HTTP or HTTPS protocols.

        When using the Hostname value to select between same-Port, same-Protocol
        Listeners, the Hostname value must be different on each Listener for the
        Listener to be distinct.

        When the Listeners are distinct based on Hostname, inbound request
        hostnames MUST match from the most specific to least specific Hostname
        values to choose the correct Listener and its associated set of Routes.

        Exact matches must be processed before wildcard matches, and wildcard
        matches must be processed before fallback (empty Hostname value)
        matches. For example, `"foo.example.com"` takes precedence over
        `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.

        Additionally, if there are multiple wildcard entries, more specific
        wildcard entries must be processed before less specific wildcard entries.
        For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
        The precise definition here is that the higher the number of dots in the
        hostname to the right of the wildcard character, the higher the precedence.

        The wildcard character will match any number of characters _and dots_ to
        the left, however, so `"*.example.com"` will match both
        `"foo.bar.example.com"` _and_ `"bar.example.com"`.

        If a set of Listeners contains Listeners that are not distinct, then those
        Listeners are Conflicted, and the implementation MUST set the "Conflicted"
        condition in the Listener Status to "True".

        Implementations MAY choose to accept a Gateway with some Conflicted
        Listeners only if they only accept the partial Listener set that contains
        no Conflicted Listeners. To put this another way, implementations may
        accept a partial Listener set only if they throw out *all* the conflicting
        Listeners. No picking one of the conflicting listeners as the winner.
        This also means that the Gateway must have at least one non-conflicting
        Listener in this case, otherwise it violates the requirement that at
        least one Listener must be present.

        The implementation MUST set a "ListenersNotValid" condition on the
        Gateway Status when the Gateway contains Conflicted Listeners whether or
        not they accept the Gateway. That Condition SHOULD clearly
        indicate in the Message which Listeners are conflicted, and which are
        Accepted. Additionally, the Listener status for those listeners SHOULD
        indicate which Listeners are conflicted and not Accepted.

        A Gateway's Listeners are considered "compatible" if:

        1. They are distinct.
        2. The implementation can serve them in compliance with the Addresses
           requirement that all Listeners are available on all assigned
           addresses.

        Compatible combinations in Extended support are expected to vary across
        implementations. A combination that is compatible for one implementation
        may not be compatible for another.

        For example, an implementation that cannot serve both TCP and UDP listeners
        on the same address, or cannot mix HTTPS and generic TLS listens on the same port
        would not consider those cases compatible, even though they are distinct.

        Note that requests SHOULD match at most one Listener. For example, if
        Listeners are defined for "foo.example.com" and "*.example.com", a
        request to "foo.example.com" SHOULD only be routed using routes attached
        to the "foo.example.com" Listener (and not the "*.example.com" Listener).
        This concept is known as "Listener Isolation". Implementations that do
        not support Listener Isolation MUST clearly document this.

        Implementations MAY merge separate Gateways onto a single set of
        Addresses if all Listeners across all Gateways are compatible.

        Support: Core
        """
        return pulumi.get(self, "listeners")


@pulumi.output_type
class GatewayStatus(dict):
    """
    Status defines the current state of Gateway.
    """
    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.GatewayStatusAddresses']] = None,
                 conditions: Optional[Sequence['outputs.GatewayStatusConditions']] = None,
                 listeners: Optional[Sequence['outputs.GatewayStatusListeners']] = None):
        """
        Status defines the current state of Gateway.
        :param Sequence['GatewayStatusAddressesArgs'] addresses: Addresses lists the network addresses that have been bound to the
               Gateway.
               
               This list may differ from the addresses provided in the spec under some
               conditions:
               
                 * no addresses are specified, all addresses are dynamically assigned
                 * a combination of specified and dynamic addresses are assigned
                 * a specified address was unusable (e.g. already in use)
        :param Sequence['GatewayStatusConditionsArgs'] conditions: Conditions describe the current conditions of the Gateway.
               
               Implementations should prefer to express Gateway conditions
               using the `GatewayConditionType` and `GatewayConditionReason`
               constants so that operators and tools can converge on a common
               vocabulary to describe Gateway state.
               
               Known condition types are:
               
               * "Accepted"
               * "Programmed"
               * "Ready"
        :param Sequence['GatewayStatusListenersArgs'] listeners: Listeners provide status for each unique listener port defined in the Spec.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.GatewayStatusAddresses']]:
        """
        Addresses lists the network addresses that have been bound to the
        Gateway.

        This list may differ from the addresses provided in the spec under some
        conditions:

          * no addresses are specified, all addresses are dynamically assigned
          * a combination of specified and dynamic addresses are assigned
          * a specified address was unusable (e.g. already in use)
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GatewayStatusConditions']]:
        """
        Conditions describe the current conditions of the Gateway.

        Implementations should prefer to express Gateway conditions
        using the `GatewayConditionType` and `GatewayConditionReason`
        constants so that operators and tools can converge on a common
        vocabulary to describe Gateway state.

        Known condition types are:

        * "Accepted"
        * "Programmed"
        * "Ready"
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.GatewayStatusListeners']]:
        """
        Listeners provide status for each unique listener port defined in the Spec.
        """
        return pulumi.get(self, "listeners")


@pulumi.output_type
class GatewayStatusAddresses(dict):
    """
    GatewayStatusAddress describes a network address that is bound to a Gateway.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        GatewayStatusAddress describes a network address that is bound to a Gateway.
        :param str type: Type of the address.
        :param str value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewayStatusAddressesPatch(dict):
    """
    GatewayStatusAddress describes a network address that is bound to a Gateway.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        GatewayStatusAddress describes a network address that is bound to a Gateway.
        :param str type: Type of the address.
        :param str value: Value of the address. The validity of the values will depend
               on the type and support by the controller.
               
               Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the address. The validity of the values will depend
        on the type and support by the controller.

        Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewayStatusConditions(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayStatusConditionsPatch(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayStatusConditionsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayStatusConditionsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayStatusConditionsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayStatusListeners(dict):
    """
    ListenerStatus is the status associated with a Listener.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachedRoutes":
            suggest = "attached_routes"
        elif key == "supportedKinds":
            suggest = "supported_kinds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayStatusListeners. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayStatusListeners.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayStatusListeners.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attached_routes: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.GatewayStatusListenersConditions']] = None,
                 name: Optional[str] = None,
                 supported_kinds: Optional[Sequence['outputs.GatewayStatusListenersSupportedKinds']] = None):
        """
        ListenerStatus is the status associated with a Listener.
        :param int attached_routes: AttachedRoutes represents the total number of Routes that have been
               successfully attached to this Listener.
               
               Successful attachment of a Route to a Listener is based solely on the
               combination of the AllowedRoutes field on the corresponding Listener
               and the Route's ParentRefs field. A Route is successfully attached to
               a Listener when it is selected by the Listener's AllowedRoutes field
               AND the Route has a valid ParentRef selecting the whole Gateway
               resource or a specific Listener as a parent resource (more detail on
               attachment semantics can be found in the documentation on the various
               Route kinds ParentRefs fields). Listener or Route status does not impact
               successful attachment, i.e. the AttachedRoutes field count MUST be set
               for Listeners with condition Accepted: false and MUST count successfully
               attached Routes that may themselves have Accepted: false conditions.
               
               Uses for this field include troubleshooting Route attachment and
               measuring blast radius/impact of changes to a Listener.
        :param Sequence['GatewayStatusListenersConditionsArgs'] conditions: Conditions describe the current condition of this listener.
        :param str name: Name is the name of the Listener that this status corresponds to.
        :param Sequence['GatewayStatusListenersSupportedKindsArgs'] supported_kinds: SupportedKinds is the list indicating the Kinds supported by this
               listener. This MUST represent the kinds an implementation supports for
               that Listener configuration.
               
               If kinds are specified in Spec that are not supported, they MUST NOT
               appear in this list and an implementation MUST set the "ResolvedRefs"
               condition to "False" with the "InvalidRouteKinds" reason. If both valid
               and invalid Route kinds are specified, the implementation MUST
               reference the valid Route kinds that have been specified.
        """
        if attached_routes is not None:
            pulumi.set(__self__, "attached_routes", attached_routes)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if supported_kinds is not None:
            pulumi.set(__self__, "supported_kinds", supported_kinds)

    @property
    @pulumi.getter(name="attachedRoutes")
    def attached_routes(self) -> Optional[int]:
        """
        AttachedRoutes represents the total number of Routes that have been
        successfully attached to this Listener.

        Successful attachment of a Route to a Listener is based solely on the
        combination of the AllowedRoutes field on the corresponding Listener
        and the Route's ParentRefs field. A Route is successfully attached to
        a Listener when it is selected by the Listener's AllowedRoutes field
        AND the Route has a valid ParentRef selecting the whole Gateway
        resource or a specific Listener as a parent resource (more detail on
        attachment semantics can be found in the documentation on the various
        Route kinds ParentRefs fields). Listener or Route status does not impact
        successful attachment, i.e. the AttachedRoutes field count MUST be set
        for Listeners with condition Accepted: false and MUST count successfully
        attached Routes that may themselves have Accepted: false conditions.

        Uses for this field include troubleshooting Route attachment and
        measuring blast radius/impact of changes to a Listener.
        """
        return pulumi.get(self, "attached_routes")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GatewayStatusListenersConditions']]:
        """
        Conditions describe the current condition of this listener.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the Listener that this status corresponds to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="supportedKinds")
    def supported_kinds(self) -> Optional[Sequence['outputs.GatewayStatusListenersSupportedKinds']]:
        """
        SupportedKinds is the list indicating the Kinds supported by this
        listener. This MUST represent the kinds an implementation supports for
        that Listener configuration.

        If kinds are specified in Spec that are not supported, they MUST NOT
        appear in this list and an implementation MUST set the "ResolvedRefs"
        condition to "False" with the "InvalidRouteKinds" reason. If both valid
        and invalid Route kinds are specified, the implementation MUST
        reference the valid Route kinds that have been specified.
        """
        return pulumi.get(self, "supported_kinds")


@pulumi.output_type
class GatewayStatusListenersConditions(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayStatusListenersConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayStatusListenersConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayStatusListenersConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayStatusListenersConditionsPatch(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayStatusListenersConditionsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayStatusListenersConditionsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayStatusListenersConditionsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayStatusListenersPatch(dict):
    """
    ListenerStatus is the status associated with a Listener.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachedRoutes":
            suggest = "attached_routes"
        elif key == "supportedKinds":
            suggest = "supported_kinds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayStatusListenersPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayStatusListenersPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayStatusListenersPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attached_routes: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.GatewayStatusListenersConditionsPatch']] = None,
                 name: Optional[str] = None,
                 supported_kinds: Optional[Sequence['outputs.GatewayStatusListenersSupportedKindsPatch']] = None):
        """
        ListenerStatus is the status associated with a Listener.
        :param int attached_routes: AttachedRoutes represents the total number of Routes that have been
               successfully attached to this Listener.
               
               Successful attachment of a Route to a Listener is based solely on the
               combination of the AllowedRoutes field on the corresponding Listener
               and the Route's ParentRefs field. A Route is successfully attached to
               a Listener when it is selected by the Listener's AllowedRoutes field
               AND the Route has a valid ParentRef selecting the whole Gateway
               resource or a specific Listener as a parent resource (more detail on
               attachment semantics can be found in the documentation on the various
               Route kinds ParentRefs fields). Listener or Route status does not impact
               successful attachment, i.e. the AttachedRoutes field count MUST be set
               for Listeners with condition Accepted: false and MUST count successfully
               attached Routes that may themselves have Accepted: false conditions.
               
               Uses for this field include troubleshooting Route attachment and
               measuring blast radius/impact of changes to a Listener.
        :param Sequence['GatewayStatusListenersConditionsPatchArgs'] conditions: Conditions describe the current condition of this listener.
        :param str name: Name is the name of the Listener that this status corresponds to.
        :param Sequence['GatewayStatusListenersSupportedKindsPatchArgs'] supported_kinds: SupportedKinds is the list indicating the Kinds supported by this
               listener. This MUST represent the kinds an implementation supports for
               that Listener configuration.
               
               If kinds are specified in Spec that are not supported, they MUST NOT
               appear in this list and an implementation MUST set the "ResolvedRefs"
               condition to "False" with the "InvalidRouteKinds" reason. If both valid
               and invalid Route kinds are specified, the implementation MUST
               reference the valid Route kinds that have been specified.
        """
        if attached_routes is not None:
            pulumi.set(__self__, "attached_routes", attached_routes)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if supported_kinds is not None:
            pulumi.set(__self__, "supported_kinds", supported_kinds)

    @property
    @pulumi.getter(name="attachedRoutes")
    def attached_routes(self) -> Optional[int]:
        """
        AttachedRoutes represents the total number of Routes that have been
        successfully attached to this Listener.

        Successful attachment of a Route to a Listener is based solely on the
        combination of the AllowedRoutes field on the corresponding Listener
        and the Route's ParentRefs field. A Route is successfully attached to
        a Listener when it is selected by the Listener's AllowedRoutes field
        AND the Route has a valid ParentRef selecting the whole Gateway
        resource or a specific Listener as a parent resource (more detail on
        attachment semantics can be found in the documentation on the various
        Route kinds ParentRefs fields). Listener or Route status does not impact
        successful attachment, i.e. the AttachedRoutes field count MUST be set
        for Listeners with condition Accepted: false and MUST count successfully
        attached Routes that may themselves have Accepted: false conditions.

        Uses for this field include troubleshooting Route attachment and
        measuring blast radius/impact of changes to a Listener.
        """
        return pulumi.get(self, "attached_routes")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GatewayStatusListenersConditionsPatch']]:
        """
        Conditions describe the current condition of this listener.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the Listener that this status corresponds to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="supportedKinds")
    def supported_kinds(self) -> Optional[Sequence['outputs.GatewayStatusListenersSupportedKindsPatch']]:
        """
        SupportedKinds is the list indicating the Kinds supported by this
        listener. This MUST represent the kinds an implementation supports for
        that Listener configuration.

        If kinds are specified in Spec that are not supported, they MUST NOT
        appear in this list and an implementation MUST set the "ResolvedRefs"
        condition to "False" with the "InvalidRouteKinds" reason. If both valid
        and invalid Route kinds are specified, the implementation MUST
        reference the valid Route kinds that have been specified.
        """
        return pulumi.get(self, "supported_kinds")


@pulumi.output_type
class GatewayStatusListenersSupportedKinds(dict):
    """
    RouteGroupKind indicates the group and kind of a Route resource.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param str group: Group is the group of the Route.
        :param str kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GatewayStatusListenersSupportedKindsPatch(dict):
    """
    RouteGroupKind indicates the group and kind of a Route resource.
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        RouteGroupKind indicates the group and kind of a Route resource.
        :param str group: Group is the group of the Route.
        :param str kind: Kind is the kind of the Route.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the Route.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the kind of the Route.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GatewayStatusPatch(dict):
    """
    Status defines the current state of Gateway.
    """
    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.GatewayStatusAddressesPatch']] = None,
                 conditions: Optional[Sequence['outputs.GatewayStatusConditionsPatch']] = None,
                 listeners: Optional[Sequence['outputs.GatewayStatusListenersPatch']] = None):
        """
        Status defines the current state of Gateway.
        :param Sequence['GatewayStatusAddressesPatchArgs'] addresses: Addresses lists the network addresses that have been bound to the
               Gateway.
               
               This list may differ from the addresses provided in the spec under some
               conditions:
               
                 * no addresses are specified, all addresses are dynamically assigned
                 * a combination of specified and dynamic addresses are assigned
                 * a specified address was unusable (e.g. already in use)
        :param Sequence['GatewayStatusConditionsPatchArgs'] conditions: Conditions describe the current conditions of the Gateway.
               
               Implementations should prefer to express Gateway conditions
               using the `GatewayConditionType` and `GatewayConditionReason`
               constants so that operators and tools can converge on a common
               vocabulary to describe Gateway state.
               
               Known condition types are:
               
               * "Accepted"
               * "Programmed"
               * "Ready"
        :param Sequence['GatewayStatusListenersPatchArgs'] listeners: Listeners provide status for each unique listener port defined in the Spec.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.GatewayStatusAddressesPatch']]:
        """
        Addresses lists the network addresses that have been bound to the
        Gateway.

        This list may differ from the addresses provided in the spec under some
        conditions:

          * no addresses are specified, all addresses are dynamically assigned
          * a combination of specified and dynamic addresses are assigned
          * a specified address was unusable (e.g. already in use)
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GatewayStatusConditionsPatch']]:
        """
        Conditions describe the current conditions of the Gateway.

        Implementations should prefer to express Gateway conditions
        using the `GatewayConditionType` and `GatewayConditionReason`
        constants so that operators and tools can converge on a common
        vocabulary to describe Gateway state.

        Known condition types are:

        * "Accepted"
        * "Programmed"
        * "Ready"
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.GatewayStatusListenersPatch']]:
        """
        Listeners provide status for each unique listener port defined in the Spec.
        """
        return pulumi.get(self, "listeners")


@pulumi.output_type
class HTTPRoute(dict):
    """
    HTTPRoute provides a way to route HTTP requests. This includes the capability
    to match requests by hostname, path, header, or query param. Filters can be
    used to specify additional processing steps. Backends specify where matching
    requests should be routed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 kind: Optional[str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.HTTPRouteSpec'] = None,
                 status: Optional['outputs.HTTPRouteStatus'] = None):
        """
        HTTPRoute provides a way to route HTTP requests. This includes the capability
        to match requests by hostname, path, header, or query param. Filters can be
        used to specify additional processing steps. Backends specify where matching
        requests should be routed.
        :param str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'gateway.networking.k8s.io/v1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'HTTPRoute')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.HTTPRouteSpec']:
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.HTTPRouteStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class HTTPRouteSpec(dict):
    """
    Spec defines the desired state of HTTPRoute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRefs":
            suggest = "parent_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 parent_refs: Optional[Sequence['outputs.HTTPRouteSpecParentRefs']] = None,
                 rules: Optional[Sequence['outputs.HTTPRouteSpecRules']] = None):
        """
        Spec defines the desired state of HTTPRoute.
        :param Sequence[str] hostnames: Hostnames defines a set of hostnames that should match against the HTTP Host
               header to select a HTTPRoute used to process the request. Implementations
               MUST ignore any port value specified in the HTTP Host header while
               performing a match and (absent of any applicable header modification
               configuration) MUST forward this header unmodified to the backend.
               
               Valid values for Hostnames are determined by RFC 1123 definition of a
               hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label must appear by itself as the first label.
               
               If a hostname is specified by both the Listener and HTTPRoute, there
               must be at least one intersecting hostname for the HTTPRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `*.example.com`, `test.example.com`, and `foo.test.example.com` would
                 all match. On the other hand, `example.com` and `test.example.net` would
                 not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and HTTPRoute have specified hostnames, any
               HTTPRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               HTTPRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` must not be considered for a match.
               
               If both the Listener and HTTPRoute have specified hostnames, and none
               match with the criteria above, then the HTTPRoute is not accepted. The
               implementation must raise an 'Accepted' Condition with a status of
               `False` in the corresponding RouteParentStatus.
               
               In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
               overlapping wildcard matching and exact matching hostnames), precedence must
               be given to rules from the HTTPRoute with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               
               If ties exist across multiple Routes, the matching precedence rules for
               HTTPRouteMatches takes over.
               
               Support: Core
        :param Sequence['HTTPRouteSpecParentRefsArgs'] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param Sequence['HTTPRouteSpecRulesArgs'] rules: Rules are a list of HTTP matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        """
        Hostnames defines a set of hostnames that should match against the HTTP Host
        header to select a HTTPRoute used to process the request. Implementations
        MUST ignore any port value specified in the HTTP Host header while
        performing a match and (absent of any applicable header modification
        configuration) MUST forward this header unmodified to the backend.

        Valid values for Hostnames are determined by RFC 1123 definition of a
        hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label must appear by itself as the first label.

        If a hostname is specified by both the Listener and HTTPRoute, there
        must be at least one intersecting hostname for the HTTPRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `*.example.com`, `test.example.com`, and `foo.test.example.com` would
          all match. On the other hand, `example.com` and `test.example.net` would
          not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and HTTPRoute have specified hostnames, any
        HTTPRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        HTTPRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` must not be considered for a match.

        If both the Listener and HTTPRoute have specified hostnames, and none
        match with the criteria above, then the HTTPRoute is not accepted. The
        implementation must raise an 'Accepted' Condition with a status of
        `False` in the corresponding RouteParentStatus.

        In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
        overlapping wildcard matching and exact matching hostnames), precedence must
        be given to rules from the HTTPRoute with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.

        If ties exist across multiple Routes, the matching precedence rules for
        HTTPRouteMatches takes over.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[Sequence['outputs.HTTPRouteSpecParentRefs']]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.HTTPRouteSpecRules']]:
        """
        Rules are a list of HTTP matchers, filters and actions.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class HTTPRouteSpecParentRefs(dict):
    """
    ParentReference identifies an API object (usually a Gateway) that can be considered
    a parent of this resource (usually a route). There are two kinds of parent resources
    with "Core" support:

    * Gateway (Gateway conformance profile)
    * Service (Mesh conformance profile, ClusterIP Services only)

    This API may be extended in the future to support additional kinds of parent
    resources.

    The API object must be valid in the cluster; the Group and Kind must
    be registered in the cluster for this reference to be valid.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecParentRefs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecParentRefs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecParentRefs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class HTTPRouteSpecParentRefsPatch(dict):
    """
    ParentReference identifies an API object (usually a Gateway) that can be considered
    a parent of this resource (usually a route). There are two kinds of parent resources
    with "Core" support:

    * Gateway (Gateway conformance profile)
    * Service (Mesh conformance profile, ClusterIP Services only)

    This API may be extended in the future to support additional kinds of parent
    resources.

    The API object must be valid in the cluster; the Group and Kind must
    be registered in the cluster for this reference to be valid.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecParentRefsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecParentRefsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecParentRefsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentReference identifies an API object (usually a Gateway) that can be considered
        a parent of this resource (usually a route). There are two kinds of parent resources
        with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        The API object must be valid in the cluster; the Group and Kind must
        be registered in the cluster for this reference to be valid.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class HTTPRouteSpecPatch(dict):
    """
    Spec defines the desired state of HTTPRoute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRefs":
            suggest = "parent_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 parent_refs: Optional[Sequence['outputs.HTTPRouteSpecParentRefsPatch']] = None,
                 rules: Optional[Sequence['outputs.HTTPRouteSpecRulesPatch']] = None):
        """
        Spec defines the desired state of HTTPRoute.
        :param Sequence[str] hostnames: Hostnames defines a set of hostnames that should match against the HTTP Host
               header to select a HTTPRoute used to process the request. Implementations
               MUST ignore any port value specified in the HTTP Host header while
               performing a match and (absent of any applicable header modification
               configuration) MUST forward this header unmodified to the backend.
               
               Valid values for Hostnames are determined by RFC 1123 definition of a
               hostname with 2 notable exceptions:
               
               1. IPs are not allowed.
               2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
                  label must appear by itself as the first label.
               
               If a hostname is specified by both the Listener and HTTPRoute, there
               must be at least one intersecting hostname for the HTTPRoute to be
               attached to the Listener. For example:
               
               * A Listener with `test.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames, or have specified at
                 least one of `test.example.com` or `*.example.com`.
               * A Listener with `*.example.com` as the hostname matches HTTPRoutes
                 that have either not specified any hostnames or have specified at least
                 one hostname that matches the Listener hostname. For example,
                 `*.example.com`, `test.example.com`, and `foo.test.example.com` would
                 all match. On the other hand, `example.com` and `test.example.net` would
                 not match.
               
               Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
               as a suffix match. That means that a match for `*.example.com` would match
               both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
               
               If both the Listener and HTTPRoute have specified hostnames, any
               HTTPRoute hostnames that do not match the Listener hostname MUST be
               ignored. For example, if a Listener specified `*.example.com`, and the
               HTTPRoute specified `test.example.com` and `test.example.net`,
               `test.example.net` must not be considered for a match.
               
               If both the Listener and HTTPRoute have specified hostnames, and none
               match with the criteria above, then the HTTPRoute is not accepted. The
               implementation must raise an 'Accepted' Condition with a status of
               `False` in the corresponding RouteParentStatus.
               
               In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
               overlapping wildcard matching and exact matching hostnames), precedence must
               be given to rules from the HTTPRoute with the largest number of:
               
               * Characters in a matching non-wildcard hostname.
               * Characters in a matching hostname.
               
               If ties exist across multiple Routes, the matching precedence rules for
               HTTPRouteMatches takes over.
               
               Support: Core
        :param Sequence['HTTPRouteSpecParentRefsPatchArgs'] parent_refs: ParentRefs references the resources (usually Gateways) that a Route wants
               to be attached to. Note that the referenced parent resource needs to
               allow this for the attachment to be complete. For Gateways, that means
               the Gateway needs to allow attachment from Routes of this kind and
               namespace. For Services, that means the Service must either be in the same
               namespace for a "producer" route, or the mesh implementation must support
               and allow "consumer" routes for the referenced Service. ReferenceGrant is
               not applicable for governing ParentRefs to Services - it is not possible to
               create a "producer" route for a Service in a different namespace from the
               Route.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               This API may be extended in the future to support additional kinds of parent
               resources.
               
               ParentRefs must be _distinct_. This means either that:
               
               * They select different objects.  If this is the case, then parentRef
                 entries are distinct. In terms of fields, this means that the
                 multi-part key defined by `group`, `kind`, `namespace`, and `name` must
                 be unique across all parentRef entries in the Route.
               * They do not select different objects, but for each optional field used,
                 each ParentRef that selects the same object must set the same set of
                 optional fields to different values. If one ParentRef sets a
                 combination of optional fields, all must set the same combination.
               
               Some examples:
               
               * If one ParentRef sets `sectionName`, all ParentRefs referencing the
                 same object must also set `sectionName`.
               * If one ParentRef sets `port`, all ParentRefs referencing the same
                 object must also set `port`.
               * If one ParentRef sets `sectionName` and `port`, all ParentRefs
                 referencing the same object must also set `sectionName` and `port`.
               
               It is possible to separately reference multiple distinct objects that may
               be collapsed by an implementation. For example, some implementations may
               choose to merge compatible Gateway Listeners together. If that is the
               case, the list of routes attached to those resources should also be
               merged.
               
               Note that for ParentRefs that cross namespace boundaries, there are specific
               rules. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example,
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable other kinds of cross-namespace reference.
        :param Sequence['HTTPRouteSpecRulesPatchArgs'] rules: Rules are a list of HTTP matchers, filters and actions.
        """
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if parent_refs is not None:
            pulumi.set(__self__, "parent_refs", parent_refs)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        """
        Hostnames defines a set of hostnames that should match against the HTTP Host
        header to select a HTTPRoute used to process the request. Implementations
        MUST ignore any port value specified in the HTTP Host header while
        performing a match and (absent of any applicable header modification
        configuration) MUST forward this header unmodified to the backend.

        Valid values for Hostnames are determined by RFC 1123 definition of a
        hostname with 2 notable exceptions:

        1. IPs are not allowed.
        2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
           label must appear by itself as the first label.

        If a hostname is specified by both the Listener and HTTPRoute, there
        must be at least one intersecting hostname for the HTTPRoute to be
        attached to the Listener. For example:

        * A Listener with `test.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames, or have specified at
          least one of `test.example.com` or `*.example.com`.
        * A Listener with `*.example.com` as the hostname matches HTTPRoutes
          that have either not specified any hostnames or have specified at least
          one hostname that matches the Listener hostname. For example,
          `*.example.com`, `test.example.com`, and `foo.test.example.com` would
          all match. On the other hand, `example.com` and `test.example.net` would
          not match.

        Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
        as a suffix match. That means that a match for `*.example.com` would match
        both `test.example.com`, and `foo.test.example.com`, but not `example.com`.

        If both the Listener and HTTPRoute have specified hostnames, any
        HTTPRoute hostnames that do not match the Listener hostname MUST be
        ignored. For example, if a Listener specified `*.example.com`, and the
        HTTPRoute specified `test.example.com` and `test.example.net`,
        `test.example.net` must not be considered for a match.

        If both the Listener and HTTPRoute have specified hostnames, and none
        match with the criteria above, then the HTTPRoute is not accepted. The
        implementation must raise an 'Accepted' Condition with a status of
        `False` in the corresponding RouteParentStatus.

        In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
        overlapping wildcard matching and exact matching hostnames), precedence must
        be given to rules from the HTTPRoute with the largest number of:

        * Characters in a matching non-wildcard hostname.
        * Characters in a matching hostname.

        If ties exist across multiple Routes, the matching precedence rules for
        HTTPRouteMatches takes over.

        Support: Core
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter(name="parentRefs")
    def parent_refs(self) -> Optional[Sequence['outputs.HTTPRouteSpecParentRefsPatch']]:
        """
        ParentRefs references the resources (usually Gateways) that a Route wants
        to be attached to. Note that the referenced parent resource needs to
        allow this for the attachment to be complete. For Gateways, that means
        the Gateway needs to allow attachment from Routes of this kind and
        namespace. For Services, that means the Service must either be in the same
        namespace for a "producer" route, or the mesh implementation must support
        and allow "consumer" routes for the referenced Service. ReferenceGrant is
        not applicable for governing ParentRefs to Services - it is not possible to
        create a "producer" route for a Service in a different namespace from the
        Route.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        This API may be extended in the future to support additional kinds of parent
        resources.

        ParentRefs must be _distinct_. This means either that:

        * They select different objects.  If this is the case, then parentRef
          entries are distinct. In terms of fields, this means that the
          multi-part key defined by `group`, `kind`, `namespace`, and `name` must
          be unique across all parentRef entries in the Route.
        * They do not select different objects, but for each optional field used,
          each ParentRef that selects the same object must set the same set of
          optional fields to different values. If one ParentRef sets a
          combination of optional fields, all must set the same combination.

        Some examples:

        * If one ParentRef sets `sectionName`, all ParentRefs referencing the
          same object must also set `sectionName`.
        * If one ParentRef sets `port`, all ParentRefs referencing the same
          object must also set `port`.
        * If one ParentRef sets `sectionName` and `port`, all ParentRefs
          referencing the same object must also set `sectionName` and `port`.

        It is possible to separately reference multiple distinct objects that may
        be collapsed by an implementation. For example, some implementations may
        choose to merge compatible Gateway Listeners together. If that is the
        case, the list of routes attached to those resources should also be
        merged.

        Note that for ParentRefs that cross namespace boundaries, there are specific
        rules. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example,
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable other kinds of cross-namespace reference.
        """
        return pulumi.get(self, "parent_refs")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesPatch']]:
        """
        Rules are a list of HTTP matchers, filters and actions.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class HTTPRouteSpecRules(dict):
    """
    HTTPRouteRule defines semantics for matching an HTTP request based on
    conditions (matches), processing it (filters), and forwarding the request to
    an API object (backendRefs).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRefs":
            suggest = "backend_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_refs: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefs']] = None,
                 filters: Optional[Sequence['outputs.HTTPRouteSpecRulesFilters']] = None,
                 matches: Optional[Sequence['outputs.HTTPRouteSpecRulesMatches']] = None,
                 timeouts: Optional['outputs.HTTPRouteSpecRulesTimeouts'] = None):
        """
        HTTPRouteRule defines semantics for matching an HTTP request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param Sequence['HTTPRouteSpecRulesBackendRefsArgs'] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive a 500 status code.
               
               See the HTTPBackendRef definition for the rules about what makes a single
               HTTPBackendRef invalid.
               
               When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive a 500 status code.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic must receive a 500. Implementations may
               choose how that 50 percent is determined.
               
               When a HTTPBackendRef refers to a Service that has no ready endpoints,
               implementations SHOULD return a 503 for requests to that backend instead.
               If an implementation chooses to do this, all of the above rules for 500 responses
               MUST also apply for responses that return a 503.
               
               Support: Core for Kubernetes Service
               
               Support: Extended for Kubernetes ServiceImport
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param Sequence['HTTPRouteSpecRulesFiltersArgs'] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               Wherever possible, implementations SHOULD implement filters in the order
               they are specified.
               
               Implementations MAY choose to implement this ordering strictly, rejecting
               any combination or order of filters that can not be supported. If implementations
               choose a strict interpretation of filter ordering, they MUST clearly document
               that behavior.
               
               To reject an invalid combination or order of filters, implementations SHOULD
               consider the Route Rules with this configuration invalid. If all Route Rules
               in a Route are invalid, the entire Route would be considered invalid. If only
               a portion of Route Rules are invalid, implementations MUST set the
               "PartiallyInvalid" condition for the Route.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               All filters are expected to be compatible with each other except for the
               URLRewrite and RequestRedirect filters, which may not be combined. If an
               implementation can not support other combinations of filters, they must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param Sequence['HTTPRouteSpecRulesMatchesArgs'] matches: Matches define conditions used for matching the rule against incoming
               HTTP requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - path:
                   value: "/foo"
                 headers:
                 - name: "version"
                   value: "v2"
               - path:
                   value: "/v2/foo"
               ```
               
               For a request to match against this rule, a request must satisfy
               EITHER of the two conditions:
               
               - path prefixed with `/foo` AND contains the header `version: v2`
               - path prefix of `/v2/foo`
               
               See the documentation for HTTPRouteMatch on how to specify multiple
               match conditions that should be ANDed together.
               
               If no matches are specified, the default is a prefix
               path match on "/", which has the effect of matching every
               HTTP request.
               
               Proxy or Load Balancer routing configuration generated from HTTPRoutes
               MUST prioritize matches based on the following criteria, continuing on
               ties. Across all rules specified on applicable Routes, precedence must be
               given to the match having:
               
               * "Exact" path match.
               * "Prefix" path match with largest number of characters.
               * Method match.
               * Largest number of header matches.
               * Largest number of query param matches.
               
               Note: The precedence of RegularExpression path matches are implementation-specific.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within an HTTPRoute, matching precedence MUST be granted
               to the FIRST matching rule (in list order) with a match meeting the above
               criteria.
               
               When no rules matching a request have been successfully attached to the
               parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefs']]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive a 500 status code.

        See the HTTPBackendRef definition for the rules about what makes a single
        HTTPBackendRef invalid.

        When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive a 500 status code.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic must receive a 500. Implementations may
        choose how that 50 percent is determined.

        When a HTTPBackendRef refers to a Service that has no ready endpoints,
        implementations SHOULD return a 503 for requests to that backend instead.
        If an implementation chooses to do this, all of the above rules for 500 responses
        MUST also apply for responses that return a 503.

        Support: Core for Kubernetes Service

        Support: Extended for Kubernetes ServiceImport

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFilters']]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        Wherever possible, implementations SHOULD implement filters in the order
        they are specified.

        Implementations MAY choose to implement this ordering strictly, rejecting
        any combination or order of filters that can not be supported. If implementations
        choose a strict interpretation of filter ordering, they MUST clearly document
        that behavior.

        To reject an invalid combination or order of filters, implementations SHOULD
        consider the Route Rules with this configuration invalid. If all Route Rules
        in a Route are invalid, the entire Route would be considered invalid. If only
        a portion of Route Rules are invalid, implementations MUST set the
        "PartiallyInvalid" condition for the Route.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        All filters are expected to be compatible with each other except for the
        URLRewrite and RequestRedirect filters, which may not be combined. If an
        implementation can not support other combinations of filters, they must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesMatches']]:
        """
        Matches define conditions used for matching the rule against incoming
        HTTP requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - path:
            value: "/foo"
          headers:
          - name: "version"
            value: "v2"
        - path:
            value: "/v2/foo"
        ```

        For a request to match against this rule, a request must satisfy
        EITHER of the two conditions:

        - path prefixed with `/foo` AND contains the header `version: v2`
        - path prefix of `/v2/foo`

        See the documentation for HTTPRouteMatch on how to specify multiple
        match conditions that should be ANDed together.

        If no matches are specified, the default is a prefix
        path match on "/", which has the effect of matching every
        HTTP request.

        Proxy or Load Balancer routing configuration generated from HTTPRoutes
        MUST prioritize matches based on the following criteria, continuing on
        ties. Across all rules specified on applicable Routes, precedence must be
        given to the match having:

        * "Exact" path match.
        * "Prefix" path match with largest number of characters.
        * Method match.
        * Largest number of header matches.
        * Largest number of query param matches.

        Note: The precedence of RegularExpression path matches are implementation-specific.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within an HTTPRoute, matching precedence MUST be granted
        to the FIRST matching rule (in list order) with a match meeting the above
        criteria.

        When no rules matching a request have been successfully attached to the
        parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def timeouts(self) -> Optional['outputs.HTTPRouteSpecRulesTimeouts']:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefs(dict):
    """
    HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

    Note that when a namespace different than the local namespace is specified, a
    ReferenceGrant object is required in the referent namespace to allow that
    namespace's owner to accept the reference. See the ReferenceGrant
    documentation for details.

    <gateway:experimental:description>

    When the BackendRef points to a Kubernetes Service, implementations SHOULD
    honor the appProtocol field if it is set for the target Service Port.

    Implementations supporting appProtocol SHOULD recognize the Kubernetes
    Standard Application Protocols defined in KEP-3726.

    If a Service appProtocol isn't specified, an implementation MAY infer the
    backend protocol through its own means. Implementations MAY infer the
    protocol from the Route type referring to the backend Service.

    If a Route is not able to send traffic to the backend using the specified
    protocol then the backend is considered invalid. Implementations MUST set the
    "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

    </gateway:experimental:description>
    """
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFilters']] = None,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersArgs'] filters: Filters defined at this level should be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in HTTPRouteRule.)
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param int weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFilters']]:
        """
        Filters defined at this level should be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in HTTPRouteRule.)
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFilters(dict):
    """
    HTTPRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. HTTPRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "requestRedirect":
            suggest = "request_redirect"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"
        elif key == "urlRewrite":
            suggest = "url_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersExtensionRef'] = None,
                 request_header_modifier: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier'] = None,
                 request_mirror: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirror'] = None,
                 request_redirect: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect'] = None,
                 response_header_modifier: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier'] = None,
                 type: Optional[str] = None,
                 url_rewrite: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite'] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersExtensionRef']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirror']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect']:
        return pulumi.get(self, "request_redirect")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite']:
        return pulumi.get(self, "url_rewrite")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersExtensionRef(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    This filter can be used multiple times within the same rule.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    This filter can be used multiple times within the same rule.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersPatch(dict):
    """
    HTTPRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. HTTPRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "requestRedirect":
            suggest = "request_redirect"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"
        elif key == "urlRewrite":
            suggest = "url_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch'] = None,
                 request_header_modifier: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch'] = None,
                 request_mirror: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch'] = None,
                 request_redirect: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch'] = None,
                 response_header_modifier: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch'] = None,
                 type: Optional[str] = None,
                 url_rewrite: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch'] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersExtensionRefPatch']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch']:
        return pulumi.get(self, "request_redirect")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch']:
        return pulumi.get(self, "url_rewrite")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPatch(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirror(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersRequestMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPatch']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect(dict):
    """
    RequestRedirect defines a schema for a filter that responds to the
    request with an HTTP redirection.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath'] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None,
                 status_code: Optional[int] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param str hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param int port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param str scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param int status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch(dict):
    """
    RequestRedirect defines a schema for a filter that responds to the
    request with an HTTP redirection.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch'] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None,
                 status_code: Optional[int] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param str hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param int port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param str scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param int status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath(dict):
    """
    Path defines parameters used to modify the path of the incoming request.
    The modified path is then used to construct the `Location` header. When
    empty, the request path is used as-is.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch(dict):
    """
    Path defines parameters used to modify the path of the incoming request.
    The modified path is then used to construct the `Location` header. When
    empty, the request path is used as-is.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPatch(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite(dict):
    """
    URLRewrite defines a schema for a filter that modifies a request during forwarding.

    Support: Extended
    """
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath'] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param str hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath']:
        return pulumi.get(self, "path")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePatch(dict):
    """
    URLRewrite defines a schema for a filter that modifies a request during forwarding.

    Support: Extended
    """
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch'] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param str hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch']:
        return pulumi.get(self, "path")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath(dict):
    """
    Path defines a path rewrite.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch(dict):
    """
    Path defines a path rewrite.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesBackendRefsPatch(dict):
    """
    HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

    Note that when a namespace different than the local namespace is specified, a
    ReferenceGrant object is required in the referent namespace to allow that
    namespace's owner to accept the reference. See the ReferenceGrant
    documentation for details.

    <gateway:experimental:description>

    When the BackendRef points to a Kubernetes Service, implementations SHOULD
    honor the appProtocol field if it is set for the target Service Port.

    Implementations supporting appProtocol SHOULD recognize the Kubernetes
    Standard Application Protocols defined in KEP-3726.

    If a Service appProtocol isn't specified, an implementation MAY infer the
    backend protocol through its own means. Implementations MAY infer the
    protocol from the Route type referring to the backend Service.

    If a Route is not able to send traffic to the backend using the specified
    protocol then the backend is considered invalid. Implementations MUST set the
    "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

    </gateway:experimental:description>
    """
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersPatch']] = None,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.

        Note that when a namespace different than the local namespace is specified, a
        ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        <gateway:experimental:description>

        When the BackendRef points to a Kubernetes Service, implementations SHOULD
        honor the appProtocol field if it is set for the target Service Port.

        Implementations supporting appProtocol SHOULD recognize the Kubernetes
        Standard Application Protocols defined in KEP-3726.

        If a Service appProtocol isn't specified, an implementation MAY infer the
        backend protocol through its own means. Implementations MAY infer the
        protocol from the Route type referring to the backend Service.

        If a Route is not able to send traffic to the backend using the specified
        protocol then the backend is considered invalid. Implementations MUST set the
        "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.

        </gateway:experimental:description>
        :param Sequence['HTTPRouteSpecRulesBackendRefsFiltersPatchArgs'] filters: Filters defined at this level should be executed if and only if the
               request is being forwarded to the backend defined here.
               
               Support: Implementation-specific (For broader support of filters, use the
               Filters field in HTTPRouteRule.)
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        :param int weight: Weight specifies the proportion of requests forwarded to the referenced
               backend. This is computed as weight/(sum of all weights in this
               BackendRefs list). For non-zero values, there may be some epsilon from
               the exact proportion defined here depending on the precision an
               implementation supports. Weight is not a percentage and the sum of
               weights does not need to equal 100.
               
               If only one backend is specified and it has a weight greater than 0, 100%
               of the traffic is forwarded to that backend. If weight is set to 0, no
               traffic should be forwarded for this entry. If unspecified, weight
               defaults to 1.
               
               Support for this field varies based on the context where used.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsFiltersPatch']]:
        """
        Filters defined at this level should be executed if and only if the
        request is being forwarded to the backend defined here.

        Support: Implementation-specific (For broader support of filters, use the
        Filters field in HTTPRouteRule.)
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the proportion of requests forwarded to the referenced
        backend. This is computed as weight/(sum of all weights in this
        BackendRefs list). For non-zero values, there may be some epsilon from
        the exact proportion defined here depending on the precision an
        implementation supports. Weight is not a percentage and the sum of
        weights does not need to equal 100.

        If only one backend is specified and it has a weight greater than 0, 100%
        of the traffic is forwarded to that backend. If weight is set to 0, no
        traffic should be forwarded for this entry. If unspecified, weight
        defaults to 1.

        Support for this field varies based on the context where used.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class HTTPRouteSpecRulesFilters(dict):
    """
    HTTPRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. HTTPRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "requestRedirect":
            suggest = "request_redirect"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"
        elif key == "urlRewrite":
            suggest = "url_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.HTTPRouteSpecRulesFiltersExtensionRef'] = None,
                 request_header_modifier: Optional['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifier'] = None,
                 request_mirror: Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirror'] = None,
                 request_redirect: Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirect'] = None,
                 response_header_modifier: Optional['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifier'] = None,
                 type: Optional[str] = None,
                 url_rewrite: Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewrite'] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersExtensionRef']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifier']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirror']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirect']:
        return pulumi.get(self, "request_redirect")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifier']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewrite']:
        return pulumi.get(self, "url_rewrite")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersExtensionRef(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    This filter can be used multiple times within the same rule.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersExtensionRefPatch(dict):
    """
    ExtensionRef is an optional, implementation-specific extension to the
    "filter" behavior.  For example, resource "myroutefilter" in group
    "networking.example.net"). ExtensionRef MUST NOT be used for core and
    extended filters.

    This filter can be used multiple times within the same rule.

    Support: Implementation-specific
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ExtensionRef is an optional, implementation-specific extension to the
        "filter" behavior.  For example, resource "myroutefilter" in group
        "networking.example.net"). ExtensionRef MUST NOT be used for core and
        extended filters.

        This filter can be used multiple times within the same rule.

        Support: Implementation-specific
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is kind of the referent. For example "HTTPRoute" or "Service".
        :param str name: Name is the name of the referent.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent. For example "HTTPRoute" or "Service".
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersPatch(dict):
    """
    HTTPRouteFilter defines processing steps that must be completed during the
    request or response lifecycle. HTTPRouteFilters are meant as an extension
    point to express processing that may be done in Gateway implementations. Some
    examples include request or response modification, implementing
    authentication strategies, rate-limiting, and traffic shaping. API
    guarantee/conformance is defined based on the type of the filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionRef":
            suggest = "extension_ref"
        elif key == "requestHeaderModifier":
            suggest = "request_header_modifier"
        elif key == "requestMirror":
            suggest = "request_mirror"
        elif key == "requestRedirect":
            suggest = "request_redirect"
        elif key == "responseHeaderModifier":
            suggest = "response_header_modifier"
        elif key == "urlRewrite":
            suggest = "url_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_ref: Optional['outputs.HTTPRouteSpecRulesFiltersExtensionRefPatch'] = None,
                 request_header_modifier: Optional['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch'] = None,
                 request_mirror: Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirrorPatch'] = None,
                 request_redirect: Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirectPatch'] = None,
                 response_header_modifier: Optional['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch'] = None,
                 type: Optional[str] = None,
                 url_rewrite: Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewritePatch'] = None):
        """
        HTTPRouteFilter defines processing steps that must be completed during the
        request or response lifecycle. HTTPRouteFilters are meant as an extension
        point to express processing that may be done in Gateway implementations. Some
        examples include request or response modification, implementing
        authentication strategies, rate-limiting, and traffic shaping. API
        guarantee/conformance is defined based on the type of the filter.
        :param str type: Type identifies the type of filter to apply. As with other API fields,
               types are classified into three conformance levels:
               
               - Core: Filter types and their corresponding configuration defined by
                 "Support: Core" in this package, e.g. "RequestHeaderModifier". All
                 implementations must support core filters.
               
               - Extended: Filter types and their corresponding configuration defined by
                 "Support: Extended" in this package, e.g. "RequestMirror". Implementers
                 are encouraged to support extended filters.
               
               - Implementation-specific: Filters that are defined and supported by
                 specific vendors.
                 In the future, filters showing convergence in behavior across multiple
                 implementations will be considered for inclusion in extended or core
                 conformance levels. Filter-specific configuration for such filters
                 is specified using the ExtensionRef field. `Type` should be set to
                 "ExtensionRef" for custom filters.
               
               Implementers are encouraged to define custom implementation types to
               extend the core API with implementation-specific behavior.
               
               If a reference to a custom filter type cannot be resolved, the filter
               MUST NOT be skipped. Instead, requests that would have been processed by
               that filter MUST receive a HTTP error response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if extension_ref is not None:
            pulumi.set(__self__, "extension_ref", extension_ref)
        if request_header_modifier is not None:
            pulumi.set(__self__, "request_header_modifier", request_header_modifier)
        if request_mirror is not None:
            pulumi.set(__self__, "request_mirror", request_mirror)
        if request_redirect is not None:
            pulumi.set(__self__, "request_redirect", request_redirect)
        if response_header_modifier is not None:
            pulumi.set(__self__, "response_header_modifier", response_header_modifier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url_rewrite is not None:
            pulumi.set(__self__, "url_rewrite", url_rewrite)

    @property
    @pulumi.getter(name="extensionRef")
    def extension_ref(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersExtensionRefPatch']:
        return pulumi.get(self, "extension_ref")

    @property
    @pulumi.getter(name="requestHeaderModifier")
    def request_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch']:
        return pulumi.get(self, "request_header_modifier")

    @property
    @pulumi.getter(name="requestMirror")
    def request_mirror(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirrorPatch']:
        return pulumi.get(self, "request_mirror")

    @property
    @pulumi.getter(name="requestRedirect")
    def request_redirect(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirectPatch']:
        return pulumi.get(self, "request_redirect")

    @property
    @pulumi.getter(name="responseHeaderModifier")
    def response_header_modifier(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch']:
        return pulumi.get(self, "response_header_modifier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type identifies the type of filter to apply. As with other API fields,
        types are classified into three conformance levels:

        - Core: Filter types and their corresponding configuration defined by
          "Support: Core" in this package, e.g. "RequestHeaderModifier". All
          implementations must support core filters.

        - Extended: Filter types and their corresponding configuration defined by
          "Support: Extended" in this package, e.g. "RequestMirror". Implementers
          are encouraged to support extended filters.

        - Implementation-specific: Filters that are defined and supported by
          specific vendors.
          In the future, filters showing convergence in behavior across multiple
          implementations will be considered for inclusion in extended or core
          conformance levels. Filter-specific configuration for such filters
          is specified using the ExtensionRef field. `Type` should be set to
          "ExtensionRef" for custom filters.

        Implementers are encouraged to define custom implementation types to
        extend the core API with implementation-specific behavior.

        If a reference to a custom filter type cannot be resolved, the filter
        MUST NOT be skipped. Instead, requests that would have been processed by
        that filter MUST receive a HTTP error response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="urlRewrite")
    def url_rewrite(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewritePatch']:
        return pulumi.get(self, "url_rewrite")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifier(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierSet']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierPatch(dict):
    """
    RequestHeaderModifier defines a schema for a filter that modifies request
    headers.

    Support: Core
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch']] = None):
        """
        RequestHeaderModifier defines a schema for a filter that modifies request
        headers.

        Support: Core
        :param Sequence['HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestMirror(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersRequestMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersRequestMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersRequestMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirrorBackendRef'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirrorBackendRef']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestMirrorBackendRef(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch(dict):
    """
    BackendRef references a resource where mirrored requests are sent.

    Mirrored requests must be sent only to a single destination endpoint
    within this BackendRef, irrespective of how many endpoints are present
    within this BackendRef.

    If the referent cannot be found, this BackendRef is invalid and must be
    dropped from the Gateway. The controller must ensure the "ResolvedRefs"
    condition on the Route status is set to `status: False` and not configure
    this backend in the underlying implementation.

    If there is a cross-namespace reference to an *existing* object
    that is not allowed by a ReferenceGrant, the controller must ensure the
    "ResolvedRefs"  condition on the Route is set to `status: False`,
    with the "RefNotPermitted" reason and not configure this backend in the
    underlying implementation.

    In either error case, the Message of the `ResolvedRefs` Condition
    should be used to provide more detail about the problem.

    Support: Extended for Kubernetes Service

    Support: Implementation-specific for any other resource
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None):
        """
        BackendRef references a resource where mirrored requests are sent.

        Mirrored requests must be sent only to a single destination endpoint
        within this BackendRef, irrespective of how many endpoints are present
        within this BackendRef.

        If the referent cannot be found, this BackendRef is invalid and must be
        dropped from the Gateway. The controller must ensure the "ResolvedRefs"
        condition on the Route status is set to `status: False` and not configure
        this backend in the underlying implementation.

        If there is a cross-namespace reference to an *existing* object
        that is not allowed by a ReferenceGrant, the controller must ensure the
        "ResolvedRefs"  condition on the Route is set to `status: False`,
        with the "RefNotPermitted" reason and not configure this backend in the
        underlying implementation.

        In either error case, the Message of the `ResolvedRefs` Condition
        should be used to provide more detail about the problem.

        Support: Extended for Kubernetes Service

        Support: Implementation-specific for any other resource
        :param str group: Group is the group of the referent. For example, "gateway.networking.k8s.io".
               When unspecified or empty string, core API group is inferred.
        :param str kind: Kind is the Kubernetes resource kind of the referent. For example
               "Service".
               
               Defaults to "Service" when not specified.
               
               ExternalName services can refer to CNAME DNS records that may live
               outside of the cluster and as such are difficult to reason about in
               terms of conformance. They also may not be safe to forward to (see
               CVE-2021-25740 for more information). Implementations SHOULD NOT
               support ExternalName Services.
               
               Support: Core (Services with a type other than ExternalName)
               
               Support: Implementation-specific (Services with type ExternalName)
        :param str name: Name is the name of the referent.
        :param str namespace: Namespace is the namespace of the backend. When unspecified, the local
               namespace is inferred.
               
               Note that when a namespace different than the local namespace is specified,
               a ReferenceGrant object is required in the referent namespace to allow that
               namespace's owner to accept the reference. See the ReferenceGrant
               documentation for details.
               
               Support: Core
        :param int port: Port specifies the destination port number to use for this resource.
               Port is required when the referent is a Kubernetes Service. In this
               case, the port number is the service port number, not the target port.
               For other resources, destination port might be derived from the referent
               resource or this field.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent. For example, "gateway.networking.k8s.io".
        When unspecified or empty string, core API group is inferred.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is the Kubernetes resource kind of the referent. For example
        "Service".

        Defaults to "Service" when not specified.

        ExternalName services can refer to CNAME DNS records that may live
        outside of the cluster and as such are difficult to reason about in
        terms of conformance. They also may not be safe to forward to (see
        CVE-2021-25740 for more information). Implementations SHOULD NOT
        support ExternalName Services.

        Support: Core (Services with a type other than ExternalName)

        Support: Implementation-specific (Services with type ExternalName)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the backend. When unspecified, the local
        namespace is inferred.

        Note that when a namespace different than the local namespace is specified,
        a ReferenceGrant object is required in the referent namespace to allow that
        namespace's owner to accept the reference. See the ReferenceGrant
        documentation for details.

        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port specifies the destination port number to use for this resource.
        Port is required when the referent is a Kubernetes Service. In this
        case, the port number is the service port number, not the target port.
        For other resources, destination port might be derived from the referent
        resource or this field.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestMirrorPatch(dict):
    """
    RequestMirror defines a schema for a filter that mirrors requests.
    Requests are sent to the specified destination, but responses from
    that destination are ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRef":
            suggest = "backend_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersRequestMirrorPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersRequestMirrorPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersRequestMirrorPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ref: Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch'] = None):
        """
        RequestMirror defines a schema for a filter that mirrors requests.
        Requests are sent to the specified destination, but responses from
        that destination are ignored.

        This filter can be used multiple times within the same rule. Note that
        not all implementations will be able to support mirroring to multiple
        backends.

        Support: Extended
        """
        if backend_ref is not None:
            pulumi.set(__self__, "backend_ref", backend_ref)

    @property
    @pulumi.getter(name="backendRef")
    def backend_ref(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestMirrorBackendRefPatch']:
        return pulumi.get(self, "backend_ref")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestRedirect(dict):
    """
    RequestRedirect defines a schema for a filter that responds to the
    request with an HTTP redirection.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersRequestRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirectPath'] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None,
                 status_code: Optional[int] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param str hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param int port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param str scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param int status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirectPath']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestRedirectPatch(dict):
    """
    RequestRedirect defines a schema for a filter that responds to the
    request with an HTTP redirection.

    Support: Core
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersRequestRedirectPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirectPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirectPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirectPathPatch'] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None,
                 status_code: Optional[int] = None):
        """
        RequestRedirect defines a schema for a filter that responds to the
        request with an HTTP redirection.

        Support: Core
        :param str hostname: Hostname is the hostname to be used in the value of the `Location`
               header in the response.
               When empty, the hostname in the `Host` header of the request is used.
               
               Support: Core
        :param int port: Port is the port to be used in the value of the `Location`
               header in the response.
               
               If no port is specified, the redirect port MUST be derived using the
               following rules:
               
               * If redirect scheme is not-empty, the redirect port MUST be the well-known
                 port associated with the redirect scheme. Specifically "http" to port 80
                 and "https" to port 443. If the redirect scheme does not have a
                 well-known port, the listener port of the Gateway SHOULD be used.
               * If redirect scheme is empty, the redirect port MUST be the Gateway
                 Listener port.
               
               Implementations SHOULD NOT add the port number in the 'Location'
               header in the following cases:
               
               * A Location header that will use HTTP (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 80.
               * A Location header that will use HTTPS (whether that is determined via
                 the Listener protocol or the Scheme field) _and_ use port 443.
               
               Support: Extended
        :param str scheme: Scheme is the scheme to be used in the value of the `Location` header in
               the response. When empty, the scheme of the request is used.
               
               Scheme redirects can affect the port of the redirect, for more information,
               refer to the documentation for the port field of this filter.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Extended
        :param int status_code: StatusCode is the HTTP status code to be used in response.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
               
               Support: Core
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the hostname to be used in the value of the `Location`
        header in the response.
        When empty, the hostname in the `Host` header of the request is used.

        Support: Core
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersRequestRedirectPathPatch']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the port to be used in the value of the `Location`
        header in the response.

        If no port is specified, the redirect port MUST be derived using the
        following rules:

        * If redirect scheme is not-empty, the redirect port MUST be the well-known
          port associated with the redirect scheme. Specifically "http" to port 80
          and "https" to port 443. If the redirect scheme does not have a
          well-known port, the listener port of the Gateway SHOULD be used.
        * If redirect scheme is empty, the redirect port MUST be the Gateway
          Listener port.

        Implementations SHOULD NOT add the port number in the 'Location'
        header in the following cases:

        * A Location header that will use HTTP (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 80.
        * A Location header that will use HTTPS (whether that is determined via
          the Listener protocol or the Scheme field) _and_ use port 443.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme is the scheme to be used in the value of the `Location` header in
        the response. When empty, the scheme of the request is used.

        Scheme redirects can affect the port of the redirect, for more information,
        refer to the documentation for the port field of this filter.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Extended
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        """
        StatusCode is the HTTP status code to be used in response.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.

        Support: Core
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestRedirectPath(dict):
    """
    Path defines parameters used to modify the path of the incoming request.
    The modified path is then used to construct the `Location` header. When
    empty, the request path is used as-is.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersRequestRedirectPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirectPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirectPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersRequestRedirectPathPatch(dict):
    """
    Path defines parameters used to modify the path of the incoming request.
    The modified path is then used to construct the `Location` header. When
    empty, the request path is used as-is.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersRequestRedirectPathPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirectPathPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersRequestRedirectPathPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines parameters used to modify the path of the incoming request.
        The modified path is then used to construct the `Location` header. When
        empty, the request path is used as-is.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifier(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierSet']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierSet']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierPatch(dict):
    """
    ResponseHeaderModifier defines a schema for a filter that modifies response
    headers.

    Support: Extended
    """
    def __init__(__self__, *,
                 add: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch']] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch']] = None):
        """
        ResponseHeaderModifier defines a schema for a filter that modifies response
        headers.

        Support: Extended
        :param Sequence['HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatchArgs'] add: Add adds the given header(s) (name, value) to the request
               before the action. It appends to any existing values associated
               with the header name.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 add:
                 - name: "my-header"
                   value: "bar,baz"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: foo,bar,baz
        :param Sequence[str] remove: Remove the given header(s) from the HTTP request before the action. The
               value of Remove is a list of HTTP header names. Note that the header
               names are case-insensitive (see
               https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
               
               Input:
                 GET /foo HTTP/1.1
                 my-header1: foo
                 my-header2: bar
                 my-header3: baz
               
               Config:
                 remove: ["my-header1", "my-header3"]
               
               Output:
                 GET /foo HTTP/1.1
                 my-header2: bar
        :param Sequence['HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatchArgs'] set: Set overwrites the request with the given header (name, value)
               before the action.
               
               Input:
                 GET /foo HTTP/1.1
                 my-header: foo
               
               Config:
                 set:
                 - name: "my-header"
                   value: "bar"
               
               Output:
                 GET /foo HTTP/1.1
                 my-header: bar
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierAddPatch']]:
        """
        Add adds the given header(s) (name, value) to the request
        before the action. It appends to any existing values associated
        with the header name.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          add:
          - name: "my-header"
            value: "bar,baz"

        Output:
          GET /foo HTTP/1.1
          my-header: foo,bar,baz
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        """
        Remove the given header(s) from the HTTP request before the action. The
        value of Remove is a list of HTTP header names. Note that the header
        names are case-insensitive (see
        https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).

        Input:
          GET /foo HTTP/1.1
          my-header1: foo
          my-header2: bar
          my-header3: baz

        Config:
          remove: ["my-header1", "my-header3"]

        Output:
          GET /foo HTTP/1.1
          my-header2: bar
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch']]:
        """
        Set overwrites the request with the given header (name, value)
        before the action.

        Input:
          GET /foo HTTP/1.1
          my-header: foo

        Config:
          set:
          - name: "my-header"
            value: "bar"

        Output:
          GET /foo HTTP/1.1
          my-header: bar
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierSet(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersResponseHeaderModifierSetPatch(dict):
    """
    HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, the first entry with
               an equivalent name MUST be considered for a match. Subsequent entries
               with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, the first entry with
        an equivalent name MUST be considered for a match. Subsequent entries
        with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersUrlRewrite(dict):
    """
    URLRewrite defines a schema for a filter that modifies a request during forwarding.

    Support: Extended
    """
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewritePath'] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param str hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewritePath']:
        return pulumi.get(self, "path")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersUrlRewritePatch(dict):
    """
    URLRewrite defines a schema for a filter that modifies a request during forwarding.

    Support: Extended
    """
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewritePathPatch'] = None):
        """
        URLRewrite defines a schema for a filter that modifies a request during forwarding.

        Support: Extended
        :param str hostname: Hostname is the value to be used to replace the Host header value during
               forwarding.
               
               Support: Extended
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname is the value to be used to replace the Host header value during
        forwarding.

        Support: Extended
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesFiltersUrlRewritePathPatch']:
        return pulumi.get(self, "path")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersUrlRewritePath(dict):
    """
    Path defines a path rewrite.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersUrlRewritePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersUrlRewritePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersUrlRewritePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesFiltersUrlRewritePathPatch(dict):
    """
    Path defines a path rewrite.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replaceFullPath":
            suggest = "replace_full_path"
        elif key == "replacePrefixMatch":
            suggest = "replace_prefix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesFiltersUrlRewritePathPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesFiltersUrlRewritePathPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesFiltersUrlRewritePathPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replace_full_path: Optional[str] = None,
                 replace_prefix_match: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Path defines a path rewrite.

        Support: Extended
        :param str replace_full_path: ReplaceFullPath specifies the value with which to replace the full path
               of a request during a rewrite or redirect.
        :param str replace_prefix_match: ReplacePrefixMatch specifies the value with which to replace the prefix
               match of a request during a rewrite or redirect. For example, a request
               to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
               of "/xyz" would be modified to "/xyz/bar".
               
               Note that this matches the behavior of the PathPrefix match type. This
               matches full path elements. A path element refers to the list of labels
               in the path split by the `/` separator. When specified, a trailing `/` is
               ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
               match the prefix `/abc`, but the path `/abcd` would not.
               
               ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
               Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
               the implementation setting the Accepted Condition for the Route to `status: False`.
               
               Request Path | Prefix Match | Replace Prefix | Modified Path
        :param str type: Type defines the type of path modifier. Additional types may be
               added in a future release of the API.
               
               Note that values may be added to this enum, implementations
               must ensure that unknown values will not cause a crash.
               
               Unknown values here must result in the implementation setting the
               Accepted Condition for the Route to `status: False`, with a
               Reason of `UnsupportedValue`.
        """
        if replace_full_path is not None:
            pulumi.set(__self__, "replace_full_path", replace_full_path)
        if replace_prefix_match is not None:
            pulumi.set(__self__, "replace_prefix_match", replace_prefix_match)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="replaceFullPath")
    def replace_full_path(self) -> Optional[str]:
        """
        ReplaceFullPath specifies the value with which to replace the full path
        of a request during a rewrite or redirect.
        """
        return pulumi.get(self, "replace_full_path")

    @property
    @pulumi.getter(name="replacePrefixMatch")
    def replace_prefix_match(self) -> Optional[str]:
        """
        ReplacePrefixMatch specifies the value with which to replace the prefix
        match of a request during a rewrite or redirect. For example, a request
        to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
        of "/xyz" would be modified to "/xyz/bar".

        Note that this matches the behavior of the PathPrefix match type. This
        matches full path elements. A path element refers to the list of labels
        in the path split by the `/` separator. When specified, a trailing `/` is
        ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
        match the prefix `/abc`, but the path `/abcd` would not.

        ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
        Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
        the implementation setting the Accepted Condition for the Route to `status: False`.

        Request Path | Prefix Match | Replace Prefix | Modified Path
        """
        return pulumi.get(self, "replace_prefix_match")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the type of path modifier. Additional types may be
        added in a future release of the API.

        Note that values may be added to this enum, implementations
        must ensure that unknown values will not cause a crash.

        Unknown values here must result in the implementation setting the
        Accepted Condition for the Route to `status: False`, with a
        Reason of `UnsupportedValue`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteSpecRulesMatches(dict):
    """
    HTTPRouteMatch defines the predicate used to match requests to a given
    action. Multiple match types are ANDed together, i.e. the match will
    evaluate to true only if all conditions are satisfied.

    For example, the match below will match a HTTP request only if its path
    starts with `/foo` AND it contains the `version: v1` header:

    ```
    match:

    	path:
    	  value: "/foo"
    	headers:
    	- name: "version"
    	  value "v1"

    ```
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParams":
            suggest = "query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesMatches. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesMatches.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesMatches.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesHeaders']] = None,
                 method: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesMatchesPath'] = None,
                 query_params: Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesQueryParams']] = None):
        """
        HTTPRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a HTTP request only if its path
        starts with `/foo` AND it contains the `version: v1` header:

        ```
        match:

        	path:
        	  value: "/foo"
        	headers:
        	- name: "version"
        	  value "v1"

        ```
        :param Sequence['HTTPRouteSpecRulesMatchesHeadersArgs'] headers: Headers specifies HTTP request header matchers. Multiple match values are
               ANDed together, meaning, a request must match all the specified headers
               to select the route.
        :param str method: Method specifies HTTP method matcher.
               When specified, this route will be matched only if the request has the
               specified method.
               
               Support: Extended
        :param Sequence['HTTPRouteSpecRulesMatchesQueryParamsArgs'] query_params: QueryParams specifies HTTP query parameter matchers. Multiple match
               values are ANDed together, meaning, a request must match all the
               specified query parameters to select the route.
               
               Support: Extended
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesHeaders']]:
        """
        Headers specifies HTTP request header matchers. Multiple match values are
        ANDed together, meaning, a request must match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Method specifies HTTP method matcher.
        When specified, this route will be matched only if the request has the
        specified method.

        Support: Extended
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesMatchesPath']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesQueryParams']]:
        """
        QueryParams specifies HTTP query parameter matchers. Multiple match
        values are ANDed together, meaning, a request must match all the
        specified query parameters to select the route.

        Support: Extended
        """
        return pulumi.get(self, "query_params")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesHeaders(dict):
    """
    HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
    headers.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
        headers.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
               
               When a header is repeated in an HTTP request, it is
               implementation-specific behavior as to how this is represented.
               Generally, proxies should follow the guidance from the RFC:
               https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
               processing a repeated header, with special handling for "Set-Cookie".
        :param str type: Type specifies how to match against the value of the header.
               
               Support: Core (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression HeaderMatchType has implementation-specific
               conformance, implementations can support POSIX, PCRE or any other dialects
               of regular expressions. Please read the implementation's documentation to
               determine the supported dialect.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.

        When a header is repeated in an HTTP request, it is
        implementation-specific behavior as to how this is represented.
        Generally, proxies should follow the guidance from the RFC:
        https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
        processing a repeated header, with special handling for "Set-Cookie".
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the value of the header.

        Support: Core (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression HeaderMatchType has implementation-specific
        conformance, implementations can support POSIX, PCRE or any other dialects
        of regular expressions. Please read the implementation's documentation to
        determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesHeadersPatch(dict):
    """
    HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
    headers.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
        headers.
        :param str name: Name is the name of the HTTP Header to be matched. Name matching MUST be
               case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
               
               If multiple entries specify equivalent header names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent header name MUST be ignored. Due to the
               case-insensitivity of header names, "foo" and "Foo" are considered
               equivalent.
               
               When a header is repeated in an HTTP request, it is
               implementation-specific behavior as to how this is represented.
               Generally, proxies should follow the guidance from the RFC:
               https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
               processing a repeated header, with special handling for "Set-Cookie".
        :param str type: Type specifies how to match against the value of the header.
               
               Support: Core (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression HeaderMatchType has implementation-specific
               conformance, implementations can support POSIX, PCRE or any other dialects
               of regular expressions. Please read the implementation's documentation to
               determine the supported dialect.
        :param str value: Value is the value of HTTP Header to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP Header to be matched. Name matching MUST be
        case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).

        If multiple entries specify equivalent header names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent header name MUST be ignored. Due to the
        case-insensitivity of header names, "foo" and "Foo" are considered
        equivalent.

        When a header is repeated in an HTTP request, it is
        implementation-specific behavior as to how this is represented.
        Generally, proxies should follow the guidance from the RFC:
        https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
        processing a repeated header, with special handling for "Set-Cookie".
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the value of the header.

        Support: Core (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression HeaderMatchType has implementation-specific
        conformance, implementations can support POSIX, PCRE or any other dialects
        of regular expressions. Please read the implementation's documentation to
        determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP Header to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesPatch(dict):
    """
    HTTPRouteMatch defines the predicate used to match requests to a given
    action. Multiple match types are ANDed together, i.e. the match will
    evaluate to true only if all conditions are satisfied.

    For example, the match below will match a HTTP request only if its path
    starts with `/foo` AND it contains the `version: v1` header:

    ```
    match:

    	path:
    	  value: "/foo"
    	headers:
    	- name: "version"
    	  value "v1"

    ```
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParams":
            suggest = "query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesMatchesPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesMatchesPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesMatchesPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesHeadersPatch']] = None,
                 method: Optional[str] = None,
                 path: Optional['outputs.HTTPRouteSpecRulesMatchesPathPatch'] = None,
                 query_params: Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesQueryParamsPatch']] = None):
        """
        HTTPRouteMatch defines the predicate used to match requests to a given
        action. Multiple match types are ANDed together, i.e. the match will
        evaluate to true only if all conditions are satisfied.

        For example, the match below will match a HTTP request only if its path
        starts with `/foo` AND it contains the `version: v1` header:

        ```
        match:

        	path:
        	  value: "/foo"
        	headers:
        	- name: "version"
        	  value "v1"

        ```
        :param Sequence['HTTPRouteSpecRulesMatchesHeadersPatchArgs'] headers: Headers specifies HTTP request header matchers. Multiple match values are
               ANDed together, meaning, a request must match all the specified headers
               to select the route.
        :param str method: Method specifies HTTP method matcher.
               When specified, this route will be matched only if the request has the
               specified method.
               
               Support: Extended
        :param Sequence['HTTPRouteSpecRulesMatchesQueryParamsPatchArgs'] query_params: QueryParams specifies HTTP query parameter matchers. Multiple match
               values are ANDed together, meaning, a request must match all the
               specified query parameters to select the route.
               
               Support: Extended
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesHeadersPatch']]:
        """
        Headers specifies HTTP request header matchers. Multiple match values are
        ANDed together, meaning, a request must match all the specified headers
        to select the route.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Method specifies HTTP method matcher.
        When specified, this route will be matched only if the request has the
        specified method.

        Support: Extended
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.HTTPRouteSpecRulesMatchesPathPatch']:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesQueryParamsPatch']]:
        """
        QueryParams specifies HTTP query parameter matchers. Multiple match
        values are ANDed together, meaning, a request must match all the
        specified query parameters to select the route.

        Support: Extended
        """
        return pulumi.get(self, "query_params")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesPath(dict):
    """
    Path specifies a HTTP request path matcher. If this field is not
    specified, a default prefix match on the "/" path is provided.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Path specifies a HTTP request path matcher. If this field is not
        specified, a default prefix match on the "/" path is provided.
        :param str type: Type specifies how to match against the path Value.
               
               Support: Core (Exact, PathPrefix)
               
               Support: Implementation-specific (RegularExpression)
        :param str value: Value of the HTTP path to match against.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the path Value.

        Support: Core (Exact, PathPrefix)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the HTTP path to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesPathPatch(dict):
    """
    Path specifies a HTTP request path matcher. If this field is not
    specified, a default prefix match on the "/" path is provided.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Path specifies a HTTP request path matcher. If this field is not
        specified, a default prefix match on the "/" path is provided.
        :param str type: Type specifies how to match against the path Value.
               
               Support: Core (Exact, PathPrefix)
               
               Support: Implementation-specific (RegularExpression)
        :param str value: Value of the HTTP path to match against.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the path Value.

        Support: Core (Exact, PathPrefix)

        Support: Implementation-specific (RegularExpression)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the HTTP path to match against.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesQueryParams(dict):
    """
    HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
    query parameters.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
        query parameters.
        :param str name: Name is the name of the HTTP query param to be matched. This must be an
               exact string match. (See
               https://tools.ietf.org/html/rfc7230#section-2.7.3).
               
               If multiple entries specify equivalent query param names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent query param name MUST be ignored.
               
               If a query param is repeated in an HTTP request, the behavior is
               purposely left undefined, since different data planes have different
               capabilities. However, it is *recommended* that implementations should
               match against the first value of the param if the data plane supports it,
               as this behavior is expected in other load balancing contexts outside of
               the Gateway API.
               
               Users SHOULD NOT route traffic based on repeated query params to guard
               themselves against potential differences in the implementations.
        :param str type: Type specifies how to match against the value of the query parameter.
               
               Support: Extended (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression QueryParamMatchType has Implementation-specific
               conformance, implementations can support POSIX, PCRE or any other
               dialects of regular expressions. Please read the implementation's
               documentation to determine the supported dialect.
        :param str value: Value is the value of HTTP query param to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP query param to be matched. This must be an
        exact string match. (See
        https://tools.ietf.org/html/rfc7230#section-2.7.3).

        If multiple entries specify equivalent query param names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent query param name MUST be ignored.

        If a query param is repeated in an HTTP request, the behavior is
        purposely left undefined, since different data planes have different
        capabilities. However, it is *recommended* that implementations should
        match against the first value of the param if the data plane supports it,
        as this behavior is expected in other load balancing contexts outside of
        the Gateway API.

        Users SHOULD NOT route traffic based on repeated query params to guard
        themselves against potential differences in the implementations.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the value of the query parameter.

        Support: Extended (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression QueryParamMatchType has Implementation-specific
        conformance, implementations can support POSIX, PCRE or any other
        dialects of regular expressions. Please read the implementation's
        documentation to determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP query param to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesMatchesQueryParamsPatch(dict):
    """
    HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
    query parameters.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
        query parameters.
        :param str name: Name is the name of the HTTP query param to be matched. This must be an
               exact string match. (See
               https://tools.ietf.org/html/rfc7230#section-2.7.3).
               
               If multiple entries specify equivalent query param names, only the first
               entry with an equivalent name MUST be considered for a match. Subsequent
               entries with an equivalent query param name MUST be ignored.
               
               If a query param is repeated in an HTTP request, the behavior is
               purposely left undefined, since different data planes have different
               capabilities. However, it is *recommended* that implementations should
               match against the first value of the param if the data plane supports it,
               as this behavior is expected in other load balancing contexts outside of
               the Gateway API.
               
               Users SHOULD NOT route traffic based on repeated query params to guard
               themselves against potential differences in the implementations.
        :param str type: Type specifies how to match against the value of the query parameter.
               
               Support: Extended (Exact)
               
               Support: Implementation-specific (RegularExpression)
               
               Since RegularExpression QueryParamMatchType has Implementation-specific
               conformance, implementations can support POSIX, PCRE or any other
               dialects of regular expressions. Please read the implementation's
               documentation to determine the supported dialect.
        :param str value: Value is the value of HTTP query param to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the HTTP query param to be matched. This must be an
        exact string match. (See
        https://tools.ietf.org/html/rfc7230#section-2.7.3).

        If multiple entries specify equivalent query param names, only the first
        entry with an equivalent name MUST be considered for a match. Subsequent
        entries with an equivalent query param name MUST be ignored.

        If a query param is repeated in an HTTP request, the behavior is
        purposely left undefined, since different data planes have different
        capabilities. However, it is *recommended* that implementations should
        match against the first value of the param if the data plane supports it,
        as this behavior is expected in other load balancing contexts outside of
        the Gateway API.

        Users SHOULD NOT route traffic based on repeated query params to guard
        themselves against potential differences in the implementations.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies how to match against the value of the query parameter.

        Support: Extended (Exact)

        Support: Implementation-specific (RegularExpression)

        Since RegularExpression QueryParamMatchType has Implementation-specific
        conformance, implementations can support POSIX, PCRE or any other
        dialects of regular expressions. Please read the implementation's
        documentation to determine the supported dialect.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the value of HTTP query param to be matched.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HTTPRouteSpecRulesPatch(dict):
    """
    HTTPRouteRule defines semantics for matching an HTTP request based on
    conditions (matches), processing it (filters), and forwarding the request to
    an API object (backendRefs).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRefs":
            suggest = "backend_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_refs: Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsPatch']] = None,
                 filters: Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersPatch']] = None,
                 matches: Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesPatch']] = None,
                 timeouts: Optional['outputs.HTTPRouteSpecRulesTimeoutsPatch'] = None):
        """
        HTTPRouteRule defines semantics for matching an HTTP request based on
        conditions (matches), processing it (filters), and forwarding the request to
        an API object (backendRefs).
        :param Sequence['HTTPRouteSpecRulesBackendRefsPatchArgs'] backend_refs: BackendRefs defines the backend(s) where matching requests should be
               sent.
               
               Failure behavior here depends on how many BackendRefs are specified and
               how many are invalid.
               
               If *all* entries in BackendRefs are invalid, and there are also no filters
               specified in this route rule, *all* traffic which matches this rule MUST
               receive a 500 status code.
               
               See the HTTPBackendRef definition for the rules about what makes a single
               HTTPBackendRef invalid.
               
               When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
               requests that would have otherwise been routed to an invalid backend. If
               multiple backends are specified, and some are invalid, the proportion of
               requests that would otherwise have been routed to an invalid backend
               MUST receive a 500 status code.
               
               For example, if two backends are specified with equal weights, and one is
               invalid, 50 percent of traffic must receive a 500. Implementations may
               choose how that 50 percent is determined.
               
               When a HTTPBackendRef refers to a Service that has no ready endpoints,
               implementations SHOULD return a 503 for requests to that backend instead.
               If an implementation chooses to do this, all of the above rules for 500 responses
               MUST also apply for responses that return a 503.
               
               Support: Core for Kubernetes Service
               
               Support: Extended for Kubernetes ServiceImport
               
               Support: Implementation-specific for any other resource
               
               Support for weight: Core
        :param Sequence['HTTPRouteSpecRulesFiltersPatchArgs'] filters: Filters define the filters that are applied to requests that match
               this rule.
               
               Wherever possible, implementations SHOULD implement filters in the order
               they are specified.
               
               Implementations MAY choose to implement this ordering strictly, rejecting
               any combination or order of filters that can not be supported. If implementations
               choose a strict interpretation of filter ordering, they MUST clearly document
               that behavior.
               
               To reject an invalid combination or order of filters, implementations SHOULD
               consider the Route Rules with this configuration invalid. If all Route Rules
               in a Route are invalid, the entire Route would be considered invalid. If only
               a portion of Route Rules are invalid, implementations MUST set the
               "PartiallyInvalid" condition for the Route.
               
               Conformance-levels at this level are defined based on the type of filter:
               
               - ALL core filters MUST be supported by all implementations.
               - Implementers are encouraged to support extended filters.
               - Implementation-specific custom filters have no API guarantees across
                 implementations.
               
               Specifying the same filter multiple times is not supported unless explicitly
               indicated in the filter.
               
               All filters are expected to be compatible with each other except for the
               URLRewrite and RequestRedirect filters, which may not be combined. If an
               implementation can not support other combinations of filters, they must clearly
               document that limitation. In cases where incompatible or unsupported
               filters are specified and cause the `Accepted` condition to be set to status
               `False`, implementations may use the `IncompatibleFilters` reason to specify
               this configuration error.
               
               Support: Core
        :param Sequence['HTTPRouteSpecRulesMatchesPatchArgs'] matches: Matches define conditions used for matching the rule against incoming
               HTTP requests. Each match is independent, i.e. this rule will be matched
               if **any** one of the matches is satisfied.
               
               For example, take the following matches configuration:
               
               ```
               matches:
               - path:
                   value: "/foo"
                 headers:
                 - name: "version"
                   value: "v2"
               - path:
                   value: "/v2/foo"
               ```
               
               For a request to match against this rule, a request must satisfy
               EITHER of the two conditions:
               
               - path prefixed with `/foo` AND contains the header `version: v2`
               - path prefix of `/v2/foo`
               
               See the documentation for HTTPRouteMatch on how to specify multiple
               match conditions that should be ANDed together.
               
               If no matches are specified, the default is a prefix
               path match on "/", which has the effect of matching every
               HTTP request.
               
               Proxy or Load Balancer routing configuration generated from HTTPRoutes
               MUST prioritize matches based on the following criteria, continuing on
               ties. Across all rules specified on applicable Routes, precedence must be
               given to the match having:
               
               * "Exact" path match.
               * "Prefix" path match with largest number of characters.
               * Method match.
               * Largest number of header matches.
               * Largest number of query param matches.
               
               Note: The precedence of RegularExpression path matches are implementation-specific.
               
               If ties still exist across multiple Routes, matching precedence MUST be
               determined in order of the following criteria, continuing on ties:
               
               * The oldest Route based on creation timestamp.
               * The Route appearing first in alphabetical order by
                 "{namespace}/{name}".
               
               If ties still exist within an HTTPRoute, matching precedence MUST be granted
               to the FIRST matching rule (in list order) with a match meeting the above
               criteria.
               
               When no rules matching a request have been successfully attached to the
               parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        if backend_refs is not None:
            pulumi.set(__self__, "backend_refs", backend_refs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @property
    @pulumi.getter(name="backendRefs")
    def backend_refs(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesBackendRefsPatch']]:
        """
        BackendRefs defines the backend(s) where matching requests should be
        sent.

        Failure behavior here depends on how many BackendRefs are specified and
        how many are invalid.

        If *all* entries in BackendRefs are invalid, and there are also no filters
        specified in this route rule, *all* traffic which matches this rule MUST
        receive a 500 status code.

        See the HTTPBackendRef definition for the rules about what makes a single
        HTTPBackendRef invalid.

        When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
        requests that would have otherwise been routed to an invalid backend. If
        multiple backends are specified, and some are invalid, the proportion of
        requests that would otherwise have been routed to an invalid backend
        MUST receive a 500 status code.

        For example, if two backends are specified with equal weights, and one is
        invalid, 50 percent of traffic must receive a 500. Implementations may
        choose how that 50 percent is determined.

        When a HTTPBackendRef refers to a Service that has no ready endpoints,
        implementations SHOULD return a 503 for requests to that backend instead.
        If an implementation chooses to do this, all of the above rules for 500 responses
        MUST also apply for responses that return a 503.

        Support: Core for Kubernetes Service

        Support: Extended for Kubernetes ServiceImport

        Support: Implementation-specific for any other resource

        Support for weight: Core
        """
        return pulumi.get(self, "backend_refs")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesFiltersPatch']]:
        """
        Filters define the filters that are applied to requests that match
        this rule.

        Wherever possible, implementations SHOULD implement filters in the order
        they are specified.

        Implementations MAY choose to implement this ordering strictly, rejecting
        any combination or order of filters that can not be supported. If implementations
        choose a strict interpretation of filter ordering, they MUST clearly document
        that behavior.

        To reject an invalid combination or order of filters, implementations SHOULD
        consider the Route Rules with this configuration invalid. If all Route Rules
        in a Route are invalid, the entire Route would be considered invalid. If only
        a portion of Route Rules are invalid, implementations MUST set the
        "PartiallyInvalid" condition for the Route.

        Conformance-levels at this level are defined based on the type of filter:

        - ALL core filters MUST be supported by all implementations.
        - Implementers are encouraged to support extended filters.
        - Implementation-specific custom filters have no API guarantees across
          implementations.

        Specifying the same filter multiple times is not supported unless explicitly
        indicated in the filter.

        All filters are expected to be compatible with each other except for the
        URLRewrite and RequestRedirect filters, which may not be combined. If an
        implementation can not support other combinations of filters, they must clearly
        document that limitation. In cases where incompatible or unsupported
        filters are specified and cause the `Accepted` condition to be set to status
        `False`, implementations may use the `IncompatibleFilters` reason to specify
        this configuration error.

        Support: Core
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.HTTPRouteSpecRulesMatchesPatch']]:
        """
        Matches define conditions used for matching the rule against incoming
        HTTP requests. Each match is independent, i.e. this rule will be matched
        if **any** one of the matches is satisfied.

        For example, take the following matches configuration:

        ```
        matches:
        - path:
            value: "/foo"
          headers:
          - name: "version"
            value: "v2"
        - path:
            value: "/v2/foo"
        ```

        For a request to match against this rule, a request must satisfy
        EITHER of the two conditions:

        - path prefixed with `/foo` AND contains the header `version: v2`
        - path prefix of `/v2/foo`

        See the documentation for HTTPRouteMatch on how to specify multiple
        match conditions that should be ANDed together.

        If no matches are specified, the default is a prefix
        path match on "/", which has the effect of matching every
        HTTP request.

        Proxy or Load Balancer routing configuration generated from HTTPRoutes
        MUST prioritize matches based on the following criteria, continuing on
        ties. Across all rules specified on applicable Routes, precedence must be
        given to the match having:

        * "Exact" path match.
        * "Prefix" path match with largest number of characters.
        * Method match.
        * Largest number of header matches.
        * Largest number of query param matches.

        Note: The precedence of RegularExpression path matches are implementation-specific.

        If ties still exist across multiple Routes, matching precedence MUST be
        determined in order of the following criteria, continuing on ties:

        * The oldest Route based on creation timestamp.
        * The Route appearing first in alphabetical order by
          "{namespace}/{name}".

        If ties still exist within an HTTPRoute, matching precedence MUST be granted
        to the FIRST matching rule (in list order) with a match meeting the above
        criteria.

        When no rules matching a request have been successfully attached to the
        parent a request is coming from, a HTTP 404 status code MUST be returned.
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def timeouts(self) -> Optional['outputs.HTTPRouteSpecRulesTimeoutsPatch']:
        return pulumi.get(self, "timeouts")


@pulumi.output_type
class HTTPRouteSpecRulesTimeouts(dict):
    """
    Timeouts defines the timeouts that can be configured for an HTTP request.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRequest":
            suggest = "backend_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesTimeouts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesTimeouts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesTimeouts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_request: Optional[str] = None,
                 request: Optional[str] = None):
        """
        Timeouts defines the timeouts that can be configured for an HTTP request.

        Support: Extended
        :param str backend_request: BackendRequest specifies a timeout for an individual request from the gateway
               to a backend. This covers the time from when the request first starts being
               sent from the gateway to when the full response has been received from the backend.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               An entire client HTTP transaction with a gateway, covered by the Request timeout,
               may result in more than one call from the gateway to the destination backend,
               for example, if automatic retries are supported.
               
               The value of BackendRequest must be a Gateway API Duration string as defined by
               GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
               when specified, the value of BackendRequest must be no more than the value of the
               Request timeout (since the Request timeout encompasses the BackendRequest timeout).
               
               Support: Extended
        :param str request: Request specifies the maximum duration for a gateway to respond to an HTTP request.
               If the gateway has not been able to respond before this deadline is met, the gateway
               MUST return a timeout error.
               
               For example, setting the `rules.timeouts.request` field to the value `10s` in an
               `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
               to complete.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               This timeout is intended to cover as close to the whole request-response transaction
               as possible although an implementation MAY choose to start the timeout after the entire
               request stream has been received instead of immediately after the transaction is
               initiated by the client.
               
               The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
               field is unspecified, request timeout behavior is implementation-specific.
               
               Support: Extended
        """
        if backend_request is not None:
            pulumi.set(__self__, "backend_request", backend_request)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @property
    @pulumi.getter(name="backendRequest")
    def backend_request(self) -> Optional[str]:
        """
        BackendRequest specifies a timeout for an individual request from the gateway
        to a backend. This covers the time from when the request first starts being
        sent from the gateway to when the full response has been received from the backend.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        An entire client HTTP transaction with a gateway, covered by the Request timeout,
        may result in more than one call from the gateway to the destination backend,
        for example, if automatic retries are supported.

        The value of BackendRequest must be a Gateway API Duration string as defined by
        GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
        when specified, the value of BackendRequest must be no more than the value of the
        Request timeout (since the Request timeout encompasses the BackendRequest timeout).

        Support: Extended
        """
        return pulumi.get(self, "backend_request")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        Request specifies the maximum duration for a gateway to respond to an HTTP request.
        If the gateway has not been able to respond before this deadline is met, the gateway
        MUST return a timeout error.

        For example, setting the `rules.timeouts.request` field to the value `10s` in an
        `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
        to complete.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        This timeout is intended to cover as close to the whole request-response transaction
        as possible although an implementation MAY choose to start the timeout after the entire
        request stream has been received instead of immediately after the transaction is
        initiated by the client.

        The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
        field is unspecified, request timeout behavior is implementation-specific.

        Support: Extended
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class HTTPRouteSpecRulesTimeoutsPatch(dict):
    """
    Timeouts defines the timeouts that can be configured for an HTTP request.

    Support: Extended
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendRequest":
            suggest = "backend_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteSpecRulesTimeoutsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteSpecRulesTimeoutsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteSpecRulesTimeoutsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_request: Optional[str] = None,
                 request: Optional[str] = None):
        """
        Timeouts defines the timeouts that can be configured for an HTTP request.

        Support: Extended
        :param str backend_request: BackendRequest specifies a timeout for an individual request from the gateway
               to a backend. This covers the time from when the request first starts being
               sent from the gateway to when the full response has been received from the backend.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               An entire client HTTP transaction with a gateway, covered by the Request timeout,
               may result in more than one call from the gateway to the destination backend,
               for example, if automatic retries are supported.
               
               The value of BackendRequest must be a Gateway API Duration string as defined by
               GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
               when specified, the value of BackendRequest must be no more than the value of the
               Request timeout (since the Request timeout encompasses the BackendRequest timeout).
               
               Support: Extended
        :param str request: Request specifies the maximum duration for a gateway to respond to an HTTP request.
               If the gateway has not been able to respond before this deadline is met, the gateway
               MUST return a timeout error.
               
               For example, setting the `rules.timeouts.request` field to the value `10s` in an
               `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
               to complete.
               
               Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
               completely. Implementations that cannot completely disable the timeout MUST
               instead interpret the zero duration as the longest possible value to which
               the timeout can be set.
               
               This timeout is intended to cover as close to the whole request-response transaction
               as possible although an implementation MAY choose to start the timeout after the entire
               request stream has been received instead of immediately after the transaction is
               initiated by the client.
               
               The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
               field is unspecified, request timeout behavior is implementation-specific.
               
               Support: Extended
        """
        if backend_request is not None:
            pulumi.set(__self__, "backend_request", backend_request)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @property
    @pulumi.getter(name="backendRequest")
    def backend_request(self) -> Optional[str]:
        """
        BackendRequest specifies a timeout for an individual request from the gateway
        to a backend. This covers the time from when the request first starts being
        sent from the gateway to when the full response has been received from the backend.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        An entire client HTTP transaction with a gateway, covered by the Request timeout,
        may result in more than one call from the gateway to the destination backend,
        for example, if automatic retries are supported.

        The value of BackendRequest must be a Gateway API Duration string as defined by
        GEP-2257.  When this field is unspecified, its behavior is implementation-specific;
        when specified, the value of BackendRequest must be no more than the value of the
        Request timeout (since the Request timeout encompasses the BackendRequest timeout).

        Support: Extended
        """
        return pulumi.get(self, "backend_request")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        Request specifies the maximum duration for a gateway to respond to an HTTP request.
        If the gateway has not been able to respond before this deadline is met, the gateway
        MUST return a timeout error.

        For example, setting the `rules.timeouts.request` field to the value `10s` in an
        `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
        to complete.

        Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
        completely. Implementations that cannot completely disable the timeout MUST
        instead interpret the zero duration as the longest possible value to which
        the timeout can be set.

        This timeout is intended to cover as close to the whole request-response transaction
        as possible although an implementation MAY choose to start the timeout after the entire
        request stream has been received instead of immediately after the transaction is
        initiated by the client.

        The value of Request is a Gateway API Duration string as defined by GEP-2257. When this
        field is unspecified, request timeout behavior is implementation-specific.

        Support: Extended
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class HTTPRouteStatus(dict):
    """
    Status defines the current state of HTTPRoute.
    """
    def __init__(__self__, *,
                 parents: Optional[Sequence['outputs.HTTPRouteStatusParents']] = None):
        """
        Status defines the current state of HTTPRoute.
        :param Sequence['HTTPRouteStatusParentsArgs'] parents: Parents is a list of parent resources (usually Gateways) that are
               associated with the route, and the status of the route with respect to
               each parent. When this route attaches to a parent, the controller that
               manages the parent must add an entry to this list when the controller
               first sees the route and should update the entry as appropriate when the
               route or gateway is modified.
               
               Note that parent references that cannot be resolved by an implementation
               of this API will not be added to this list. Implementations of this API
               can only populate Route status for the Gateways/parent resources they are
               responsible for.
               
               A maximum of 32 Gateways will be represented in this list. An empty list
               means the route has not been attached to any Gateway.
        """
        if parents is not None:
            pulumi.set(__self__, "parents", parents)

    @property
    @pulumi.getter
    def parents(self) -> Optional[Sequence['outputs.HTTPRouteStatusParents']]:
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
        return pulumi.get(self, "parents")


@pulumi.output_type
class HTTPRouteStatusParents(dict):
    """
    RouteParentStatus describes the status of a route with respect to an
    associated Parent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerName":
            suggest = "controller_name"
        elif key == "parentRef":
            suggest = "parent_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteStatusParents. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteStatusParents.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteStatusParents.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.HTTPRouteStatusParentsConditions']] = None,
                 controller_name: Optional[str] = None,
                 parent_ref: Optional['outputs.HTTPRouteStatusParentsParentRef'] = None):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        :param Sequence['HTTPRouteStatusParentsConditionsArgs'] conditions: Conditions describes the status of the route with respect to the Gateway.
               Note that the route's availability is also subject to the Gateway's own
               status conditions and listener status.
               
               If the Route's ParentRef specifies an existing Gateway that supports
               Routes of this kind AND that Gateway's controller has sufficient access,
               then that Gateway's controller MUST set the "Accepted" condition on the
               Route, to indicate whether the route has been accepted or rejected by the
               Gateway, and why.
               
               A Route MUST be considered "Accepted" if at least one of the Route's
               rules is implemented by the Gateway.
               
               There are a number of cases where the "Accepted" condition may not be set
               due to lack of controller visibility, that includes when:
               
               * The Route refers to a non-existent parent.
               * The Route is of a type that the controller does not support.
               * The Route is in a namespace the controller does not have access to.
        :param str controller_name: ControllerName is a domain/path string that indicates the name of the
               controller that wrote this status. This corresponds with the
               controllerName field on GatewayClass.
               
               Example: "example.net/gateway-controller".
               
               The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
               valid Kubernetes names
               (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
               
               Controllers MUST populate this field when writing status. Controllers should ensure that
               entries to status populated with their ControllerName are cleaned up when they are no
               longer necessary.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if parent_ref is not None:
            pulumi.set(__self__, "parent_ref", parent_ref)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.HTTPRouteStatusParentsConditions']]:
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[str]:
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        return pulumi.get(self, "controller_name")

    @property
    @pulumi.getter(name="parentRef")
    def parent_ref(self) -> Optional['outputs.HTTPRouteStatusParentsParentRef']:
        return pulumi.get(self, "parent_ref")


@pulumi.output_type
class HTTPRouteStatusParentsConditions(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteStatusParentsConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteStatusParentsConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteStatusParentsConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteStatusParentsConditionsPatch(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteStatusParentsConditionsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteStatusParentsConditionsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteStatusParentsConditionsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource.
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another.
               This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition.
               This may be an empty string.
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon.
               For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
               with respect to the current state of the instance.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition.
               Producers of specific condition types may define expected values and meanings for this field,
               and whether the values are considered a guaranteed API.
               The value should be a CamelCase string.
               This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another.
        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        message is a human readable message indicating details about the transition.
        This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon.
        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
        with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition.
        Producers of specific condition types may define expected values and meanings for this field,
        and whether the values are considered a guaranteed API.
        The value should be a CamelCase string.
        This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HTTPRouteStatusParentsParentRef(dict):
    """
    ParentRef corresponds with a ParentRef in the spec that this
    RouteParentStatus struct describes the status of.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteStatusParentsParentRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteStatusParentsParentRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteStatusParentsParentRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class HTTPRouteStatusParentsParentRefPatch(dict):
    """
    ParentRef corresponds with a ParentRef in the spec that this
    RouteParentStatus struct describes the status of.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sectionName":
            suggest = "section_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteStatusParentsParentRefPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteStatusParentsParentRefPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteStatusParentsParentRefPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 port: Optional[int] = None,
                 section_name: Optional[str] = None):
        """
        ParentRef corresponds with a ParentRef in the spec that this
        RouteParentStatus struct describes the status of.
        :param str group: Group is the group of the referent.
               When unspecified, "gateway.networking.k8s.io" is inferred.
               To set the core API group (such as for a "Service" kind referent),
               Group must be explicitly set to "" (empty string).
               
               Support: Core
        :param str kind: Kind is kind of the referent.
               
               There are two kinds of parent resources with "Core" support:
               
               * Gateway (Gateway conformance profile)
               * Service (Mesh conformance profile, ClusterIP Services only)
               
               Support for other resources is Implementation-Specific.
        :param str name: Name is the name of the referent.
               
               Support: Core
        :param str namespace: Namespace is the namespace of the referent. When unspecified, this refers
               to the local namespace of the Route.
               
               Note that there are specific rules for ParentRefs which cross namespace
               boundaries. Cross-namespace references are only valid if they are explicitly
               allowed by something in the namespace they are referring to. For example:
               Gateway has the AllowedRoutes field, and ReferenceGrant provides a
               generic way to enable any other kind of cross-namespace reference.
               
               
               
               Support: Core
        :param int port: Port is the network port this Route targets. It can be interpreted
               differently based on the type of parent resource.
               
               When the parent resource is a Gateway, this targets all listeners
               listening on the specified port that also support this kind of Route(and
               select this Route). It's not recommended to set `Port` unless the
               networking behaviors specified in a Route must apply to a specific port
               as opposed to a listener(s) whose port(s) may be changed. When both Port
               and SectionName are specified, the name and port of the selected listener
               must match both specified values.
               
               
               
               Implementations MAY choose to support other parent resources.
               Implementations supporting other types of parent resources MUST clearly
               document how/if Port is interpreted.
               
               For the purpose of status, an attachment is considered successful as
               long as the parent resource accepts it partially. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
               from the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route,
               the Route MUST be considered detached from the Gateway.
               
               Support: Extended
        :param str section_name: SectionName is the name of a section within the target resource. In the
               following resources, SectionName is interpreted as the following:
               
               * Gateway: Listener name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               * Service: Port name. When both Port (experimental) and SectionName
               are specified, the name and port of the selected listener must match
               both specified values.
               
               Implementations MAY choose to support attaching Routes to other resources.
               If that is the case, they MUST clearly document how SectionName is
               interpreted.
               
               When unspecified (empty string), this will reference the entire resource.
               For the purpose of status, an attachment is considered successful if at
               least one section in the parent resource accepts it. For example, Gateway
               listeners can restrict which Routes can attach to them by Route kind,
               namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
               the referencing Route, the Route MUST be considered successfully
               attached. If no Gateway listeners accept attachment from this Route, the
               Route MUST be considered detached from the Gateway.
               
               Support: Core
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if section_name is not None:
            pulumi.set(__self__, "section_name", section_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group is the group of the referent.
        When unspecified, "gateway.networking.k8s.io" is inferred.
        To set the core API group (such as for a "Service" kind referent),
        Group must be explicitly set to "" (empty string).

        Support: Core
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind is kind of the referent.

        There are two kinds of parent resources with "Core" support:

        * Gateway (Gateway conformance profile)
        * Service (Mesh conformance profile, ClusterIP Services only)

        Support for other resources is Implementation-Specific.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name is the name of the referent.

        Support: Core
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace is the namespace of the referent. When unspecified, this refers
        to the local namespace of the Route.

        Note that there are specific rules for ParentRefs which cross namespace
        boundaries. Cross-namespace references are only valid if they are explicitly
        allowed by something in the namespace they are referring to. For example:
        Gateway has the AllowedRoutes field, and ReferenceGrant provides a
        generic way to enable any other kind of cross-namespace reference.



        Support: Core
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port is the network port this Route targets. It can be interpreted
        differently based on the type of parent resource.

        When the parent resource is a Gateway, this targets all listeners
        listening on the specified port that also support this kind of Route(and
        select this Route). It's not recommended to set `Port` unless the
        networking behaviors specified in a Route must apply to a specific port
        as opposed to a listener(s) whose port(s) may be changed. When both Port
        and SectionName are specified, the name and port of the selected listener
        must match both specified values.



        Implementations MAY choose to support other parent resources.
        Implementations supporting other types of parent resources MUST clearly
        document how/if Port is interpreted.

        For the purpose of status, an attachment is considered successful as
        long as the parent resource accepts it partially. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
        from the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route,
        the Route MUST be considered detached from the Gateway.

        Support: Extended
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sectionName")
    def section_name(self) -> Optional[str]:
        """
        SectionName is the name of a section within the target resource. In the
        following resources, SectionName is interpreted as the following:

        * Gateway: Listener name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.
        * Service: Port name. When both Port (experimental) and SectionName
        are specified, the name and port of the selected listener must match
        both specified values.

        Implementations MAY choose to support attaching Routes to other resources.
        If that is the case, they MUST clearly document how SectionName is
        interpreted.

        When unspecified (empty string), this will reference the entire resource.
        For the purpose of status, an attachment is considered successful if at
        least one section in the parent resource accepts it. For example, Gateway
        listeners can restrict which Routes can attach to them by Route kind,
        namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
        the referencing Route, the Route MUST be considered successfully
        attached. If no Gateway listeners accept attachment from this Route, the
        Route MUST be considered detached from the Gateway.

        Support: Core
        """
        return pulumi.get(self, "section_name")


@pulumi.output_type
class HTTPRouteStatusParentsPatch(dict):
    """
    RouteParentStatus describes the status of a route with respect to an
    associated Parent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerName":
            suggest = "controller_name"
        elif key == "parentRef":
            suggest = "parent_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HTTPRouteStatusParentsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HTTPRouteStatusParentsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HTTPRouteStatusParentsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.HTTPRouteStatusParentsConditionsPatch']] = None,
                 controller_name: Optional[str] = None,
                 parent_ref: Optional['outputs.HTTPRouteStatusParentsParentRefPatch'] = None):
        """
        RouteParentStatus describes the status of a route with respect to an
        associated Parent.
        :param Sequence['HTTPRouteStatusParentsConditionsPatchArgs'] conditions: Conditions describes the status of the route with respect to the Gateway.
               Note that the route's availability is also subject to the Gateway's own
               status conditions and listener status.
               
               If the Route's ParentRef specifies an existing Gateway that supports
               Routes of this kind AND that Gateway's controller has sufficient access,
               then that Gateway's controller MUST set the "Accepted" condition on the
               Route, to indicate whether the route has been accepted or rejected by the
               Gateway, and why.
               
               A Route MUST be considered "Accepted" if at least one of the Route's
               rules is implemented by the Gateway.
               
               There are a number of cases where the "Accepted" condition may not be set
               due to lack of controller visibility, that includes when:
               
               * The Route refers to a non-existent parent.
               * The Route is of a type that the controller does not support.
               * The Route is in a namespace the controller does not have access to.
        :param str controller_name: ControllerName is a domain/path string that indicates the name of the
               controller that wrote this status. This corresponds with the
               controllerName field on GatewayClass.
               
               Example: "example.net/gateway-controller".
               
               The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
               valid Kubernetes names
               (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
               
               Controllers MUST populate this field when writing status. Controllers should ensure that
               entries to status populated with their ControllerName are cleaned up when they are no
               longer necessary.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if controller_name is not None:
            pulumi.set(__self__, "controller_name", controller_name)
        if parent_ref is not None:
            pulumi.set(__self__, "parent_ref", parent_ref)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.HTTPRouteStatusParentsConditionsPatch']]:
        """
        Conditions describes the status of the route with respect to the Gateway.
        Note that the route's availability is also subject to the Gateway's own
        status conditions and listener status.

        If the Route's ParentRef specifies an existing Gateway that supports
        Routes of this kind AND that Gateway's controller has sufficient access,
        then that Gateway's controller MUST set the "Accepted" condition on the
        Route, to indicate whether the route has been accepted or rejected by the
        Gateway, and why.

        A Route MUST be considered "Accepted" if at least one of the Route's
        rules is implemented by the Gateway.

        There are a number of cases where the "Accepted" condition may not be set
        due to lack of controller visibility, that includes when:

        * The Route refers to a non-existent parent.
        * The Route is of a type that the controller does not support.
        * The Route is in a namespace the controller does not have access to.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="controllerName")
    def controller_name(self) -> Optional[str]:
        """
        ControllerName is a domain/path string that indicates the name of the
        controller that wrote this status. This corresponds with the
        controllerName field on GatewayClass.

        Example: "example.net/gateway-controller".

        The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
        valid Kubernetes names
        (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).

        Controllers MUST populate this field when writing status. Controllers should ensure that
        entries to status populated with their ControllerName are cleaned up when they are no
        longer necessary.
        """
        return pulumi.get(self, "controller_name")

    @property
    @pulumi.getter(name="parentRef")
    def parent_ref(self) -> Optional['outputs.HTTPRouteStatusParentsParentRefPatch']:
        return pulumi.get(self, "parent_ref")


@pulumi.output_type
class HTTPRouteStatusPatch(dict):
    """
    Status defines the current state of HTTPRoute.
    """
    def __init__(__self__, *,
                 parents: Optional[Sequence['outputs.HTTPRouteStatusParentsPatch']] = None):
        """
        Status defines the current state of HTTPRoute.
        :param Sequence['HTTPRouteStatusParentsPatchArgs'] parents: Parents is a list of parent resources (usually Gateways) that are
               associated with the route, and the status of the route with respect to
               each parent. When this route attaches to a parent, the controller that
               manages the parent must add an entry to this list when the controller
               first sees the route and should update the entry as appropriate when the
               route or gateway is modified.
               
               Note that parent references that cannot be resolved by an implementation
               of this API will not be added to this list. Implementations of this API
               can only populate Route status for the Gateways/parent resources they are
               responsible for.
               
               A maximum of 32 Gateways will be represented in this list. An empty list
               means the route has not been attached to any Gateway.
        """
        if parents is not None:
            pulumi.set(__self__, "parents", parents)

    @property
    @pulumi.getter
    def parents(self) -> Optional[Sequence['outputs.HTTPRouteStatusParentsPatch']]:
        """
        Parents is a list of parent resources (usually Gateways) that are
        associated with the route, and the status of the route with respect to
        each parent. When this route attaches to a parent, the controller that
        manages the parent must add an entry to this list when the controller
        first sees the route and should update the entry as appropriate when the
        route or gateway is modified.

        Note that parent references that cannot be resolved by an implementation
        of this API will not be added to this list. Implementations of this API
        can only populate Route status for the Gateways/parent resources they are
        responsible for.

        A maximum of 32 Gateways will be represented in this list. An empty list
        means the route has not been attached to any Gateway.
        """
        return pulumi.get(self, "parents")


